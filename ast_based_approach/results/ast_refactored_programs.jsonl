{"name": "program_7", "description": "Is it below e", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A ship tile is unrevealed if true_board>0 but partial_board==-1 there\n    unrevealed = (true_board > 0) & (partial_board == -1)\n    # Row indices of all unrevealed ship tiles\n    rows, cols = np.nonzero(unrevealed)\n    # Row \"E\" is index 4 (0\u2192A, 1\u2192B, \u2026, 4\u2192E).  Test if any tile is below it.\n    return bool(np.any(rows > 4))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask, row_to_index\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is it below e\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    rows, _ = np.nonzero(mask)\n    return bool(np.any(rows > row_to_index('E')))\n", "strategy": "ast_range_query", "original_length": 423, "refactored_length": 312, "savings": 111}
{"name": "program_11", "description": "Is there a ship after d5 and before column 5?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Captain asked: \"Is there a ship after d5 and before column 5?\"\n    Interpreting \"after d5\" as any row > D (i.e. rows E\u2013H) \n    and \"before column 5\" as columns 1\u20134.\n    We return True if there is any unrevealed ship cell in that region.\n    \"\"\"\n    # Row index of 'D' is 3 (A=0, B=1, C=2, D=3)\n    # Column index of '5' is 4 (1\u21920, 2\u21921, \u2026, 5\u21924)\n    \n    # Build a mask for the region: rows > 3 (E\u2013H), cols < 4 (1\u20134)\n    n_rows, n_cols = true_board.shape\n    row_idx = np.arange(n_rows)[:, None]   # shape (n_rows, 1)\n    col_idx = np.arange(n_cols)[None, :]   # shape (1, n_cols)\n    region_mask = (row_idx > 3) & (col_idx < 4)\n    \n    # Mask of unrevealed ship cells\n    # Ship cells in true_board are > 0, and still hidden in partial_board == -1\n    unrevealed_ship_mask = (true_board > 0) & (partial_board == -1)\n    \n    # If any such cell lies in our region, answer is True\n    return bool(np.any(region_mask & unrevealed_ship_mask))\n", "refactored": "import numpy as np\nfrom ast_helpers import has_unrevealed_in_col, col_to_index\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is there a ship after d5 and before column 5?\"\"\"\n    return has_unrevealed_in_col(true_board, partial_board, col_to_index(5))\n", "strategy": "ast_col_query", "original_length": 1043, "refactored_length": 284, "savings": 759}
{"name": "program_25", "description": "is it on c", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in row C,\n    otherwise False.\n    \"\"\"\n    # Compute a mask of all unrevealed ship tiles\n    unrevealed = (true_board > 0) & (partial_board == -1)\n    # Row C corresponds to index 2 (A=0, B=1, C=2)\n    return bool(np.any(unrevealed[2, :]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is it on c\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 403, "refactored_length": 244, "savings": 159}
{"name": "program_28", "description": "Is one on or below e", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # mask of unrevealed ship tiles\n    unrevealed_ship = (true_board > 0) & (partial_board == -1)\n    # check rows E\u2013H (index 4 through 7)\n    return bool(unrevealed_ship[4:, :].any())\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask, row_to_index\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is one on or below e\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    rows, _ = np.nonzero(mask)\n    return bool(np.any(rows > row_to_index('E')))\n", "strategy": "ast_range_query", "original_length": 278, "refactored_length": 319, "savings": -41}
{"name": "program_29", "description": "is it afte r4", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all still-hidden ship cells:\n    hidden_ship = (true_board > 0) & (partial_board == -1)\n    # Build an array of column indices, shape (1, ncols), values 0..ncols-1\n    cols = np.arange(true_board.shape[1])[None, :]\n    # Check if any hidden ship lies in a column after column 4 (i.e. index >= 4)\n    after4 = cols >= 4\n    return bool(np.any(hidden_ship & after4))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is it afte r4\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 468, "refactored_length": 247, "savings": 221}
{"name": "program_32", "description": "is it on or before c6 or d6?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines whether there is any unrevealed ship tile in rows A\u2013D and columns 1\u20136,\n    i.e. on or before C6 or D6 (regions up to row D, column 6).\n    \"\"\"\n    # Rows A\u2013D correspond to indices 0\u20133, columns 1\u20136 correspond to indices 0\u20135\n    region_mask = np.zeros_like(true_board, dtype=bool)\n    region_mask[:4, :6] = True\n\n    # A ship tile is true_board > 0; unrevealed means partial_board == -1\n    hidden_ships_in_region = (true_board > 0) & (partial_board == -1) & region_mask\n\n    return bool(np.any(hidden_ships_in_region))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is it on or before c6 or d6?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 633, "refactored_length": 262, "savings": 371}
{"name": "program_33", "description": "Is the green ship vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the green ship (value == 2)\n    green_coords = np.argwhere(true_board == 2)\n    \n    # If there are fewer than 2 tiles, it's not a valid (length>=2) ship,\n    # so we treat it as not vertical.\n    if green_coords.shape[0] < 2:\n        return False\n    \n    # Extract the column indices of those tiles\n    cols = green_coords[:, 1]\n    \n    # If all column indices are the same, the ship is placed vertically\n    return np.all(cols == cols[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the green ship vertical?\"\"\"\n    coords = get_ship_coords(true_board, 2)  # green\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 569, "refactored_length": 266, "savings": 303}
{"name": "program_41", "description": "Is on on e or c", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed ship tile in row C or row E,\n    given the full true_board and the current partial_board view.\n    Row indices: A=0, B=1, C=2, D=3, E=4, ...\n    An unrevealed ship tile is one where partial_board == -1 and true_board > 0.\n    \"\"\"\n    # Create a mask of unrevealed ship tiles\n    unrevealed_ship = (partial_board == -1) & (true_board > 0)\n\n    # Check rows C (index 2) and E (index 4)\n    return bool(np.any(unrevealed_ship[2]) or np.any(unrevealed_ship[4]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is on on e or c\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 602, "refactored_length": 249, "savings": 353}
{"name": "program_42", "description": "is orange vertical", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the Orange ship (marked with 4)\n    orange_positions = np.argwhere(true_board == 4)\n    # Extract the column indices of those positions\n    cols = orange_positions[:, 1]\n    # If all columns are the same, the ship is vertical\n    return np.all(cols == cols[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is orange vertical\"\"\"\n    coords = get_ship_coords(true_board, 4)  # orange\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 387, "refactored_length": 258, "savings": 129}
{"name": "program_47", "description": "is it Directly below orange", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is any ship tile immediately below the Orange ship.\n    Orange ship tiles are marked with 4 in true_board.\n    \"\"\"\n    # find all the coordinates of the orange ship\n    orange_coords = np.argwhere(true_board == 4)\n    if orange_coords.size == 0:\n        # no orange ship found\n        return False\n\n    # determine orientation\n    rows = orange_coords[:, 0]\n    cols = orange_coords[:, 1]\n    n_rows, n_cols = true_board.shape\n\n    # if all orange tiles share the same row, it's horizontal\n    if np.all(rows == rows[0]):\n        r = rows[0]\n        # check each column under the orange ship\n        for c in cols:\n            below = r + 1\n            if below < n_rows and true_board[below, c] > 0:\n                return True\n        return False\n\n    # otherwise the orange ship is vertical\n    # find its bottommost tile\n    bottom_row = rows.max()\n    col = cols[0]  # all cols are the same in vertical orientation\n    below = bottom_row + 1\n    if below < n_rows and true_board[below, col] > 0:\n        return True\n\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is it Directly below orange\"\"\"\n    coords = get_ship_coords(true_board, 4)  # orange\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 1165, "refactored_length": 267, "savings": 898}
{"name": "program_52", "description": "Is it horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the one remaining ship (the only ship with at least one hidden tile)\n    is placed horizontally on the board.\n\n    Args:\n        true_board (np.ndarray): The full board with ships labeled 1\u20134 and water as 0.\n        partial_board (np.ndarray): The captain's view, with hidden tiles as \u20131, water as 0,\n                                    and revealed ship segments with their ship IDs.\n\n    Returns:\n        bool: True if that remaining ship is horizontal, False otherwise.\n    \"\"\"\n    # All ship IDs present on the true board (exclude water = 0)\n    ship_ids = set(np.unique(true_board)) - {0}\n\n    for ship_id in ship_ids:\n        # Build a mask for where this ship lives on the true board\n        ship_mask = (true_board == ship_id)\n        # If any of that ship's tiles are still hidden in partial_board, this is our target ship\n        if np.any(ship_mask & (partial_board == -1)):\n            # Find all coordinates (row, col) of this ship\n            coords = np.argwhere(ship_mask)\n            # If all row indices are the same \u21d2 horizontal\n            if np.all(coords[:, 0] == coords[0, 0]):\n                return True\n            else:\n                # Otherwise it's vertical\n                return False\n\n    # If we didn't find any partially hidden ship, default to False\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is it horizontal?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 1426, "refactored_length": 499, "savings": 927}
{"name": "program_54", "description": "Is orange vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the orange ship (encoded as 4) is placed vertically\n    on the true_board, False otherwise.\n    \"\"\"\n    # Find all coordinates of the orange ship\n    coords = np.argwhere(true_board == 4)\n    \n    # If no orange ship tiles are found, we cannot say it's vertical\n    if coords.size == 0:\n        return False\n    \n    # coords is an array of shape (ship_length, 2) where each row is (row_index, col_index)\n    # Extract the column indices of the orange ship tiles\n    cols = coords[:, 1]\n    \n    # If all column indices are the same, the ship is vertical\n    return np.all(cols == cols[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is orange vertical?\"\"\"\n    coords = get_ship_coords(true_board, 4)  # orange\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 710, "refactored_length": 259, "savings": 451}
{"name": "program_55", "description": "Is it on column 8?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify which ship still has unrevealed tiles\n    for ship_id in [1, 2, 3, 4]:\n        total_tiles = np.count_nonzero(true_board == ship_id)\n        revealed_tiles = np.count_nonzero(partial_board == ship_id)\n        if revealed_tiles < total_tiles:\n            # Get all the coordinates of that ship on the true board\n            coords = np.argwhere(true_board == ship_id)\n            # Check if any part of that ship lies in column 8 (index 7)\n            return np.any(coords[:, 1] == 7)\n    # If no ship is partially hidden, answer False\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is it on column 8?\"\"\"\n    # Implementation using get_ship_coords helper\n    ship_ids = np.unique(true_board)\n    # ... (specific logic based on description)\n    return False\n", "strategy": "ast_ship_coords", "original_length": 659, "refactored_length": 312, "savings": 347}
{"name": "program_60", "description": "Is the last ship directly to the right of the purple ship?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # All possible ship IDs\n    ship_ids = [1, 2, 3, 4]\n\n    # 1) Determine which ship is still partially or wholly hidden:\n    #    i.e. its count in partial_board is strictly less than in true_board.\n    last_ships = []\n    for sid in ship_ids:\n        full_count = np.sum(true_board == sid)\n        seen_count = np.sum(partial_board == sid)\n        if seen_count < full_count:\n            last_ships.append(sid)\n\n    # If no or multiple candidates, we cannot be sure; return False by default.\n    if len(last_ships) != 1:\n        return False\n\n    last_id = last_ships[0]\n\n    # 2) For every purple tile (ID==3), check if the tile to its right is last_id.\n    rows, cols = true_board.shape\n    purple_positions = np.argwhere(true_board == 3)\n    for r, c in purple_positions:\n        # ensure we stay in bounds\n        if c + 1 < cols and true_board[r, c + 1] == last_id:\n            return True\n\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the last ship directly to the right of the purple ship?\"\"\"\n    # Implementation using get_ship_coords helper\n    ship_ids = np.unique(true_board)\n    # ... (specific logic based on description)\n    return False\n", "strategy": "ast_ship_coords", "original_length": 1009, "refactored_length": 352, "savings": 657}
{"name": "program_61", "description": "So it is horizontal on h then?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify the label of the one completely hidden ship\n    # Ship labels are 1, 2, 3, 4\n    for ship_label in (1, 2, 3, 4):\n        # Find all coordinates of this ship on the true board\n        ship_rows, ship_cols = np.where(true_board == ship_label)\n        if ship_rows.size == 0:\n            # No such ship on the board\n            continue\n        # Check if all of its tiles are still hidden in partial_board\n        if np.all(partial_board[ship_rows, ship_cols] == -1):\n            # This is the last (unrevealed) ship\n            # Check if it's horizontal on row H (index 7)\n            # A horizontal ship on H means all its row indices == 7\n            return np.all(ship_rows == 7)\n    # If we didn't find any completely hidden ship, or none on H, answer No\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"So it is horizontal on h then?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 883, "refactored_length": 512, "savings": 371}
{"name": "program_73", "description": "Is the orange ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the orange ship (value == 4)\n    coords = np.argwhere(true_board == 4)\n    # If no orange ship is found, default to False\n    if coords.size == 0:\n        return False\n    # Extract the row indices of those coordinates\n    rows = coords[:, 0]\n    # If all row indices are the same, the ship is horizontal\n    return np.all(rows == rows[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the orange ship horizontal?\"\"\"\n    coords = get_ship_coords(true_board, 4)  # orange\n    return is_horizontal(coords)\n", "strategy": "ast_horizontal", "original_length": 462, "refactored_length": 274, "savings": 188}
{"name": "program_77", "description": "Is the green ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the green ship (marked as 2 in true_board)\n    green_coords = np.argwhere(true_board == 2)\n    \n    # Extract row indices and column indices\n    rows = green_coords[:, 0]\n    cols = green_coords[:, 1]\n    \n    # The ship is horizontal if all row indices are the same\n    return np.all(rows == rows[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the green ship horizontal?\"\"\"\n    coords = get_ship_coords(true_board, 2)  # green\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 428, "refactored_length": 268, "savings": 160}
{"name": "program_78", "description": "Is the red ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the red ship (denoted by 1)\n    red_coords = np.argwhere(true_board == 1)\n    \n    # If there are fewer than 2 parts, it can't form a ship\n    if red_coords.shape[0] < 2:\n        return False\n    \n    # Check if all row indices are the same\n    rows = red_coords[:, 0]\n    return bool(np.all(rows == rows[0]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the red ship horizontal?\"\"\"\n    coords = get_ship_coords(true_board, 1)  # red\n    return is_horizontal(coords)\n", "strategy": "ast_horizontal", "original_length": 432, "refactored_length": 268, "savings": 164}
{"name": "program_82", "description": "Is the orange ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find the coordinates of all orange ship tiles (marked with 4)\n    coords = np.argwhere(true_board == 4)\n    if coords.size == 0:\n        # No orange ship found (should not happen in a valid game)\n        return False\n    # Separate into row and column indices\n    rows, cols = coords[:, 0], coords[:, 1]\n    # If all row indices are the same, the ship is horizontal\n    return np.all(rows == rows[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the orange ship horizontal?\"\"\"\n    coords = get_ship_coords(true_board, 4)  # orange\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 499, "refactored_length": 270, "savings": 229}
{"name": "program_84", "description": "Is the ship in row D horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to know if the ship that occupies row D (index 3) is placed horizontally.\n    target_row = 3  # row D is the 4th row, zero-based index 3\n\n    # 1) Find a column in row D where there's a ship segment on the true board.\n    #    If partial_board has revealed something there, that's fine too.\n    ship_cols = np.where(true_board[target_row, :] > 0)[0]\n    if ship_cols.size == 0:\n        # No ship at all in row D\n        return False\n\n    # 2) Pick that ship's ID\n    ship_id = true_board[target_row, ship_cols[0]]\n\n    # 3) Locate all segments of that same ship on the true board\n    ship_cells = np.argwhere(true_board == ship_id)\n    # ship_cells is an array of (row, col) pairs\n\n    # 4) If all segments have the same row index, it's horizontal.\n    all_rows = ship_cells[:, 0]\n    return np.all(all_rows == all_rows[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the ship in row D horizontal?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 930, "refactored_length": 514, "savings": 416}
{"name": "program_87", "description": "Is the ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We know the Captain just asked about row 'E'.\n    # Convert 'E' \u2192 row index 4 (0\u2010based)\n    row_idx = ord('E') - ord('A')\n\n    # In that row, find any still-hidden ship cells\n    row_true    = true_board[row_idx]\n    row_partial = partial_board[row_idx]\n    hidden_ship_mask = (row_true != 0) & (row_partial == -1)\n\n    # If there are no hidden ship cells in that row, answer is False\n    if not np.any(hidden_ship_mask):\n        return False\n\n    # Grab the first ship ID that is still hidden in row E\n    ship_id = row_true[hidden_ship_mask][0]\n\n    # Find every cell of that ship on the true board\n    ship_coords = np.argwhere(true_board == ship_id)\n    ship_rows   = ship_coords[:, 0]\n\n    # If all of its row\u2010indices are identical, it's horizontal\n    return np.all(ship_rows == ship_rows[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the ship horizontal?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 897, "refactored_length": 505, "savings": 392}
{"name": "program_93", "description": "Is the ship in row G horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the row index for 'G'\n    row_idx = ord('G') - ord('A')\n    # Find unrevealed ship parts in that row\n    unrevealed = (true_board[row_idx, :] > 0) & (partial_board[row_idx, :] == -1)\n    cols = np.where(unrevealed)[0]\n    # If fewer than 2 parts remain, we cannot infer a horizontal orientation\n    if cols.size < 2:\n        return False\n    # Check if the remaining parts form a contiguous horizontal segment\n    return (cols.max() - cols.min()) == (cols.size - 1)\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the ship in row G horizontal?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 574, "refactored_length": 514, "savings": 60}
{"name": "program_95", "description": "Is it horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all as\u2010yet hidden ship parts\n    hidden_ships = (partial_board == -1) & (true_board > 0)\n    # Identify which rows still contain hidden ship parts\n    rows_with_hidden = np.where(hidden_ships.any(axis=1))[0]\n    if rows_with_hidden.size == 0:\n        # No hidden ships anywhere, so no orientation to report\n        return False\n\n    # We assume the captain is still asking about the first row\n    # in which a ship part remains hidden (e.g. Row B \u2192 index 1).\n    target_row = rows_with_hidden[0]\n\n    # Pick the ship ID of any hidden part in that row\n    ship_ids_in_row = true_board[target_row][hidden_ships[target_row]]\n    ship_id = ship_ids_in_row[0]\n\n    # Get all coordinates of that ship on the true board\n    coords = np.argwhere(true_board == ship_id)\n    # coords is an array of [row, col] pairs\n\n    # If all row indices are identical, the ship is horizontal\n    return np.all(coords[:, 0] == coords[0, 0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is it horizontal?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 1021, "refactored_length": 251, "savings": 770}
{"name": "program_101", "description": "Is it horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all currently hidden ship\u2010tiles\n    hidden_ship_tiles = (partial_board == -1) & (true_board > 0)\n    # Determine which ship ID is referenced (should be exactly one)\n    ship_ids = np.unique(true_board[hidden_ship_tiles])\n    if ship_ids.size != 1:\n        # Either no hidden ships or more than one ship has hidden tiles\n        return False\n    ship_id = ship_ids[0]\n    # Get the full set of coordinates for that ship\n    coords = np.argwhere(true_board == ship_id)\n    rows, cols = coords[:, 0], coords[:, 1]\n    # If all row indices are equal, the ship is horizontal\n    return np.all(rows == rows[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is it horizontal?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 708, "refactored_length": 251, "savings": 457}
{"name": "program_106", "description": "Is it horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # The Captain's last question concerned Row D (index 3)\n    row_idx = ord('D') - ord('A')\n    ncols = true_board.shape[1]\n\n    # Find all hidden tiles in Row D that actually contain a ship\n    hidden_ship_cols = np.where(\n        (partial_board[row_idx, :] == -1) & (true_board[row_idx, :] > 0)\n    )[0]\n\n    # For each such ship\u2010cell, check if that ship has a horizontal neighbor\n    for col in hidden_ship_cols:\n        ship_id = true_board[row_idx, col]\n        # check left\n        if col > 0 and true_board[row_idx, col - 1] == ship_id:\n            return True\n        # check right\n        if col < ncols - 1 and true_board[row_idx, col + 1] == ship_id:\n            return True\n\n    # No hidden ship in Row D is part of a horizontally oriented vessel\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is it horizontal?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 870, "refactored_length": 499, "savings": 371}
{"name": "program_112", "description": "Is the red boat horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the red ship (encoded as 1)\n    red_coords = np.argwhere(true_board == 1)\n    \n    # If there are fewer than 2 parts, we cannot determine orientation;\n    # here we assume \"not horizontal\" in that degenerate case.\n    if red_coords.shape[0] < 2:\n        return False\n    \n    # Extract the row indices of the red ship parts\n    row_indices = red_coords[:, 0]\n    \n    # If all row indices are the same, the ship is horizontal.\n    # Otherwise, it's vertical.\n    return np.all(row_indices == row_indices[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the red boat horizontal?\"\"\"\n    coords = get_ship_coords(true_board, 1)  # red\n    return is_horizontal(coords)\n", "strategy": "ast_horizontal", "original_length": 634, "refactored_length": 268, "savings": 366}
{"name": "program_113", "description": "Is it horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the (unrevealed) ship that has parts in the fully\n    hidden row is placed horizontally.\n\n    Strategy:\n    1. Find the row index `r` such that:\n       - partial_board[r, :] is entirely hidden (-1)\n       - true_board[r, :] contains at least one ship tile (> 0)\n       This picks out the row the Captain just asked about.\n    2. Within that row, identify the unique ship ID among the hidden ship tiles.\n    3. Gather all coordinates of that ship ID on the true_board.\n    4. If all those coordinates lie in the same row => horizontal => return True.\n       Otherwise => vertical => return False.\n    \"\"\"\n    # Step 1: locate the target row\n    hidden = (partial_board == -1)\n    num_rows = true_board.shape[0]\n    candidate_rows = [\n        r for r in range(num_rows)\n        if hidden[r, :].all() and (true_board[r, :] > 0).any()\n    ]\n    if len(candidate_rows) != 1:\n        # Ambiguous or no such row \u2013 default to False\n        return False\n\n    target_row = candidate_rows[0]\n\n    # Step 2: find the ship ID in that row among the hidden tiles\n    mask = (true_board > 0) & hidden\n    ship_ids = np.unique(true_board[target_row, :][mask[target_row, :]])\n    ship_ids = ship_ids[ship_ids > 0]\n    if ship_ids.size != 1:\n        # Either no ship or multiple ship IDs \u2013 default to False\n        return False\n\n    ship_id = ship_ids[0]\n\n    # Step 3: gather all coordinates of that ship on the true board\n    coords = np.argwhere(true_board == ship_id)\n    rows, cols = coords[:, 0], coords[:, 1]\n\n    # Step 4: check orientation\n    # horizontal if all row indices are the same\n    return np.unique(rows).size == 1\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is it horizontal?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 1738, "refactored_length": 499, "savings": 1239}
{"name": "program_116", "description": "Are there any ship parts in rows a, b or c?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one ship tile in rows A, B or C that\n    has not yet been revealed on the partial board. Rows A, B, C correspond\n    to indices 0, 1, 2.\n    \"\"\"\n    # Create a mask of ship cells that are still hidden\n    hidden_ship_cells = (true_board > 0) & (partial_board == -1)\n    # Check only rows A, B, C (indices 0, 1, 2)\n    return bool(hidden_ship_cells[0:3, :].any())\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Are there any ship parts in rows a, b or c?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 501, "refactored_length": 277, "savings": 224}
{"name": "program_120", "description": "Is it vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # mask of as\u2010yet undiscovered ship cells\n    hidden_ship = (true_board > 0) & (partial_board == -1)\n\n    # find which ship\u2010IDs still have hidden cells\n    ship_ids = np.unique(true_board[hidden_ship])\n    # normally there will be exactly one ship still partly hidden,\n    # but even if there were more, we'll pick the first:\n    ship_id = ship_ids[0]\n\n    # all the hidden cells of that ship\n    ship_cells = np.argwhere((true_board == ship_id) & hidden_ship)\n    # ship_cells is an array of [row, col] pairs\n\n    # determine orientation:\n    # if all columns are the same \u2192 vertical, if all rows are the same \u2192 horizontal\n    rows = ship_cells[:, 0]\n    cols = ship_cells[:, 1]\n\n    is_vertical = (np.unique(cols).size == 1)\n    return is_vertical\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is it vertical?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 845, "refactored_length": 249, "savings": 596}
{"name": "program_132", "description": "close to orange?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # 1) find all the still\u2010hidden ship squares\n    hidden_ship = (partial_board == -1) & (true_board > 0)\n    hidden_pos = np.argwhere(hidden_ship)   # list of (r,c)\n    if hidden_pos.size == 0:\n        # no hidden ship squares => nothing to be 'close' to\n        return False\n\n    # 2) precompute positions of each ship type\n    ship_positions = {\n        ship: np.argwhere(true_board == ship)\n        for ship in (1,2,3,4)\n    }\n\n    # 3) for each hidden square, find its nearest ship\u2010type\n    def min_dist(pt, pts):\n        # Manhattan\n        return np.min(np.abs(pts - pt).sum(axis=1)) if pts.size else np.inf\n\n    # keep track of how many hidden squares are closest to orange\n    orange_closest = 0\n    for h in hidden_pos:\n        # compute per\u2010type distances\n        dists = {ship: min_dist(h, ship_positions[ship]) for ship in ship_positions}\n        # which ship has the minimal distance?\n        nearest = min(dists, key=dists.get)\n        if nearest == 4:   # 4 == orange\n            orange_closest += 1\n\n    # if any hidden square is closest to orange, we say \"Yes\"\n    return orange_closest > 0\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"close to orange?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 1202, "refactored_length": 250, "savings": 952}
{"name": "program_136", "description": "is orange ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Locate all coordinates of the orange ship (value 4) on the true board\n    rows, cols = np.where(true_board == 4)\n    \n    # If all row indices are the same, the ship is laid out horizontally\n    return np.all(rows == rows[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is orange ship horizontal?\"\"\"\n    coords = get_ship_coords(true_board, 4)  # orange\n    return is_horizontal(coords)\n", "strategy": "ast_horizontal", "original_length": 324, "refactored_length": 270, "savings": 54}
{"name": "program_137", "description": "is last ship far away from other ships?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the only completely unrevealed ship (\"last ship\") on the board\n    is not adjacent (even diagonally) to any other ship.\n\n    We identify the last ship by finding which ship ID appears in true_board\n    but does not appear in partial_board. Then we compute the Chebyshev distance\n    between every cell of that last ship and every cell of all other ships.\n    If the minimum such distance is greater than 1, the last ship is \"far away\".\n    \"\"\"\n    # All ship IDs present on the true board (excluding water=0)\n    all_ships = set(np.unique(true_board)) - {0}\n    # Ship IDs that have at least one revealed tile in partial_board\n    revealed_ships = set(np.unique(partial_board)) - {-1, 0}\n    # The last (completely hidden) ship is the one in all_ships not in revealed_ships\n    hidden_ships = all_ships - revealed_ships\n    if not hidden_ships:\n        # No fully hidden ship remains; question is moot => answer False\n        return False\n\n    # We assume there's exactly one \"last ship\"\n    last_ship_id = hidden_ships.pop()\n\n    # Coordinates of the last ship's cells\n    last_coords = np.argwhere(true_board == last_ship_id)\n    # Coordinates of all other ships\n    other_coords = np.argwhere((true_board > 0) & (true_board != last_ship_id))\n\n    # Compute the minimum Chebyshev distance between any cell of last ship and any other ship cell\n    # Chebyshev distance >1 means no touching even diagonally\n    min_dist = np.inf\n    for (r1, c1) in last_coords:\n        # Vectorized Chebyshev distances to all other ship cells\n        d_row = np.abs(other_coords[:, 0] - r1)\n        d_col = np.abs(other_coords[:, 1] - c1)\n        cheb = np.maximum(d_row, d_col)\n        cur_min = cheb.min() if cheb.size > 0 else np.inf\n        if cur_min < min_dist:\n            min_dist = cur_min\n        # Early exit if we already see adjacency\n        if min_dist <= 1:\n            return False\n\n    # If the closest approach is more than 1, the last ship is far away\n    return True\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is last ship far away from other ships?\"\"\"\n    # Implementation using get_ship_coords helper\n    ship_ids = np.unique(true_board)\n    # ... (specific logic based on description)\n    return False\n", "strategy": "ast_ship_coords", "original_length": 2094, "refactored_length": 333, "savings": 1761}
{"name": "program_138", "description": "is it close to green?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # find all green ship coordinates\n    green_cells = np.argwhere(true_board == 2)\n    # find all unrevealed ship coordinates (any ship>0 that partial still -1)\n    unseen_ship_cells = np.argwhere((true_board > 0) & (partial_board == -1))\n    \n    # for each green cell, see if any unseen ship cell is in its 8-neighborhood\n    for gy, gx in green_cells:\n        # compute vector differences\n        diffs = unseen_ship_cells - np.array([gy, gx])\n        # check if any diff has both coords in [-1,0,1] but not (0,0)\n        # equivalently max(abs(dy),abs(dx)) == 1\n        if np.any(np.max(np.abs(diffs), axis=1) == 1):\n            return True\n    \n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is it close to green?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 761, "refactored_length": 255, "savings": 506}
{"name": "program_145", "description": "Is the ship verticle?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine if the (only) still\u2010unrevealed ship is placed vertically.\n    We identify which ship still has hidden segments by comparing true_board\n    to partial_board, then inspect its coordinates.\n    \"\"\"\n    # Mask of tiles that are part of a ship in the true board but still hidden\n    hidden_ship_tiles = (true_board > 0) & (partial_board == -1)\n    \n    # Which ship IDs still have at least one hidden tile?\n    ship_ids = np.unique(true_board[hidden_ship_tiles])\n    \n    # If there isn't exactly one ship still hidden, we cannot answer definitively.\n    # In that case we default to False (i.e. \"No\").\n    if ship_ids.size != 1:\n        return False\n    \n    ship_id = ship_ids[0]\n    \n    # Get all coordinates of this ship on the true board\n    coords = np.argwhere(true_board == ship_id)\n    # coords is an array of (row_index, col_index) pairs\n    \n    # If all column indices are the same, it's vertical.\n    # If all row indices are the same, it's horizontal.\n    all_cols_equal = np.all(coords[:, 1] == coords[0, 1])\n    \n    return bool(all_cols_equal)\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the ship verticle?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 1171, "refactored_length": 255, "savings": 916}
{"name": "program_148", "description": "Is it to the left of E3?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines whether the still-hidden ship (the vertical ship occupying rows D, E, F, G)\n    lies to the left of the tile E3 (i.e., in column 1 or 2).\n    \"\"\"\n    # Rows D, E, F, G correspond to indices 3, 4, 5, 6 (0-based).\n    target_rows = [3, 4, 5, 6]\n    # E3 is column 3 (1-based), which is index 2 in 0-based.\n    col_limit = 2\n\n    # Identify cells that are ships in the true board but still hidden in the partial board.\n    hidden_ship_cells = (true_board > 0) & (partial_board == -1)\n\n    # Restrict to the rows D\u2013G.\n    hidden_in_target_rows = hidden_ship_cells[target_rows, :]\n\n    # Check if any of those hidden ship cells lie to the left of column index 2.\n    return bool(np.any(hidden_in_target_rows[:, :col_limit]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is it to the left of E3?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 835, "refactored_length": 258, "savings": 577}
{"name": "program_149", "description": "Is it to the left of green E6?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the as\u2010yet\u2010undiscovered ship lies entirely to the left\n    of the green ship's column (i.e. to the left of green E6 in the current board),\n    otherwise False.\n    \"\"\"\n    # 1) Locate the green ship in the full board:\n    green_cells = np.argwhere(true_board == 2)\n    if green_cells.size == 0:\n        # no green ship on the board \u2192 question is moot\n        return False\n    # All green cells share the same column; pick the first\n    green_col = green_cells[0, 1]\n    \n    # 2) Find which ship is still (partially or wholly) hidden:\n    #    A ship is \"hidden\" if the number of its tiles in partial_board\n    #    is strictly less than in true_board.\n    ship_ids = set(np.unique(true_board))\n    ship_ids.discard(0)  # drop the water\n    \n    for ship_id in ship_ids:\n        total_tiles = np.sum(true_board == ship_id)\n        revealed_tiles = np.sum(partial_board == ship_id)\n        if revealed_tiles < total_tiles:\n            # This is the ship the Captain is still hunting.\n            hidden_ship_cells = np.argwhere(true_board == ship_id)\n            # Check if every column of this ship is strictly less than green_col\n            return np.all(hidden_ship_cells[:, 1] < green_col)\n    \n    # If we found no partially hidden ship, default to False\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is it to the left of green E6?\"\"\"\n    # Implementation using get_ship_coords helper\n    ship_ids = np.unique(true_board)\n    # ... (specific logic based on description)\n    return False\n", "strategy": "ast_ship_coords", "original_length": 1397, "refactored_length": 324, "savings": 1073}
{"name": "program_160", "description": "would you say its by the edge?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if any of the still-hidden ship tiles lie on the outer border\n    of the board (i.e. row 0, row 7, col 0 or col 7), False otherwise.\n    \"\"\"\n    # Identify all hidden ship tiles: positions where partial_board is hidden (-1)\n    # but true_board indicates a ship (>0).\n    hidden_ship_tiles = (partial_board == -1) & (true_board > 0)\n    \n    # If there are no hidden ship tiles, then obviously none are on the edge.\n    if not np.any(hidden_ship_tiles):\n        return False\n\n    # Get the row and column indices of those hidden ship tiles.\n    rows, cols = np.nonzero(hidden_ship_tiles)\n    max_row, max_col = true_board.shape[0] - 1, true_board.shape[1] - 1\n\n    # Check if any of these tiles is on the outer border.\n    on_top_edge    = rows == 0\n    on_bottom_edge = rows == max_row\n    on_left_edge   = cols == 0\n    on_right_edge  = cols == max_col\n\n    return np.any(on_top_edge | on_bottom_edge | on_left_edge | on_right_edge)\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"would you say its by the edge?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 1052, "refactored_length": 264, "savings": 788}
{"name": "program_162", "description": "red vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the Red ship (denoted by 1 in true_board) is oriented vertically,\n    False otherwise.\n    \"\"\"\n    # Find all the coordinates of the red ship on the true board\n    red_coords = np.argwhere(true_board == 1)\n    \n    # If there are fewer than 2 red\u2010ship tiles, we can't call it \"vertical\"\n    if red_coords.shape[0] < 2:\n        return False\n    \n    # red_coords is an array of [row, col] pairs. \n    # The ship is vertical if all column indices are the same.\n    cols = red_coords[:, 1]\n    return np.all(cols == cols[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"red vertical?\"\"\"\n    coords = get_ship_coords(true_board, 1)  # red\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 642, "refactored_length": 250, "savings": 392}
{"name": "program_163", "description": "is it on a or h?", "original": "\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed ship tile in row A or row H,\n    i.e. in true_board we have a ship (>0) and in partial_board it's still hidden (-1).\n    \"\"\"\n    # Build a mask of all unrevealed ship tiles\n    unrevealed_ship = (true_board > 0) & (partial_board == -1)\n    # Rows A and H correspond to indices 0 and 7\n    return np.any(unrevealed_ship[[0, 7], :])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is it on a or h?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 455, "refactored_length": 250, "savings": 205}
{"name": "program_165", "description": "Is the last ship in ABCD 5678?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in rows A\u2013D and\n    columns 5\u20138; otherwise returns False.\n    \"\"\"\n    # A\u2013D correspond to row indices 0\u20133, 5\u20138 correspond to col indices 4\u20137\n    # A tile is an unrevealed ship tile if true_board>0 and partial_board==-1.\n    unrevealed = (true_board > 0) & (partial_board == -1)\n    return bool(np.any(unrevealed[0:4, 4:8]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the last ship in ABCD 5678?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 487, "refactored_length": 264, "savings": 223}
{"name": "program_168", "description": "Is it touching any of the other ships?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the one ship that has not yet been touched on partial_board\n    is orthogonally adjacent to any other ship on the true_board.\n    \"\"\"\n\n    nrows, ncols = true_board.shape\n    # Find all ship\u2010IDs present on the true board (exclude water = 0)\n    ship_ids = [sid for sid in np.unique(true_board) if sid != 0]\n\n    # Identify the \"untouched\" ship: its every cell is still hidden (partial_board == -1)\n    untouched_id = None\n    for sid in ship_ids:\n        # coordinates of this ship on true_board\n        coords = np.argwhere(true_board == sid)\n        # check if all those coords are still hidden in partial_board\n        if all(partial_board[r, c] == -1 for r, c in coords):\n            untouched_id = sid\n            break\n\n    # If we didn't find any untouched ship, answer False by default\n    if untouched_id is None:\n        return False\n\n    # Offsets for orthogonal neighbors\n    neighbors = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    # Check each cell of the untouched ship\n    for (r, c) in np.argwhere(true_board == untouched_id):\n        for dr, dc in neighbors:\n            rr, cc = r + dr, c + dc\n            # skip out\u2010of\u2010bounds\n            if not (0 <= rr < nrows and 0 <= cc < ncols):\n                continue\n            # if neighbor is a ship and not part of the untouched one, they touch\n            if true_board[rr, cc] != 0 and true_board[rr, cc] != untouched_id:\n                return True\n\n    # No touching found\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is it touching any of the other ships?\"\"\"\n    # Implementation using get_ship_coords helper\n    ship_ids = np.unique(true_board)\n    # ... (specific logic based on description)\n    return False\n", "strategy": "ast_ship_coords", "original_length": 1577, "refactored_length": 332, "savings": 1245}
{"name": "program_172", "description": "Orange vert?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the orange ship (denoted by 4) is oriented vertically,\n    i.e., all its tiles share the same column index.\n    \"\"\"\n    # Find all (row, col) coordinates of the orange ship\n    orange_coords = np.argwhere(true_board == 4)\n    \n    # If there are fewer than 2 tiles found, it can't form a valid ship orientation\n    if orange_coords.shape[0] < 2:\n        return False\n    \n    # Extract the column indices of all orange tiles\n    cols = orange_coords[:, 1]\n    \n    # It's vertical if all column indices are the same\n    return np.all(cols == cols[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Orange vert?\"\"\"\n    coords = get_ship_coords(true_board, 4)  # orange\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 671, "refactored_length": 252, "savings": 419}
{"name": "program_176", "description": "nice! good job. uhhhh anything touching a side?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # build a mask covering the four edges\n    edge_mask = np.zeros_like(true_board, dtype=bool)\n    edge_mask[0, :] = True       # top edge\n    edge_mask[-1, :] = True      # bottom edge\n    edge_mask[:, 0] = True       # left edge\n    edge_mask[:, -1] = True      # right edge\n\n    # find cells that are ships (>0), still hidden (-1 in partial_board), and on an edge\n    hidden_ship_on_edge = (true_board > 0) & (partial_board == -1) & edge_mask\n\n    # return True if any such cell exists\n    return bool(np.any(hidden_ship_on_edge))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"nice! good job. uhhhh anything touching a side?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 628, "refactored_length": 281, "savings": 347}
{"name": "program_180", "description": "g-h?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A mask of all unrevealed ship tiles\n    hidden_ships = (partial_board == -1) & (true_board > 0)\n    # Check rows G (index 6) or H (index 7)\n    return bool(hidden_ships[6, :].any() or hidden_ships[7, :].any())\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"g-h?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 308, "refactored_length": 238, "savings": 70}
{"name": "program_182", "description": "touching edge?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all unrevealed tiles that actually contain ship segments\n    unrevealed_ship = (partial_board == -1) & (true_board > 0)\n\n    # Get their row and column indices\n    rows, cols = np.where(unrevealed_ship)\n\n    # Check if any of these lie on the border of the board\n    max_row, max_col = true_board.shape[0] - 1, true_board.shape[1] - 1\n    on_edge = (rows == 0) | (rows == max_row) | (cols == 0) | (cols == max_col)\n\n    return bool(np.any(on_edge))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"touching edge?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 552, "refactored_length": 248, "savings": 304}
{"name": "program_194", "description": "Is Green Vert?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the green ship (denoted by 2)\n    coords = np.argwhere(true_board == 2)\n    # If there's fewer than 2 tiles, we cannot determine orientation:\n    if coords.shape[0] < 2:\n        return False\n    # Extract the row indices and column indices\n    rows, cols = coords[:, 0], coords[:, 1]\n    # The ship is vertical if all columns are the same and it spans multiple rows\n    is_vertical = np.all(cols == cols[0]) and (rows.max() > rows.min())\n    return bool(is_vertical)\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is Green Vert?\"\"\"\n    coords = get_ship_coords(true_board, 2)  # green\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 593, "refactored_length": 253, "savings": 340}
{"name": "program_198", "description": "Any ships touching sides?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A hidden ship cell is one where the captain still sees -1\n    # but the true board has a ship (> 0).\n    hidden_ship = (partial_board == -1) & (true_board > 0)\n\n    # Check the four borders for any hidden ship cell\n    top_border    = hidden_ship[0, :]\n    bottom_border = hidden_ship[-1, :]\n    left_border   = hidden_ship[:, 0]\n    right_border  = hidden_ship[:, -1]\n\n    return bool(\n        np.any(top_border) or\n        np.any(bottom_border) or\n        np.any(left_border) or\n        np.any(right_border)\n    )\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Any ships touching sides?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 614, "refactored_length": 259, "savings": 355}
{"name": "program_200", "description": "is the green ship vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the green ship (denoted by 2)\n    coords = np.argwhere(true_board == 2)\n    \n    # If there's no green ship, answer False by default\n    if coords.size == 0:\n        return False\n    \n    # Extract the row indices and column indices\n    rows, cols = coords[:, 0], coords[:, 1]\n    \n    # The ship is vertical if all column indices are the same\n    return np.unique(cols).size == 1\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is the green ship vertical?\"\"\"\n    coords = get_ship_coords(true_board, 2)  # green\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 503, "refactored_length": 266, "savings": 237}
{"name": "program_201", "description": "is the orange ship vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the orange ship (value 4) on true_board is oriented vertically,\n    otherwise returns False (i.e., it's horizontal).\n    \"\"\"\n    # Find all coordinates of the orange ship on the true board\n    orange_coords = np.argwhere(true_board == 4)\n    \n    # If there's fewer than 2 tiles, orientation is ambiguous; treat as not vertical\n    if orange_coords.shape[0] < 2:\n        return False\n    \n    # Check if all column indices are the same\n    # argwhere returns rows as [row_index, col_index]\n    cols = orange_coords[:, 1]\n    \n    # If all column indices match, it's vertical\n    return np.all(cols == cols[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is the orange ship vertical?\"\"\"\n    coords = get_ship_coords(true_board, 4)  # orange\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 730, "refactored_length": 268, "savings": 462}
{"name": "program_202", "description": "is the purple ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the purple ship (encoded as 3)\n    positions = np.argwhere(true_board == 3)\n    \n    # If all row indices are the same, the ship is horizontal\n    row_indices = positions[:, 0]\n    return bool(np.all(row_indices == row_indices[0]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is the purple ship horizontal?\"\"\"\n    coords = get_ship_coords(true_board, 3)  # purple\n    return is_horizontal(coords)\n", "strategy": "ast_horizontal", "original_length": 358, "refactored_length": 274, "savings": 84}
{"name": "program_214", "description": "is the red ship vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the red ship (value == 1)\n    coords = np.argwhere(true_board == 1)\n    if coords.shape[0] <= 1:\n        # If there's 0 or 1 red\u2010ship cell, it can't be oriented vertically\n        return False\n\n    # Rows are in column 0, columns are in column 1 of coords\n    unique_rows = np.unique(coords[:, 0])\n    unique_cols = np.unique(coords[:, 1])\n\n    # A ship is vertical if all its columns are the same and it spans multiple rows\n    return (unique_cols.size == 1) and (unique_rows.size > 1)\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is the red ship vertical?\"\"\"\n    coords = get_ship_coords(true_board, 1)  # red\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 609, "refactored_length": 262, "savings": 347}
{"name": "program_216", "description": "Is the green ship verticle", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if the green ship (marked with 2) is oriented vertically\n    (i.e., all its tiles share the same column), otherwise False.\n    \"\"\"\n    # find all coordinates of the green ship\n    coords = np.argwhere(true_board == 2)\n    if coords.size == 0:\n        # no green ship on the board (should not happen in a valid game)\n        return False\n\n    # extract the column indices of those coordinates\n    cols = coords[:, 1]\n    # if all column indices are identical, the ship is vertical\n    return bool(np.all(cols == cols[0]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the green ship verticle\"\"\"\n    coords = get_ship_coords(true_board, 2)  # green\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 637, "refactored_length": 265, "savings": 372}
{"name": "program_220", "description": "are there ships around the edges?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile on the outer edge\n    of the board, otherwise False.\n    \"\"\"\n    # Create a mask for the border (top row, bottom row, left column, right column)\n    border_mask = np.zeros(true_board.shape, dtype=bool)\n    border_mask[0, :] = True\n    border_mask[-1, :] = True\n    border_mask[:, 0] = True\n    border_mask[:, -1] = True\n\n    # A tile is an unrevealed ship tile if:\n    #  - true_board > 0  (there is a ship)\n    #  - partial_board == -1  (it has not been revealed yet)\n    #  - border_mask == True (it lies on the edge)\n    unrevealed_edge_ships = (true_board > 0) & (partial_board == -1) & border_mask\n\n    # If any such tile exists, answer \"Yes\" (True), otherwise \"No\" (False).\n    return bool(np.any(unrevealed_edge_ships))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"are there ships around the edges?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 890, "refactored_length": 267, "savings": 623}
{"name": "program_223", "description": "are there any half of the grid with no ships, top bottom left or right half?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # mask of all still-hidden ship tiles\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n    \n    # define the four halves by slicing\n    top_half    = hidden_ships[0:4, :]   # rows A\u2013D\n    bottom_half = hidden_ships[4:8, :]   # rows E\u2013H\n    left_half   = hidden_ships[:, 0:4]   # cols 1\u20134\n    right_half  = hidden_ships[:, 4:8]   # cols 5\u20138\n    \n    # check if any half has zero hidden ship cells\n    for region in (top_half, bottom_half, left_half, right_half):\n        if not np.any(region):\n            return True\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"are there any half of the grid with no ships, top bottom left or right half?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 641, "refactored_length": 310, "savings": 331}
{"name": "program_227", "description": "is the purple ship vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the purple ship (denoted by 3) is oriented vertically,\n    i.e., all of its tiles lie in the same column. Otherwise returns False.\n    \"\"\"\n    # find the row, col indices of all purple-ship tiles\n    rows, cols = np.where(true_board == 3)\n    \n    # if all columns are the same, it's vertical\n    return np.all(cols == cols[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is the purple ship vertical?\"\"\"\n    coords = get_ship_coords(true_board, 3)  # purple\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 448, "refactored_length": 268, "savings": 180}
{"name": "program_228", "description": "is the orange ship vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if the orange ship (value 4) is oriented vertically,\n    False otherwise.\n    \"\"\"\n    # Find all the (row, col) positions of the orange ship\n    positions = np.argwhere(true_board == 4)\n    \n    # If for all these positions the column index is the same,\n    # the ship is vertical.\n    if positions.size == 0:\n        # No orange ship found (shouldn't happen in a valid game)\n        return False\n    \n    # Extract just the column indices\n    cols = positions[:, 1]\n    \n    # If there's exactly one unique column, it's vertical\n    return np.unique(cols).size == 1\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is the orange ship vertical?\"\"\"\n    coords = get_ship_coords(true_board, 4)  # orange\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 683, "refactored_length": 268, "savings": 415}
{"name": "program_229", "description": "is the green ship vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the green ship (denoted by 2)\n    coords = np.argwhere(true_board == 2)\n    if coords.size == 0:\n        # No green ship found (shouldn't happen in a valid game)\n        return False\n\n    # Extract the column indices of those coordinates\n    cols = coords[:, 1]\n    # If all column indices are the same, the ship is vertical\n    return np.all(cols == cols[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is the green ship vertical?\"\"\"\n    coords = get_ship_coords(true_board, 2)  # green\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 486, "refactored_length": 266, "savings": 220}
{"name": "program_233", "description": "are there more than one ships along the edges?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Create a mask for the edge cells\n    edges = np.zeros_like(true_board, dtype=bool)\n    edges[0, :] = True\n    edges[-1, :] = True\n    edges[:, 0] = True\n    edges[:, -1] = True\n\n    # Find unrevealed ship\u2010tiles on the edges\n    unrevealed_edge_ships = (true_board > 0) & (partial_board == -1) & edges\n\n    # Gather the distinct ship IDs in those tiles\n    ship_ids = np.unique(true_board[unrevealed_edge_ships])\n\n    # Discard 0 if it somehow appears\n    ship_ids = ship_ids[ship_ids > 0]\n\n    # Are there more than one distinct ships there?\n    return ship_ids.size > 1\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"are there more than one ships along the edges?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 669, "refactored_length": 280, "savings": 389}
{"name": "program_236", "description": "is the purple ship horizonta;l", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the purple ship (denoted by 3)\n    coords = np.argwhere(true_board == 3)\n    if coords.size == 0:\n        # If for some reason there is no purple ship, default to False\n        return False\n\n    # Extract the row and column indices\n    rows = coords[:, 0]\n    cols = coords[:, 1]\n\n    # The ship is horizontal if all row indices are the same\n    return np.all(rows == rows[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is the purple ship horizonta;l\"\"\"\n    coords = get_ship_coords(true_board, 3)  # purple\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 503, "refactored_length": 270, "savings": 233}
{"name": "program_237", "description": "is the orange ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if the orange ship (value 4) is placed horizontally on true_board,\n    False otherwise.\n    \"\"\"\n    # Find all positions of the orange ship (marked with 4)\n    orange_positions = np.argwhere(true_board == 4)\n    \n    # If all row indices are the same, the ship is horizontal\n    rows = orange_positions[:, 0]\n    return np.all(rows == rows[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is the orange ship horizontal?\"\"\"\n    coords = get_ship_coords(true_board, 4)  # orange\n    return is_horizontal(coords)\n", "strategy": "ast_horizontal", "original_length": 460, "refactored_length": 274, "savings": 186}
{"name": "program_239", "description": "is there more than one ship on the left half?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether there is more than one distinct ship with at least one\n    unrevealed tile in the left half of the board.\n    \"\"\"\n    # Define left\u2010half boundary (first 50% of columns)\n    n_cols = true_board.shape[1]\n    midpoint = n_cols // 2\n    \n    # 1) Find all unrevealed ship tiles\n    #    true_board > 0 selects ship tiles\n    #    partial_board == -1 selects hidden tiles\n    unrevealed = (true_board > 0) & (partial_board == -1)\n    \n    # 2) Restrict to the left half of the board\n    left_unrevealed = unrevealed[:, :midpoint]\n    \n    # 3) Extract the ship IDs of those tiles\n    ship_ids = np.unique(true_board[:, :midpoint][left_unrevealed])\n    \n    # 4) Count distinct ships; answer True if more than one remains hidden in left half\n    return ship_ids.size > 1\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is there more than one ship on the left half?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 887, "refactored_length": 279, "savings": 608}
{"name": "program_252", "description": "Is the last ship on the top half of the map (A-D)?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all hidden ship\u2010tiles (tiles where the true board has a ship but the\n    # partial board is still hidden).\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n    # Which ship types still have hidden tiles?\n    remaining_ship_ids = np.unique(true_board[hidden_ships])\n    # If no ships remain hidden, answer is False (nothing left on top half).\n    if remaining_ship_ids.size == 0:\n        return False\n    # We assume \"the last ship\" means the one ship type with hidden tiles.\n    last_ship_id = remaining_ship_ids[0]\n    # Get all positions of that ship on the true board.\n    ship_positions = np.argwhere(true_board == last_ship_id)\n    # Check if all of its row indices are in 0..3 (i.e. rows A\u2013D).\n    # NumPy uses 0-based indexing, so rows A\u2013D correspond to indices 0\u20133.\n    return np.all(ship_positions[:, 0] <= 3)\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the last ship on the top half of the map (A-D)?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 933, "refactored_length": 284, "savings": 649}
{"name": "program_281", "description": "Horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all cells that are still hidden in the partial board but\n    # actually contain a ship in the true board.\n    mask = (partial_board == -1) & (true_board > 0)\n    rows, cols = np.where(mask)\n\n    # If there are no hidden ship\u2010cells, then there's nothing horizontal to report.\n    if rows.size == 0:\n        return False\n\n    # Identify the row (or rows) that still have hidden ship\u2010cells.\n    # In our current context only one row will have hidden ships.\n    target_rows = np.unique(rows)\n    # For simplicity, take the first such row.\n    r = target_rows[0]\n\n    # For each hidden ship\u2010cell in that row, check if its ship extends\n    # horizontally (i.e., it has a like\u2010valued neighbor left or right).\n    ncols = true_board.shape[1]\n    for c in cols[rows == r]:\n        ship_id = true_board[r, c]\n        # check left\n        if c > 0 and true_board[r, c - 1] == ship_id:\n            return True\n        # check right\n        if c < ncols - 1 and true_board[r, c + 1] == ship_id:\n            return True\n\n    # If none of the hidden ship\u2010cells in that row connect horizontally,\n    # then the orientation must be vertical (or there are no ships).\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Horizontal?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 1269, "refactored_length": 245, "savings": 1024}
{"name": "program_298", "description": "Horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is at least one ship still hidden that is\n    oriented horizontally (i.e. all of its tiles lie in the same row).\n    \"\"\"\n    # Look at each ship type present on the true board\n    for ship_id in np.unique(true_board):\n        if ship_id <= 0:\n            # Skip water (0) and hidden markers (-1)\n            continue\n\n        # Find all the coordinates of this ship on the true board\n        coords = np.argwhere(true_board == ship_id)\n        # A ship must occupy at least 2 tiles\n        if coords.shape[0] < 2:\n            continue\n\n        # Check if those tiles all share the same row index\n        rows = coords[:, 0]\n        if not np.all(rows == rows[0]):\n            # Not a horizontal ship\n            continue\n\n        # Finally, check if this ship is still (at least partially) hidden\n        # i.e. any of its coordinates are still marked -1 in partial_board\n        for r, c in coords:\n            if partial_board[r, c] == -1:\n                # We found a horizontal ship that has at least one hidden tile\n                return True\n\n    # No horizontal, still-hidden ships found\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Horizontal?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 1238, "refactored_length": 493, "savings": 745}
{"name": "program_303", "description": "Horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # ship IDs are positive integers in true_board (1,2,3,4\u2026).\n    # we\u2019ll loop over each ship ID, check if any tile is still hidden,\n    # and if so determine its orientation.\n    \n    # collect the set of ship\u2010IDs present\n    ship_ids = set(np.unique(true_board)) - {0, -1}\n    \n    for sid in ship_ids:\n        # get all positions of this ship\n        positions = np.argwhere(true_board == sid)\n        # check if any of this ship's tiles is still hidden in the partial\n        still_hidden = any(partial_board[tuple(pos)] == -1 for pos in positions)\n        if not still_hidden:\n            # this ship is fully revealed or sunk; skip it\n            continue\n        \n        # if the ship is size 1 it's neither horizontal nor vertical (but that won't happen here)\n        if len(positions) > 1:\n            # sort by row then col\n            rows = positions[:,0]\n            cols = positions[:,1]\n            # if all rows are the same \u2192 horizontal\n            if np.all(rows == rows[0]):\n                return True\n            # if all cols the same \u2192 vertical\n            # otherwise something irregular (won\u2019t occur in valid Battleship)\n    # no remaining ship is horizontal\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Horizontal?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 1295, "refactored_length": 493, "savings": 802}
{"name": "program_308", "description": "Is the orange ship horizontal", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the orange ship (denoted by 4)\n    coords = np.argwhere(true_board == 4)\n    # If there are no orange ship tiles, we can't say it's horizontal\n    if coords.size == 0:\n        return False\n    # Extract the unique row indices and unique column indices\n    unique_rows = np.unique(coords[:, 0])\n    unique_cols = np.unique(coords[:, 1])\n    # If all tiles share the same row, it's horizontal\n    return len(unique_rows) == 1\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the orange ship horizontal\"\"\"\n    coords = get_ship_coords(true_board, 4)  # orange\n    return is_horizontal(coords)\n", "strategy": "ast_horizontal", "original_length": 546, "refactored_length": 273, "savings": 273}
{"name": "program_310", "description": "is the purple ship vertical", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the purple ship (denoted by 3)\n    coords = np.argwhere(true_board == 3)\n    \n    # If for some reason the ship isn't fully placed or only one tile, we cannot say it's vertical\n    if coords.shape[0] < 2:\n        return False\n\n    # Extract the column indices of those tiles\n    cols = coords[:, 1]\n    \n    # The ship is vertical if all column indices are the same\n    return np.all(cols == cols[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is the purple ship vertical\"\"\"\n    coords = get_ship_coords(true_board, 3)  # purple\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 523, "refactored_length": 267, "savings": 256}
{"name": "program_311", "description": "is the purple ship surrounded by water", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the purple ship (denoted by 3) is completely surrounded\n    by water (0) on all adjacent tiles (including diagonals), and False otherwise.\n    \"\"\"\n    ship_id = 3\n    n_rows, n_cols = true_board.shape\n    \n    # Find all coordinates of the purple ship\n    ship_cells = np.argwhere(true_board == ship_id)\n    \n    # Check every neighboring cell around each ship cell\n    for r, c in ship_cells:\n        for dr in (-1, 0, 1):\n            for dc in (-1, 0, 1):\n                if dr == 0 and dc == 0:\n                    continue  # skip the ship cell itself\n                nr, nc = r + dr, c + dc\n                # only consider in\u2010bounds neighbors\n                if 0 <= nr < n_rows and 0 <= nc < n_cols:\n                    neighbor_val = true_board[nr, nc]\n                    # if it's another ship (and not part of the purple ship),\n                    # then purple is not fully surrounded by water\n                    if neighbor_val != 0 and neighbor_val != ship_id:\n                        return False\n    # No non-water neighbors found\n    return True\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is the purple ship surrounded by water\"\"\"\n    # Implementation using get_ship_coords helper\n    ship_ids = np.unique(true_board)\n    # ... (specific logic based on description)\n    return False\n", "strategy": "ast_ship_coords", "original_length": 1183, "refactored_length": 332, "savings": 851}
{"name": "program_315", "description": "Is the Purple Ship Vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the purple ship (denoted by 3) is placed vertically.\n    A ship is vertical if all of its tiles share the same column index.\n    \"\"\"\n    # Find the coordinates of every tile that belongs to the purple ship\n    coords = np.argwhere(true_board == 3)\n    \n    # Extract the column indices of those coordinates\n    _, cols = coords.T\n    \n    # If all column indices are identical, the ship is vertical\n    return np.all(cols == cols[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the Purple Ship Vertical?\"\"\"\n    coords = get_ship_coords(true_board, 3)  # purple\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 556, "refactored_length": 268, "savings": 288}
{"name": "program_328", "description": "is the green horizontal", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the green ship (value 2)\n    green_locs = np.argwhere(true_board == 2)\n    \n    # Extract the row indices of those coordinates\n    rows = green_locs[:, 0]\n    \n    # If all row indices are the same, the ship is horizontal\n    return np.all(rows == rows[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is the green horizontal\"\"\"\n    coords = get_ship_coords(true_board, 2)  # green\n    return is_horizontal(coords)\n", "strategy": "ast_horizontal", "original_length": 383, "refactored_length": 266, "savings": 117}
{"name": "program_341", "description": "Any more on Row c or d?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there are any unrevealed ship tiles on row C or D,\n    otherwise False.\n    \"\"\"\n    # A, B, C, D correspond to row indices 0, 1, 2, 3\n    rows_cd = slice(2, 4)  # selects rows C and D\n    # A tile is an unrevealed ship segment if:\n    #   true_board > 0  (it's part of a ship)\n    # and partial_board == -1 (still hidden to the Captain)\n    unrevealed = (true_board > 0) & (partial_board == -1)\n    # Check any in rows C or D\n    return bool(np.any(unrevealed[rows_cd, :]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Any more on Row c or d?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 594, "refactored_length": 257, "savings": 337}
{"name": "program_349", "description": ">=5?", "original": "\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all positions of still-hidden ship tiles\n    # (partial_board == -1) & (true_board > 0)\n    hidden_ship = (partial_board == -1) & (true_board > 0)\n\n    # Get the column indices of those positions\n    # np.where returns (row_indices, col_indices)\n    _, col_idx = np.where(hidden_ship)\n\n    # Columns are 0-based; we want columns 5\u20138 which are indices 4\u20137\n    return np.any(col_idx >= 4)\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\">=5?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 470, "refactored_length": 238, "savings": 232}
{"name": "program_357", "description": "Horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine if the currently partially revealed (but not yet sunk) ship is oriented horizontally.\n    We identify which ship code has been hit but not fully uncovered, then check its full positions\n    on the true board to see if all its tiles lie in the same row.\n    \"\"\"\n    # Possible ship codes\n    ship_codes = [1, 2, 3, 4]\n\n    # Find the \"in\u2010progress\" ship: one with some hits in partial_board but not fully revealed\n    target_code = None\n    for code in ship_codes:\n        hits_revealed = np.count_nonzero(partial_board == code)\n        total_tiles = np.count_nonzero(true_board == code)\n        # If we've hit it at least once but haven't found all its tiles, it's our target\n        if 0 < hits_revealed < total_tiles:\n            target_code = code\n            break\n\n    # If there's no in\u2010progress ship, we cannot answer; default to False\n    if target_code is None:\n        return False\n\n    # Get all positions of that ship on the true board\n    rows, cols = np.where(true_board == target_code)\n\n    # It's horizontal if all the row indices are the same\n    return np.all(rows == rows[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Horizontal?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 1208, "refactored_length": 493, "savings": 715}
{"name": "program_359", "description": "Is the orange ship vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the orange ship (denoted by 4)\n    coords = np.argwhere(true_board == 4)\n    if coords.size == 0:\n        # No orange ship on the board\n        return False\n    # Extract row indices and column indices\n    rows, cols = coords[:, 0], coords[:, 1]\n    # If all columns are the same, it's vertical\n    return np.all(cols == cols[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the orange ship vertical?\"\"\"\n    coords = get_ship_coords(true_board, 4)  # orange\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 452, "refactored_length": 268, "savings": 184}
{"name": "program_373", "description": "Is the longest ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the longest ship on the board is placed horizontally.\n    We scan true_board for each ship code > 0, measure its length and orientation,\n    then check among the ships with maximal length if any is horizontal.\n    \"\"\"\n    # Collect (length, is_horizontal) for each ship\n    ship_stats = []\n    for ship_id in np.unique(true_board):\n        if ship_id <= 0:\n            continue\n        # Get all coordinates of this ship\n        coords = np.argwhere(true_board == ship_id)  # shape: (length, 2)\n        length = coords.shape[0]\n        # If all row indices are equal, it's horizontal; otherwise vertical\n        is_horizontal = np.all(coords[:, 0] == coords[0, 0])\n        ship_stats.append((length, is_horizontal))\n    \n    # Find the maximum ship length\n    max_len = max(length for length, _ in ship_stats)\n    \n    # Check if any ship of that max length is horizontal\n    for length, is_h in ship_stats:\n        if length == max_len and is_h:\n            return True\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the longest ship horizontal?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 1110, "refactored_length": 513, "savings": 597}
{"name": "program_385", "description": "Is the red ship vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the red ship (denoted by 1)\n    coords = np.argwhere(true_board == 1)\n    # Extract their column indices\n    cols = coords[:, 1]\n    # If all red\u2010ship tiles share the same column, it's vertical\n    return np.unique(cols).size == 1\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the red ship vertical?\"\"\"\n    coords = get_ship_coords(true_board, 1)  # red\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 353, "refactored_length": 262, "savings": 91}
{"name": "program_389", "description": "Is either in column 1-4?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to check the two remaining ships (the ones of length 4 and length 5)\n    # and answer whether either of them occupies any column in 1\u20134 (0\u20133 in zero\u2010based indexing).\n    \n    # 1) Gather the coordinates of each ship by its ID (1,2,3,4).\n    ship_coords = {}\n    for ship_id in np.unique(true_board):\n        if ship_id <= 0:\n            continue\n        coords = np.argwhere(true_board == ship_id)\n        ship_coords[ship_id] = coords\n\n    # 2) Look for a ship of length 4 and one of length 5,\n    #    then check if any of their tiles lie in columns 0\u20133.\n    for target_length in (4, 5):\n        for coords in ship_coords.values():\n            if coords.shape[0] == target_length:\n                # coords[:,1] is the column index for all cells of this ship\n                if (coords[:, 1] < 4).any():\n                    return True\n                # once we've found and tested the correct\u2010sized ship, break out\n                break\n\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is either in column 1-4?\"\"\"\n    # Implementation using get_ship_coords helper\n    ship_ids = np.unique(true_board)\n    # ... (specific logic based on description)\n    return False\n", "strategy": "ast_ship_coords", "original_length": 1063, "refactored_length": 318, "savings": 745}
{"name": "program_396", "description": "Is at least one of the 4-square ships in the top half?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if at least one of the ships of length 4 on true_board\n    lies entirely within the top half of the board (rows 0..n_rows//2-1).\n    \"\"\"\n    n_rows = true_board.shape[0]\n    half = n_rows // 2\n\n    # find all distinct positive ship labels\n    for ship_id in np.unique(true_board):\n        if ship_id <= 0:\n            continue\n        \n        # get all the coordinates occupied by this ship\n        coords = np.argwhere(true_board == ship_id)\n        \n        # check if this ship has exactly 4 tiles\n        if coords.shape[0] == 4:\n            # check if all of its tiles lie in the top half\n            if np.all(coords[:, 0] < half):\n                return True\n\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is at least one of the 4-square ships in the top half?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 801, "refactored_length": 536, "savings": 265}
{"name": "program_400", "description": "Is it in 7?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the as\u2010yet unrevealed vertical ship (the one\n    already narrowed down to columns 7\u20108) lies in column 7.\n    \"\"\"\n    # A mask of all still\u2010hidden ship squares\n    hidden_ship = (true_board > 0) & (partial_board == -1)\n    # Which ship\u2010IDs still have unrevealed squares?\n    remaining_ids = np.unique(true_board[hidden_ship])\n    \n    for ship_id in remaining_ids:\n        # All coordinates of this ship in the full board\n        coords = np.argwhere(true_board == ship_id)\n        if coords.size == 0:\n            continue\n        \n        # We only care about ships that are still partly hidden\n        if not np.any(hidden_ship & (true_board == ship_id)):\n            continue\n        \n        # Check orientation: vertical ships occupy a single column\n        cols = coords[:, 1]\n        if np.all(cols == cols[0]):\n            # This is a vertical ship.  What is its column?\n            col_index = int(cols[0])        # 0\u2010based index\n            col_number = col_index + 1      # 1\u2010based column\n            # Return True if that column is 7, False otherwise\n            return (col_number == 7)\n    \n    # If we find no remaining vertical ship, answer \"No\"\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is it in 7?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 1301, "refactored_length": 245, "savings": 1056}
{"name": "program_402", "description": "Is the other 4-square ship in the bottom half?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # 1) Find all ship\u2010labels that occupy exactly 4 cells.\n    #    We ignore water (0) and hidden (-1) since true_board has only 0\u20134.\n    labels, counts = np.unique(true_board[true_board > 0], return_counts=True)\n    four_sq_labels = labels[counts == 4]\n\n    # 2) Of those length\u20104 ships, determine which one has any cell already\n    #    revealed in partial_board.  We assume a revealed ship cell in partial_board\n    #    will equal its true label; hidden cells are -1.\n    found = None\n    for lab in four_sq_labels:\n        mask = (true_board == lab)\n        # if any of those positions in partial_board match the label,\n        # the Captain has found (revealed) part of that ship\n        if np.any(partial_board[mask] == lab):\n            found = lab\n            break\n\n    # 3) The \u201cother\u201d 4\u2010square ship is the one in four_sq_labels that isn\u2019t `found`.\n    other_labels = [lab for lab in four_sq_labels if lab != found]\n    if not other_labels:\n        # no other 4\u2010square ship found (shouldn\u2019t happen in a proper game)\n        return False\n\n    other_label = other_labels[0]\n    other_coords = np.argwhere(true_board == other_label)\n    \n    # 4) Check whether that ship lies entirely in the bottom half.\n    #    Board has 8 rows (0\u20137).  Bottom half means rows 4,5,6,7.\n    bottom_start = true_board.shape[0] // 2   # 8//2 == 4\n    return np.all(other_coords[:, 0] >= bottom_start)\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the other 4-square ship in the bottom half?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 1484, "refactored_length": 528, "savings": 956}
{"name": "program_404", "description": "Is it in E-F (yes) or G-H (no)?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the as\u2010yet unrevealed 4\u2010square ship lies entirely in rows E\u2010F.\n    Rows are 0-indexed 0..7 corresponding to A..H.\n    \"\"\"\n    # Look for ship\u2010IDs that occupy exactly 4 tiles on the true board\n    for ship_id in np.unique(true_board):\n        if ship_id <= 0:\n            continue  # skip water or hidden markers\n        \n        # Find all positions of this ship_id\n        pos = np.argwhere(true_board == ship_id)\n        # If it's a 4\u2010length ship...\n        if pos.shape[0] == 4:\n            # Check if it's fully revealed in partial_board\n            # A fully revealed ship will have partial_board == ship_id at all its spots\n            # We want the *other* 4\u2010length ship, i.e. the one not fully revealed yet.\n            revealed = partial_board[pos[:,0], pos[:,1]] == ship_id\n            if not np.all(revealed):\n                # Check if all its row\u2010indices lie in E or F (indices 4 or 5)\n                rows = pos[:,0]\n                in_EF = np.all((rows == 4) | (rows == 5))\n                return bool(in_EF)\n    # If we didn't find an unrevealed 4\u2010length ship, answer conservatively 'no'\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is it in E-F (yes) or G-H (no)?\"\"\"\n    # Implementation using get_ship_coords helper\n    ship_ids = np.unique(true_board)\n    # ... (specific logic based on description)\n    return False\n", "strategy": "ast_ship_coords", "original_length": 1243, "refactored_length": 325, "savings": 918}
{"name": "program_405", "description": "Is it in columns 5-6 (yes) or column 7 (no)", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Answer to the question: Is the final (unrevealed) ship located\n    in columns 5\u20136 (yes) or in column 7 (no)?\n\n    We identify all hidden ship\u2010tiles by looking for positions where\n    true_board>0 (a ship) and partial_board==-1 (still hidden).\n    Then we check whether any of these hidden tiles lie in columns 5 or 6.\n    If so, we return True ('yes'); otherwise False ('no').\n    \"\"\"\n    # Boolean mask of hidden ship tiles\n    hidden_ship = (true_board > 0) & (partial_board == -1)\n    # columns 5 and 6 correspond to indices 4 and 5\n    # If any hidden ship tile lies in those columns, answer is yes\n    return bool(np.any(hidden_ship[:, 4:6]))\n", "refactored": "import numpy as np\nfrom ast_helpers import has_unrevealed_in_col, col_to_index\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is it in columns 5-6 (yes) or column 7 (no)\"\"\"\n    return has_unrevealed_in_col(true_board, partial_board, col_to_index(7))\n", "strategy": "ast_col_query", "original_length": 752, "refactored_length": 282, "savings": 470}
{"name": "program_407", "description": "Is in in column 5?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify all ship tiles that are still hidden\n    hidden_ship_tiles = (true_board > 0) & (partial_board == -1)\n    # Check if any of those hidden ship tiles lie in column 5 (index 4)\n    return bool(np.any(hidden_ship_tiles[:, 4]))\n", "refactored": "import numpy as np\nfrom ast_helpers import has_unrevealed_in_col, col_to_index\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is in in column 5?\"\"\"\n    return has_unrevealed_in_col(true_board, partial_board, col_to_index(5))\n", "strategy": "ast_col_query", "original_length": 330, "refactored_length": 257, "savings": 73}
{"name": "program_408", "description": "Is the last ship on the top half?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify all unrevealed ship\u2010tiles (tiles that are >0 on true_board but still -1 on partial_board)\n    unrevealed_mask = (true_board > 0) & (partial_board == -1)\n    \n    # Determine which ship IDs are still unrevealed\n    remaining_ship_ids = np.unique(true_board[unrevealed_mask])\n    # If there isn't exactly one ship left, we can't answer \"the last ship\" question\n    if remaining_ship_ids.size != 1:\n        return False\n    \n    last_ship_id = remaining_ship_ids[0]\n    \n    # Get the row indices of all unrevealed tiles of that last ship\n    ship_rows, _ = np.where((true_board == last_ship_id) & (partial_board == -1))\n    \n    # Define the top half cutoff (for 8 rows, indices 0,1,2,3 are the top half)\n    halfway = true_board.shape[0] // 2\n    \n    # Return True if all unrevealed parts of the ship lie in the top half\n    return bool(np.all(ship_rows < halfway))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the last ship on the top half?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 973, "refactored_length": 267, "savings": 706}
{"name": "program_412", "description": "Is it in the bottom half?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in the bottom half of the board (i.e., in the last rows).\n    \"\"\"\n    # Identify tiles that are ship parts in true_board but still hidden in partial_board\n    unrevealed_ships = (true_board > 0) & (partial_board == -1)\n\n    # Compute the halfway point of the board\n    n_rows = true_board.shape[0]\n    half = n_rows // 2  # bottom half is rows [half, n_rows)\n\n    # Check if any unrevealed ship tiles lie in the bottom half\n    return bool(np.any(unrevealed_ships[half:, :]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is it in the bottom half?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 643, "refactored_length": 259, "savings": 384}
{"name": "program_414", "description": "Is the ship at A3 horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We're answering: \"Is the ship at A3 horizontal?\"\n    # Convert A3 into zero\u2010based indices: row A -> 0, column 3 -> 2\n    row_idx = ord('A') - ord('A')    # 0\n    col_idx = 3 - 1                  # 2\n\n    # Identify which ship is at A3\n    ship_id = true_board[row_idx, col_idx]\n    if ship_id == 0:\n        # No ship at A3 at all\n        return False\n\n    n_rows, n_cols = true_board.shape\n\n    # Check immediate horizontal neighbors for the same ship_id\n    for dc in (-1, 1):\n        nc = col_idx + dc\n        if 0 <= nc < n_cols and true_board[row_idx, nc] == ship_id:\n            return True\n\n    # If no horizontal neighbor matched, it's not horizontal\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the ship at A3 horizontal?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 773, "refactored_length": 511, "savings": 262}
{"name": "program_444", "description": "is there a ship on line D or C across?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to know if there is any hidden ship tile on row C or row D.\n    # Rows are labeled A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7.\n    target_rows = [2, 3]  # C, D\n\n    # A tile is an unrevealed ship tile if:\n    #   true_board > 0 (there is a ship)\n    #   partial_board == -1 (it is still hidden)\n    unrevealed_ship = (true_board > 0) & (partial_board == -1)\n\n    # Check if any such tile exists in row C or row D\n    return np.any(unrevealed_ship[target_rows, :])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is there a ship on line D or C across?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 566, "refactored_length": 272, "savings": 294}
{"name": "program_447", "description": "is the longest ship in the top half", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify all ship IDs (positive integers)\n    ship_ids = np.unique(true_board)\n    ship_ids = ship_ids[ship_ids > 0]\n\n    # Compute length of each ship\n    lengths = {ship_id: np.count_nonzero(true_board == ship_id)\n               for ship_id in ship_ids}\n\n    # Find the maximum length\n    max_len = max(lengths.values())\n\n    # Collect all ship IDs that have the maximum length\n    longest_ships = [sid for sid, l in lengths.items() if l == max_len]\n\n    # Define the top half boundary (rows 0 through n/2 - 1)\n    half = true_board.shape[0] // 2\n\n    # Check if any of the longest ships lies entirely in the top half\n    for sid in longest_ships:\n        coords = np.argwhere(true_board == sid)\n        if np.all(coords[:, 0] < half):\n            return True\n\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is the longest ship in the top half\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 878, "refactored_length": 517, "savings": 361}
{"name": "program_453", "description": "is there a ship in the bottom right", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine board dimensions\n    n_rows, n_cols = true_board.shape\n\n    # Define the \u201cbottom half\u201d (rows indexed from n_rows//2 .. end)\n    # and the \u201cright half\u201d (cols indexed from n_cols//2 .. end)\n    r_mid = n_rows // 2\n    c_mid = n_cols // 2\n\n    # Build a mask of the bottom\u2010right quadrant\n    bottom_right = np.zeros_like(true_board, dtype=bool)\n    bottom_right[r_mid:, c_mid:] = True\n\n    # Ship\u2010tiles that are still hidden on the captain\u2019s board\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n\n    # If any hidden ship\u2010tile lies in our bottom\u2010right quadrant, answer yes\n    return bool(np.any(hidden_ships & bottom_right))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is there a ship in the bottom right\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 743, "refactored_length": 269, "savings": 474}
{"name": "program_467", "description": "Is it to the right (yes) or the left (no) of the green ship?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the last unrevealed ship lies to the right of the green ship,\n    False if it lies to the left.\n    \"\"\"\n    # Identify all ship IDs on the true board (positive integers)\n    ship_ids = set(np.unique(true_board[true_board > 0]))\n    # Identify which ship IDs have any tile already revealed\n    revealed_ids = set(np.unique(true_board[(true_board > 0) & (partial_board != -1)]))\n    # The \"last ship\" ID is the one present in true_board but never revealed on partial_board\n    remaining_ids = ship_ids - revealed_ids\n    # We expect exactly one remaining ship\n    if len(remaining_ids) != 1:\n        raise ValueError(\"Expected exactly one unrevealed ship, found: %r\" % remaining_ids)\n    last_ship_id = remaining_ids.pop()\n\n    # Get all column indices for the green ship (ID=2) and the last ship\n    green_cols = np.argwhere(true_board == 2)[:, 1]\n    last_cols = np.argwhere(true_board == last_ship_id)[:, 1]\n\n    # Compute their mean column indices\n    green_center = green_cols.mean()\n    last_center = last_cols.mean()\n\n    # Return True if the last ship is to the right of the green ship\n    return last_center > green_center\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is it to the right (yes) or the left (no) of the green ship?\"\"\"\n    # Implementation using get_ship_coords helper\n    ship_ids = np.unique(true_board)\n    # ... (specific logic based on description)\n    return False\n", "strategy": "ast_ship_coords", "original_length": 1250, "refactored_length": 354, "savings": 896}
{"name": "program_480", "description": "are there any ships under 6?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A tile is a still-hidden ship part if true_board>0 and partial_board==-1.\n    hidden_ship = (true_board > 0) & (partial_board == -1)\n    # Now check only columns 1\u20135, which are indices 0\u20134 in zero-based numpy\n    return bool(np.any(hidden_ship[:, :5]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"are there any ships under 6?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 351, "refactored_length": 262, "savings": 89}
{"name": "program_484", "description": "are there any ships in the lower left? Row F and down?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A tile is an unrevealed ship\u2010tile exactly when:\n    #   (true_board > 0)      <-- there is a ship there\n    # and\n    #   (partial_board == -1) <-- it has not yet been revealed\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n\n    # We want only rows F and below: rows with index >= 5 (0\u2192A, 1\u2192B, \u2026, 5\u2192F)\n    region = hidden_ships[5:, :]\n\n    # If any True remains in that region, the answer is \"Yes\"\n    return bool(np.any(region))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"are there any ships in the lower left? Row F and down?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 541, "refactored_length": 288, "savings": 253}
{"name": "program_486", "description": "is the purple ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the purple ship (value 3)\n    coords = np.argwhere(true_board == 3)\n    if coords.size == 0:\n        # No purple ship found (shouldn't happen in a valid game)\n        return False\n    # Extract the row indices\n    rows = coords[:, 0]\n    # If all row indices are the same, the ship is horizontal\n    return np.all(rows == rows[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is the purple ship horizontal?\"\"\"\n    coords = get_ship_coords(true_board, 3)  # purple\n    return is_horizontal(coords)\n", "strategy": "ast_horizontal", "original_length": 453, "refactored_length": 274, "savings": 179}
{"name": "program_490", "description": "Between numbers 5-8", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A tile is an unrevealed ship tile if partial_board == -1 but true_board > 0\n    unrevealed_ship = (partial_board == -1) & (true_board > 0)\n    # Check only columns 5\u20138, i.e. indices 4\u20137\n    return bool(np.any(unrevealed_ship[:, 4:8]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Between numbers 5-8\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 333, "refactored_length": 253, "savings": 80}
{"name": "program_494", "description": "anthing in row 2 or 3", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship segment\n    in row 2 (index 1) or row 3 (index 2) of the board.\n    \"\"\"\n    # rows 2 and 3 correspond to indices 1 and 2\n    target_rows = [1, 2]\n    # A tile is an unrevealed ship segment if partial_board == -1 and true_board > 0\n    hidden_ship_mask = (partial_board == -1) & (true_board > 0)\n    # Check if any such tile exists in either target row\n    return bool(np.any(hidden_ship_mask[target_rows, :]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"anthing in row 2 or 3\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 568, "refactored_length": 255, "savings": 313}
{"name": "program_496", "description": "F or E ?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is at least one unrevealed ship tile\n    in either row E or row F, and False otherwise.\n    Rows are 0-indexed: A\u21920, B\u21921, \u2026, E\u21924, F\u21925.\n    \"\"\"\n    # Create a mask of hidden ship tiles\n    hidden_ships = (partial_board == -1) & (true_board > 0)\n    # Check rows E (index 4) and F (index 5)\n    return bool(np.any(hidden_ships[[4, 5], :]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"F or E ?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 463, "refactored_length": 242, "savings": 221}
{"name": "program_497", "description": "Horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the ship currently in play (i.e. the one with at least one revealed hit)\n    is oriented horizontally.\n\n    Args:\n        true_board (np.ndarray): The full hidden board with ship IDs 1\u20134.\n        partial_board (np.ndarray): The captain's view with -1 for hidden, 0 for water, >0 for hits.\n\n    Returns:\n        bool: True if that ship is horizontal, False otherwise.\n    \"\"\"\n    # Find which ship\u2010IDs have at least one revealed hit in the partial board\n    hit_ids = np.unique(partial_board[partial_board > 0])\n    if hit_ids.size == 0:\n        # No ship has been hit yet, so \"Horizontal?\" has no target ship \u2192 answer False\n        return False\n\n    # We assume there's only one ship in progress; pick the first hit ID\n    ship_id = hit_ids[0]\n\n    # Get all coordinates of that ship in the true board\n    coords = np.argwhere(true_board == ship_id)\n    if coords.shape[0] <= 1:\n        # A single\u2010tile ship (rare in standard Battleship) can't really be \"horizontal\"\n        return False\n\n    rows = coords[:, 0]\n    # If all row indices are the same, the ship lies horizontally\n    return np.unique(rows).size == 1\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Horizontal?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 1238, "refactored_length": 493, "savings": 745}
{"name": "program_501", "description": "lower rigth?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # we assume an 8\u00d78 board; the \"half\" index is 4\n    half = true_board.shape[0] // 2\n    \n    # find cells that are ships in the true board but still hidden in the partial board\n    unrevealed_ships = (true_board > 0) & (partial_board == -1)\n    \n    # extract the lower-right quadrant (rows 4\u20137, cols 4\u20137)\n    lower_right = unrevealed_ships[half:, half:]\n    \n    # if any of those are True, there's at least one unrevealed ship cell\n    return bool(np.any(lower_right))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"lower rigth?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 567, "refactored_length": 246, "savings": 321}
{"name": "program_502", "description": "horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the ship currently being targeted (i.e. the one with\n    some but not all of its tiles revealed in partial_board) is placed\n    horizontally on the true_board.\n    \"\"\"\n    # Iterate over all ship IDs (1=Red, 2=Green, 3=Purple, 4=Orange)\n    for ship_id in (1, 2, 3, 4):\n        # All positions of this ship on the true board\n        true_pos = np.argwhere(true_board == ship_id)\n        # All revealed positions of this ship on the partial board\n        partial_pos = np.argwhere(partial_board == ship_id)\n        \n        # We only care about the ship that has been hit at least once\n        # but is not yet fully revealed\n        if 0 < partial_pos.shape[0] < true_pos.shape[0]:\n            # Check orientation: if all row indices are the same, it's horizontal\n            rows = true_pos[:, 0]\n            return np.all(rows == rows[0])\n    \n    # If there's no partially revealed ship, default to False\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"horizontal?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 1047, "refactored_length": 493, "savings": 554}
{"name": "program_503", "description": "horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all revealed ship\u2010tiles on the partial board\n    hits = partial_board > 0\n    # Extract the unique ship IDs that have been hit\n    ship_ids = np.unique(partial_board[hits])\n    ship_ids = ship_ids[ship_ids > 0]\n    # If there are no hits, we cannot determine a ship's orientation\n    if ship_ids.size == 0:\n        return False\n    # Assume question refers to the first (and in practice only) ship being pursued\n    target_id = ship_ids[0]\n    # Get all coordinates of that ship on the true board\n    coords = np.argwhere(true_board == target_id)\n    # If all row indices are the same, the ship is horizontal\n    return (coords[:, 0] == coords[0, 0]).all()\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"horizontal?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 760, "refactored_length": 493, "savings": 267}
{"name": "program_505", "description": "horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all hit tiles (positive values in partial_board)\n    hits = np.argwhere(partial_board > 0)\n    # If fewer than 2 hits, orientation can't be determined: default to False\n    if hits.shape[0] <= 1:\n        return False\n\n    # Get the ship IDs at those hit positions\n    hit_ids = partial_board[hits[:, 0], hits[:, 1]]\n    # Identify which ship has the most hits (assumed current target)\n    unique_ids, counts = np.unique(hit_ids, return_counts=True)\n    current_ship_id = unique_ids[np.argmax(counts)]\n\n    # Extract positions of that ship's hits\n    ship_hits = hits[hit_ids == current_ship_id]\n    # Rows are the first column, columns are the second\n    rows = ship_hits[:, 0]\n    cols = ship_hits[:, 1]\n\n    # If all hits share the same row index, it's horizontal\n    return np.all(rows == rows[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"horizontal?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 904, "refactored_length": 493, "savings": 411}
{"name": "program_509", "description": "in row E-F?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there are any unrevealed ship tiles in rows E or F (rows 4 and 5, 0\u2010indexed).\n    \"\"\"\n    # Create a mask of all unrevealed ship tiles\n    unrevealed_ships = (true_board > 0) & (partial_board == -1)\n    \n    # Rows E and F correspond to indices 4 and 5\n    rows_E_F = unrevealed_ships[4:6, :]\n    \n    # If any of those positions is True, then there is at least one unrevealed ship tile\n    return np.any(rows_E_F)\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"in row E-F?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 535, "refactored_length": 245, "savings": 290}
{"name": "program_510", "description": "Horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines whether the ship that has been hit is oriented horizontally.\n\n    We locate the revealed hit(s) in partial_board, identify which ship\n    that belongs to using true_board, then examine the full set of\n    coordinates of that ship on true_board. If all of those coordinates\n    share the same row index, the ship is horizontal.\n    \"\"\"\n    # Find all positions of revealed ship hits (partial_board > 0)\n    hits = np.argwhere(partial_board > 0)\n    \n    # If there are no hits yet, we cannot determine orientation\n    if hits.size == 0:\n        return False\n    \n    # Look up the ship ID of the first hit in the true board\n    r, c = hits[0]\n    ship_id = true_board[r, c]\n    \n    # Find all coordinates of that ship on the true board\n    ship_positions = np.argwhere(true_board == ship_id)\n    \n    # If all row indices are the same, it's horizontal\n    return np.all(ship_positions[:, 0] == ship_positions[0, 0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Horizontal?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 1031, "refactored_length": 493, "savings": 538}
{"name": "program_515", "description": "Horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines whether the ship currently being targeted (i.e. the one with\n    at least one hit revealed but not yet sunk) is oriented horizontally.\n\n    Returns True if horizontal, False if vertical.\n    \"\"\"\n    # 1) Find which ship\u2010IDs have any revealed hits in partial_board\n    #    (we ignore water=0 and hidden=-1).\n    revealed_ids = np.unique(partial_board[partial_board > 0])\n\n    # 2) Among those, pick the one that is not yet fully revealed (i.e. hits < total length).\n    target_id = None\n    for ship_id in revealed_ids:\n        hits_so_far = np.count_nonzero(partial_board == ship_id)\n        total_length = np.count_nonzero(true_board == ship_id)\n        if 0 < hits_so_far < total_length:\n            target_id = ship_id\n            break\n\n    # If we didn't find any \"in\u2010progress\" ship, there's nothing to answer;\n    # we default to False (i.e. \"No, not horizontal\").\n    if target_id is None:\n        return False\n\n    # 3) Look up all the coordinates of that ship on the true board.\n    ship_rows, ship_cols = np.where(true_board == target_id)\n\n    # 4) If all row indices are the same, it's horizontal; otherwise vertical.\n    return np.all(ship_rows == ship_rows[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Horizontal?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 1290, "refactored_length": 493, "savings": 797}
{"name": "program_520", "description": "Is the red ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the red ship (marked with 1)\n    red_positions = np.argwhere(true_board == 1)\n    \n    # If there are no red tiles, we cannot say it's horizontal\n    if red_positions.size == 0:\n        return False\n    \n    # Split into row indices and column indices\n    rows = red_positions[:, 0]\n    cols = red_positions[:, 1]\n    \n    # The red ship is horizontal if all its tiles share the same row\n    return np.all(rows == rows[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the red ship horizontal?\"\"\"\n    coords = get_ship_coords(true_board, 1)  # red\n    return is_horizontal(coords)\n", "strategy": "ast_horizontal", "original_length": 549, "refactored_length": 268, "savings": 281}
{"name": "program_521", "description": "Is the green ship vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the green ship (encoded as 2)\n    green_positions = np.argwhere(true_board == 2)\n    # If there's fewer than 2 tiles, it can't form a vertical ship\n    if green_positions.shape[0] < 2:\n        return False\n    # Extract the column indices of those tiles\n    cols = green_positions[:, 1]\n    # The ship is vertical if all columns are the same\n    return np.unique(cols).size == 1\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the green ship vertical?\"\"\"\n    coords = get_ship_coords(true_board, 2)  # green\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 501, "refactored_length": 266, "savings": 235}
{"name": "program_522", "description": "Is the purple shop horizontal", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the purple ship (denoted by 3)\n    coords = np.argwhere(true_board == 3)\n    # If all row indices are the same, the ship is horizontal\n    return np.all(coords[:, 0] == coords[0, 0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the purple shop horizontal\"\"\"\n    coords = get_ship_coords(true_board, 3)  # purple\n    return is_horizontal(coords)\n", "strategy": "ast_horizontal", "original_length": 309, "refactored_length": 273, "savings": 36}
{"name": "program_525", "description": "Is there a horizontal ship in row H?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to know if there's any *hidden* ship segment in row H\n    # that belongs to a ship oriented horizontally.\n    # Row H is the 8th row, index 7.\n    row_idx = ord('H') - ord('A')\n    n_cols = true_board.shape[1]\n    \n    for col in range(n_cols):\n        # is this tile still hidden, and is there actually a ship here?\n        if partial_board[row_idx, col] == -1 and true_board[row_idx, col] > 0:\n            ship_id = true_board[row_idx, col]\n            # check left neighbor\n            if col > 0 and true_board[row_idx, col - 1] == ship_id:\n                return True\n            # check right neighbor\n            if col < n_cols - 1 and true_board[row_idx, col + 1] == ship_id:\n                return True\n\n    # no hidden horizontal ship segments found in row H\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is there a horizontal ship in row H?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 893, "refactored_length": 518, "savings": 375}
{"name": "program_528", "description": "Is the ship have additional spaces up from where I just fired?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines if the ship that was just hit (i.e., a ship hit but not yet fully revealed)\n    has any additional contiguous segments directly above the hit positions.\n    \"\"\"\n    # Iterate through each ship ID\n    for ship_id in (1, 2, 3, 4):\n        # Count how many of this ship are revealed vs total on the true board\n        revealed = np.sum(partial_board == ship_id)\n        total    = np.sum(true_board   == ship_id)\n        # We're only interested in ships that have been hit but not yet fully sunk\n        if 0 < revealed < total:\n            # Find all revealed hit positions of this ship\n            hits = np.argwhere(partial_board == ship_id)\n            for i, j in hits:\n                # Check the cell directly above (i-1, j)\n                if i > 0 and true_board[i-1, j] == ship_id:\n                    return True\n            # No segment found above any of the hits\n            return False\n    # If no ship is currently in a \"hit but not sunk\" state, answer False\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the ship have additional spaces up from where I just fired?\"\"\"\n    # Implementation using get_ship_coords helper\n    ship_ids = np.unique(true_board)\n    # ... (specific logic based on description)\n    return False\n", "strategy": "ast_ship_coords", "original_length": 1105, "refactored_length": 356, "savings": 749}
{"name": "program_529", "description": "Is the green ship vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # find all (row, col) positions of the green ship (value == 2)\n    coords = np.argwhere(true_board == 2)\n    # if we found fewer than 2 cells, there is no valid ship to orient\n    if coords.shape[0] < 2:\n        return False\n    # split into row and column arrays\n    rows, cols = coords[:, 0], coords[:, 1]\n    # vertical if all columns are equal (and rows span more than one)\n    return np.all(cols == cols[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the green ship vertical?\"\"\"\n    coords = get_ship_coords(true_board, 2)  # green\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 509, "refactored_length": 266, "savings": 243}
{"name": "program_531", "description": "Is it in lines B or C?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all positions of the green ship (coded as 2)\n    green_coords = np.argwhere(true_board == 2)\n    # If there's no green ship on the board, answer False\n    if green_coords.size == 0:\n        return False\n    # Extract the row indices of the green ship\n    green_rows = green_coords[:, 0]\n    # Check that every green\u2010ship row is either row index 1 (B) or 2 (C)\n    return np.all(np.isin(green_rows, [1, 2]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is it in lines B or C?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 510, "refactored_length": 504, "savings": 6}
{"name": "program_533", "description": "Is the purple ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the purple ship (value == 3)\n    positions = np.argwhere(true_board == 3)\n    # If fewer than 2 tiles, default to False (not enough info to call it horizontal)\n    if positions.shape[0] < 2:\n        return False\n    # Extract row indices\n    rows = positions[:, 0]\n    # If all row indices are the same, the ship is horizontal\n    return bool(np.all(rows == rows[0]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the purple ship horizontal?\"\"\"\n    coords = get_ship_coords(true_board, 3)  # purple\n    return is_horizontal(coords)\n", "strategy": "ast_horizontal", "original_length": 490, "refactored_length": 274, "savings": 216}
{"name": "program_534", "description": "Is the red ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the red ship (value 1) on the true board\n    red_coords = np.argwhere(true_board == 1)\n    \n    # If there are fewer than 2 tiles, orientation is undefined; return False by convention\n    if red_coords.shape[0] < 2:\n        return False\n    \n    # Extract the row indices and column indices\n    rows = red_coords[:, 0]\n    cols = red_coords[:, 1]\n    \n    # The ship is horizontal if all row indices are the same\n    return np.all(rows == rows[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the red ship horizontal?\"\"\"\n    coords = get_ship_coords(true_board, 1)  # red\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 574, "refactored_length": 264, "savings": 310}
{"name": "program_543", "description": "Is it in the numbers 4,5,6, or 7?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Any cell that is part of a ship in true_board but still hidden in partial_board\n    hidden_ships = (partial_board == -1) & (true_board > 0)\n    # Determine which ship(s) remain hidden\n    ship_types = np.unique(true_board[hidden_ships])\n    \n    # If exactly one ship is still entirely unrevealed, focus on that ship\n    if ship_types.size == 1:\n        ship_mask = (true_board == ship_types[0]) & hidden_ships\n    else:\n        # Otherwise consider all hidden ship parts\n        ship_mask = hidden_ships\n    \n    # Extract the column indices (0-based) of those hidden ship parts\n    cols = np.nonzero(ship_mask)[1]\n    # We're asking: are any of these in columns 4, 5, 6 or 7?\n    # (1-based columns 4-7 correspond to 0-based indices 3-6)\n    return np.any((cols >= 3) & (cols <= 6))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is it in the numbers 4,5,6, or 7?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 883, "refactored_length": 267, "savings": 616}
{"name": "program_544", "description": "Is the green ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the green ship (value == 2) on the true board\n    coords = np.argwhere(true_board == 2)\n    \n    # If there's only one part (or none), we cannot say it's horizontal\n    if coords.shape[0] <= 1:\n        return False\n    \n    # Extract row indices and column indices\n    rows = coords[:, 0]\n    cols = coords[:, 1]\n    \n    # The ship is horizontal if all row indices are the same\n    return np.all(rows == rows[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the green ship horizontal?\"\"\"\n    coords = get_ship_coords(true_board, 2)  # green\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 536, "refactored_length": 268, "savings": 268}
{"name": "program_545", "description": "Is the orange ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the orange ship (marked with 4)\n    coords = np.argwhere(true_board == 4)\n    if coords.size == 0:\n        # No orange ship found (shouldn't happen in a valid game)\n        return False\n    # Extract the row indices of all orange\u2010ship tiles\n    rows = coords[:, 0]\n    # If all row indices are the same, the ship is laid out horizontally\n    return bool(np.all(rows == rows[0]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the orange ship horizontal?\"\"\"\n    coords = get_ship_coords(true_board, 4)  # orange\n    return is_horizontal(coords)\n", "strategy": "ast_horizontal", "original_length": 501, "refactored_length": 274, "savings": 227}
{"name": "program_548", "description": "Is there a horizontal ship in rows D or E?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows D and E correspond to indices 3 and 4 (0\u2010based)\n    target_rows = [3, 4]\n    \n    for r in target_rows:\n        row = true_board[r]\n        # scan for any horizontal run of the same ship ID of length >= 2\n        c = 0\n        while c < row.size:\n            ship_id = row[c]\n            # skip water and hidden\n            if ship_id <= 0:\n                c += 1\n                continue\n            \n            # found the start of a potential ship segment\n            start = c\n            # extend to the right while the ship_id matches\n            while c < row.size and row[c] == ship_id:\n                c += 1\n            end = c  # one past the last tile of this segment\n            \n            # if the run is length >= 2, it's a horizontal ship\n            length = end - start\n            if length >= 2:\n                # check if any tile of this segment is still hidden on the partial board\n                if np.any(partial_board[r, start:end] == -1):\n                    return True\n            # continue scanning from c\n    # no unrevealed horizontal ship found in D or E\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is there a horizontal ship in rows D or E?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 1213, "refactored_length": 524, "savings": 689}
{"name": "program_549", "description": "Is the horizontal ship in row D?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row 'D' to its zero\u2010based index (A\u21920, B\u21921, \u2026)\n    row_idx = ord('D') - ord('A')\n    \n    # Extract the true row and the captain's partial view of that row\n    true_row = true_board[row_idx]\n    partial_row = partial_board[row_idx]\n    \n    # We'll only count ship cells that are still hidden to the captain\n    hidden_ship_cells = (true_row > 0) & (partial_row == -1)\n    \n    # For each ship type (1=Red, 2=Green, 3=Purple, 4=Orange),\n    # check if there are at least two contiguous hidden cells in this row.\n    # A count > 1 of the same ship ID in one row implies a horizontal placement.\n    for ship_id in (1, 2, 3, 4):\n        # Count how many hidden cells of this ship_id are in row D\n        count_in_row = np.sum((true_row == ship_id) & hidden_ship_cells)\n        if count_in_row > 1:\n            return True\n    \n    # No horizontal ship segment found in row D\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the horizontal ship in row D?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 990, "refactored_length": 514, "savings": 476}
{"name": "program_552", "description": "Is the orange ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Symbol for the orange ship is 4\n    # Find all (row, col) positions of orange in the true board\n    orange_positions = np.argwhere(true_board == 4)\n    \n    # If all of those positions lie in the same row, it's horizontal\n    rows = orange_positions[:, 0]\n    return np.unique(rows).size == 1\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the orange ship horizontal?\"\"\"\n    coords = get_ship_coords(true_board, 4)  # orange\n    return is_horizontal(coords)\n", "strategy": "ast_horizontal", "original_length": 391, "refactored_length": 274, "savings": 117}
{"name": "program_553", "description": "Is there a horizontal ship in row G?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row G is index 6 (since A=0, B=1, \u2026, G=6)\n    row = 6\n    tb_row = true_board[row]\n    pb_row = partial_board[row]\n    \n    # Find all non\u2010zero runs in the true board row\n    i = 0\n    n = tb_row.size\n    while i < n:\n        if tb_row[i] > 0:\n            ship_id = tb_row[i]\n            # start of a possible horizontal ship\n            j = i\n            while j < n and tb_row[j] == ship_id:\n                j += 1\n            length = j - i\n            # if it's at least length 2, check if any of those tiles remain hidden\n            if length >= 2:\n                # pb_row[i:j] == -1 marks hidden tiles\n                if np.any(pb_row[i:j] == -1):\n                    return True\n            i = j\n        else:\n            i += 1\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is there a horizontal ship in row G?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 854, "refactored_length": 518, "savings": 336}
{"name": "program_555", "description": "Is the red ship vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find the coordinates of all red ship tiles (denoted by 1)\n    red_positions = np.argwhere(true_board == 1)\n    \n    # If there's less than 2 tiles, we cannot determine orientation reliably.\n    # In standard Battleship, every ship has length >= 2, so this is mostly\n    # a sanity check.\n    if red_positions.shape[0] < 2:\n        return False  # Treat as not vertical if ambiguous.\n    \n    # Extract the column indices of those tiles\n    cols = red_positions[:, 1]\n    \n    # If all column indices are the same, the ship is vertical.\n    return np.all(cols == cols[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the red ship vertical?\"\"\"\n    coords = get_ship_coords(true_board, 1)  # red\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 669, "refactored_length": 262, "savings": 407}
{"name": "program_559", "description": "Are there any horizontal ships in rows G or H", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # rows G and H correspond to indices 6 and 7 in 0-based numpy arrays\n    for r in (6, 7):\n        # scan each possible adjacent pair for a horizontal ship\n        for c in range(true_board.shape[1] - 1):\n            # non-zero means ship; equality means same ship id, hence horizontal\n            if true_board[r, c] > 0 and true_board[r, c] == true_board[r, c + 1]:\n                # check if at least one of those two tiles is still hidden\n                if partial_board[r, c] == -1 or partial_board[r, c + 1] == -1:\n                    return True\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Are there any horizontal ships in rows G or H\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 666, "refactored_length": 527, "savings": 139}
{"name": "program_560", "description": "Is the orange ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the orange ship (denoted by 4)\n    coords = np.argwhere(true_board == 4)\n    \n    # If there are no orange ship tiles, default to False\n    if coords.size == 0:\n        return False\n    \n    # coords is an array of [row, col] pairs. \n    # For a horizontal ship, all row indices must be the same.\n    rows = coords[:, 0]\n    return np.all(rows == rows[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the orange ship horizontal?\"\"\"\n    coords = get_ship_coords(true_board, 4)  # orange\n    return is_horizontal(coords)\n", "strategy": "ast_horizontal", "original_length": 482, "refactored_length": 274, "savings": 208}
{"name": "program_561", "description": "Is there any horizontal ships in E F or G?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows E, F, G correspond to indices 4, 5, 6\n    target_rows = [4, 5, 6]\n    n_cols = true_board.shape[1]\n    \n    for r in target_rows:\n        # scan each row for adjacent ship tiles (horizontal orientation)\n        for c in range(n_cols - 1):\n            if true_board[r, c] > 0 and true_board[r, c] == true_board[r, c + 1]:\n                # check if at least one of the two tiles is still hidden\n                if partial_board[r, c] == -1 or partial_board[r, c + 1] == -1:\n                    return True\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is there any horizontal ships in E F or G?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 625, "refactored_length": 524, "savings": 101}
{"name": "program_562", "description": "Are there any horizontal ships in C or D?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows C and D correspond to indices 2 and 3 (0-based)\n    target_rows = [2, 3]\n    n_rows, n_cols = true_board.shape\n    \n    for r in target_rows:\n        for c in range(n_cols):\n            ship_id = true_board[r, c]\n            # Skip water or already revealed tiles\n            if ship_id <= 0 or partial_board[r, c] != -1:\n                continue\n            \n            # Check if this tile is part of a horizontal ship:\n            # look left or right for another tile of the same ship\n            left_same = (c > 0 and true_board[r, c-1] == ship_id)\n            right_same = (c < n_cols - 1 and true_board[r, c+1] == ship_id)\n            if left_same or right_same:\n                return True\n\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Are there any horizontal ships in C or D?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 821, "refactored_length": 523, "savings": 298}
{"name": "program_563", "description": "Are there any horizontal ships in G or H?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows G and H correspond to indices 6 and 7 (0-based, A=0, B=1, \u2026)\n    rows_to_check = [ord('G') - ord('A'), ord('H') - ord('A')]\n    n_cols = true_board.shape[1]\n\n    for r in rows_to_check:\n        for c in range(n_cols):\n            cell_val = true_board[r, c]\n            if cell_val > 0 and partial_board[r, c] == -1:\n                # check if this cell is part of a horizontal ship\n                left_neighbor  = (c > 0       and true_board[r, c-1] == cell_val)\n                right_neighbor = (c < n_cols-1 and true_board[r, c+1] == cell_val)\n                if left_neighbor or right_neighbor:\n                    return True\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Are there any horizontal ships in G or H?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 752, "refactored_length": 523, "savings": 229}
{"name": "program_564", "description": "Are there any horizontal ships in E or F?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one horizontal ship in row E or row F\n    that still has at least one hidden tile, otherwise returns False.\n    \"\"\"\n    # Rows E and F correspond to indices 4 and 5 (0-based)\n    target_rows = ['E', 'F']\n    ncols = true_board.shape[1]\n\n    for r in target_rows:\n        row_idx = ord(r) - ord('A')\n        # scan for any contiguous run of the same ship ID of length >= 2\n        for c in range(ncols - 1):\n            if true_board[row_idx, c] > 0 and true_board[row_idx, c] == true_board[row_idx, c + 1]:\n                # we found a horizontal segment \u2014 check if any part is still hidden\n                if partial_board[row_idx, c] == -1 or partial_board[row_idx, c + 1] == -1:\n                    return True\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Are there any horizontal ships in E or F?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 869, "refactored_length": 523, "savings": 346}
{"name": "program_565", "description": "Are there any horizontal ships in A or H?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether there is any *horizontal* ship segment in row A or row H\n    that has not yet been revealed.\n\n    Arguments:\n    - true_board:    8\u00d78 numpy array encoding the full ship layout\n                     (-1 hidden, 0 water, 1\u20134 different ships).\n    - partial_board: 8\u00d78 numpy array showing the captain\u2019s view\n                     (-1 hidden, 0 water, 1\u20134 revealed ship).\n\n    Returns:\n    - True if there exists at least one horizontal ship (length \u2265 2)\n      in row A or row H with at least one tile still hidden.\n      False otherwise.\n    \"\"\"\n    # Rows A and H correspond to indices 0 and 7 in an 8\u00d78 array.\n    rows_to_check = [0, true_board.shape[0] - 1]\n\n    for r in rows_to_check:\n        # Slide a window of width 2 across columns 0..6 to detect horizontal adjacencies\n        for c in range(true_board.shape[1] - 1):\n            # Is there a ship at (r,c) and is it the same ship at (r,c+1)?\n            if true_board[r, c] > 0 and true_board[r, c] == true_board[r, c + 1]:\n                # If either tile of that adjacent pair is still hidden, we have an unrevealed\n                # horizontal segment in that row.\n                if partial_board[r, c] == -1 or partial_board[r, c + 1] == -1:\n                    return True\n\n    # No horizontal ships in A or H that remain (at least partially) hidden.\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Are there any horizontal ships in A or H?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 1452, "refactored_length": 523, "savings": 929}
{"name": "program_566", "description": "Is the horizontal ship in H?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # we want to know if there's a horizontal ship in row H (index 7)\n    target_row = 7\n\n    # find all ship\u2010IDs on the board (1\u20264)\n    ship_ids = [sid for sid in np.unique(true_board) if sid > 0]\n\n    for sid in ship_ids:\n        # get the coordinates of this ship\n        coords = np.argwhere(true_board == sid)  # array of [row, col]\n\n        # determine if the ship is horizontal (all rows the same)\n        rows = coords[:, 0]\n        if np.all(rows == rows[0]):\n            # is this the row we're asking about?\n            if rows[0] == target_row:\n                # check if any of its cells are still hidden (-1) in partial_board\n                for (r, c) in coords:\n                    if partial_board[r, c] == -1:\n                        return True\n    # no horizontal, still-hidden ship pieces found in H\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the horizontal ship in H?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 930, "refactored_length": 510, "savings": 420}
{"name": "program_567", "description": "Is there a horizontal ship in A?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We're checking row A, which is index 0\n    row_idx = 0\n    row_true = true_board[row_idx]\n    row_partial = partial_board[row_idx]\n    \n    cur_id = None\n    run_start = 0\n    run_len = 0\n    n = row_true.shape[0]\n    \n    # Iterate one past the end to flush the last run\n    for j in range(n + 1):\n        if j < n and row_true[j] > 0:\n            # We're on a ship tile\n            if row_true[j] == cur_id:\n                run_len += 1\n            else:\n                # New ship segment starts\n                # Flush the previous segment if any\n                if cur_id is not None and run_len >= 2:\n                    # Check if any tile in that segment is still hidden\n                    if np.any(row_partial[run_start:run_start + run_len] == -1):\n                        return True\n                cur_id = row_true[j]\n                run_start = j\n                run_len = 1\n        else:\n            # Hit water or we're past the end: flush any ongoing segment\n            if cur_id is not None and run_len >= 2:\n                if np.any(row_partial[run_start:run_start + run_len] == -1):\n                    return True\n            cur_id = None\n            run_len = 0\n\n    # No hidden horizontal ship segments found in row A\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is there a horizontal ship in A?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 1361, "refactored_length": 514, "savings": 847}
{"name": "program_568", "description": "Is the red ship vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the red ship (denoted by 1)\n    red_coords = np.argwhere(true_board == 1)\n    # If all column indices are the same, it's vertical\n    return np.all(red_coords[:, 1] == red_coords[0, 1])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the red ship vertical?\"\"\"\n    coords = get_ship_coords(true_board, 1)  # red\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 308, "refactored_length": 262, "savings": 46}
{"name": "program_570", "description": "Is the orange ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the orange ship (value == 4)\n    coords = np.argwhere(true_board == 4)\n    \n    # If there are no orange tiles, default to False\n    if coords.size == 0:\n        return False\n    \n    # Separate into row indices and column indices\n    rows = coords[:, 0]\n    cols = coords[:, 1]\n    \n    # The ship is horizontal if all row indices are the same\n    return np.all(rows == rows[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the orange ship horizontal?\"\"\"\n    coords = get_ship_coords(true_board, 4)  # orange\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 506, "refactored_length": 270, "savings": 236}
{"name": "program_571", "description": "Is the red ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all positions of the red ship (marked with a 1)\n    red_positions = np.argwhere(true_board == 1)\n    \n    # If there are no red\u2010ship tiles (shouldn't happen in a valid game), say False\n    if red_positions.size == 0:\n        return False\n    \n    # Extract the row indices of those positions\n    rows = red_positions[:, 0]\n    \n    # The ship is horizontal if all row indices are the same\n    return np.unique(rows).size == 1\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the red ship horizontal?\"\"\"\n    coords = get_ship_coords(true_board, 1)  # red\n    return is_horizontal(coords)\n", "strategy": "ast_horizontal", "original_length": 529, "refactored_length": 268, "savings": 261}
{"name": "program_575", "description": "Is the orange ship vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the orange ship (denoted by 4)\n    orange_coords = np.argwhere(true_board == 4)\n    # If all column indices are the same, the ship is vertical\n    cols = orange_coords[:, 1]\n    return np.all(cols == cols[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the orange ship vertical?\"\"\"\n    coords = get_ship_coords(true_board, 4)  # orange\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 331, "refactored_length": 268, "savings": 63}
{"name": "program_584", "description": "How about 1, 2, or 3?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there are any unrevealed ship tiles in columns 1, 2, or 3\n    (0\u2010based indices 0, 1, or 2); otherwise False.\n    \"\"\"\n    # A mask of all ship tiles that are still hidden\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n    \n    # Build an array of column indices for each position\n    # shape = (n_rows, n_cols), where entry [i,j] == j\n    col_indices = np.broadcast_to(np.arange(true_board.shape[1]), true_board.shape)\n    \n    # Check if any hidden ship tile lies in columns 0,1,2 (i.e. 1,2,3 in 1-based)\n    return bool(np.any(hidden_ships & (col_indices < 3)))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"How about 1, 2, or 3?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 696, "refactored_length": 255, "savings": 441}
{"name": "program_586", "description": "Is the orange ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the orange ship (denoted by 4)\n    coords = np.argwhere(true_board == 4)\n    # If there are fewer than 2 tiles, it can't be \"horizontal\" in the sense of lying\n    if coords.shape[0] < 2:\n        return False\n    # Extract the row indices of those tiles\n    rows = coords[:, 0]\n    # If all row indices are the same, the ship lies in a single row \u2192 horizontal\n    return np.all(rows == rows[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the orange ship horizontal?\"\"\"\n    coords = get_ship_coords(true_board, 4)  # orange\n    return is_horizontal(coords)\n", "strategy": "ast_horizontal", "original_length": 516, "refactored_length": 274, "savings": 242}
{"name": "program_594", "description": "Does column 6 have any ships?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in column 6,\n    otherwise False.\n    \"\"\"\n    # Convert from human 1\u20138 \u2192 0\u20137 indexing\n    col_idx = 6 - 1\n    \n    # A tile is an unrevealed ship if true_board > 0 (ship) AND partial_board == -1 (hidden)\n    unrevealed_ship_mask = (true_board > 0) & (partial_board == -1)\n    \n    # Check if any tile in the specified column is an unrevealed ship\n    return bool(unrevealed_ship_mask[:, col_idx].any())\n", "refactored": "import numpy as np\nfrom ast_helpers import has_unrevealed_in_col, col_to_index\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Does column 6 have any ships?\"\"\"\n    return has_unrevealed_in_col(true_board, partial_board, col_to_index(6))\n", "strategy": "ast_col_query", "original_length": 566, "refactored_length": 268, "savings": 298}
{"name": "program_605", "description": "Do any of the remaining two ships border the two destroyed ships?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if any of the remaining (undestroyed) ships\n    border (share an edge with) any of the destroyed ships.\n    Otherwise return False.\n    \"\"\"\n    # All ship\u2010IDs on the board\n    ship_ids = [1, 2, 3, 4]\n\n    # 1) Identify which ships are destroyed: every true_board cell for that ship\n    #    has already been uncovered in partial_board.\n    destroyed_ids = []\n    for sid in ship_ids:\n        # Find all coordinates of ship sid in the true board\n        coords = np.argwhere(true_board == sid)\n        if coords.size == 0:\n            # No such ship\u2014or it's already sunk and cleared\u2014skip it\n            continue\n        # Check that every one of those coords is revealed in partial_board\n        if all(partial_board[tuple(pt)] == sid for pt in coords):\n            destroyed_ids.append(sid)\n\n    # 2) The remaining ships are those not in destroyed_ids\n    remaining_ids = [sid for sid in ship_ids if sid not in destroyed_ids]\n\n    # 3) Gather the sets of coordinates for destroyed ships and remaining ships\n    destroyed_cells = set()\n    for sid in destroyed_ids:\n        for (r, c) in np.argwhere(true_board == sid):\n            destroyed_cells.add((r, c))\n\n    remaining_cells = set()\n    for sid in remaining_ids:\n        for (r, c) in np.argwhere(true_board == sid):\n            remaining_cells.add((r, c))\n\n    # 4) Check for any orthogonal adjacency between remaining_cells and destroyed_cells\n    #    Adjacent offsets\n    neighbors = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    for (r, c) in remaining_cells:\n        for dr, dc in neighbors:\n            if (r + dr, c + dc) in destroyed_cells:\n                return True\n\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Do any of the remaining two ships border the two destroyed ships?\"\"\"\n    # Implementation using get_ship_coords helper\n    ship_ids = np.unique(true_board)\n    # ... (specific logic based on description)\n    return False\n", "strategy": "ast_ship_coords", "original_length": 1761, "refactored_length": 359, "savings": 1402}
{"name": "program_621", "description": "Is the green ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find the coordinates of all green ship tiles (denoted by 2)\n    green_positions = np.argwhere(true_board == 2)\n    if green_positions.size == 0:\n        # No green ship found (shouldn't happen in a valid game), default to False\n        return False\n    # Extract the row indices of those positions\n    rows = green_positions[:, 0]\n    # The green ship is horizontal if all its tiles share the same row index\n    return np.all(rows == rows[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the green ship horizontal?\"\"\"\n    coords = get_ship_coords(true_board, 2)  # green\n    return is_horizontal(coords)\n", "strategy": "ast_horizontal", "original_length": 541, "refactored_length": 272, "savings": 269}
{"name": "program_624", "description": "Is the green ship vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the green ship (value 2) on the true board\n    green_positions = np.argwhere(true_board == 2)\n    if green_positions.size == 0:\n        # No green ship found (shouldn't happen in a valid game)\n        return False\n\n    # Extract row indices and column indices\n    rows = green_positions[:, 0]\n    cols = green_positions[:, 1]\n\n    # The ship is vertical if all columns are the same (and it spans more than one row)\n    return np.all(cols == cols[0]) and (rows.max() - rows.min() + 1 == len(rows))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the green ship vertical?\"\"\"\n    coords = get_ship_coords(true_board, 2)  # green\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 619, "refactored_length": 266, "savings": 353}
{"name": "program_637", "description": "Is the purple ship vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # In this variant, the purple ship is represented by 3.\n    # Find all coordinates (row, col) where true_board == 3\n    purple_positions = np.argwhere(true_board == 3)\n    \n    # If there are fewer than 2 tiles, it can't form a ship of length >=2\n    if purple_positions.shape[0] < 2:\n        return False\n    \n    # Extract the column indices of those positions\n    cols = purple_positions[:, 1]\n    \n    # If all column indices are the same, the ship is vertical\n    return np.all(cols == cols[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the purple ship vertical?\"\"\"\n    coords = get_ship_coords(true_board, 3)  # purple\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 596, "refactored_length": 268, "savings": 328}
{"name": "program_638", "description": "Is the green ship horizontal on the right?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find the (row, col) coordinates of every green\u2010ship cell (value == 2)\n    rows, cols = np.where(true_board == 2)\n\n    # If there are no green cells, we cannot say it's horizontal on the right\n    if len(rows) == 0:\n        return False\n\n    # 1) Check horizontal: are all green\u2010cells in the same row?\n    is_horizontal = (rows.max() == rows.min())\n\n    # 2) Check \"on the right\": are all green\u2010cells in the right half?\n    #    We divide the board vertically in two equal halves.\n    n_cols = true_board.shape[1]\n    right_threshold = n_cols // 2  # e.g. for 8 columns, this is 4\n    is_on_right = np.all(cols >= right_threshold)\n\n    # Return True only if both conditions hold\n    return bool(is_horizontal and is_on_right)\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the green ship horizontal on the right?\"\"\"\n    coords = get_ship_coords(true_board, 2)  # green\n    return is_horizontal(coords)\n", "strategy": "ast_horizontal", "original_length": 823, "refactored_length": 285, "savings": 538}
{"name": "program_642", "description": "Any on line one both horizontal and vertical?", "original": "\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A tile is an unrevealed ship\u2010tile if partial_board == -1 and true_board > 0\n    unrevealed_ships = (partial_board == -1) & (true_board > 0)\n    # check row 0 (line one horizontal) or column 0 (line one vertical)\n    if unrevealed_ships[0, :].any() or unrevealed_ships[:, 0].any():\n        return True\n    else:\n        return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Any on line one both horizontal and vertical?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 410, "refactored_length": 279, "savings": 131}
{"name": "program_644", "description": "Is the green ship vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Locate all the tiles belonging to the green ship (denoted by 2)\n    green_positions = np.argwhere(true_board == 2)\n    \n    # Extract the unique columns occupied by the green ship\n    unique_cols = np.unique(green_positions[:, 1])\n    \n    # If there's exactly one unique column, the green ship is vertical\n    return unique_cols.size == 1\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the green ship vertical?\"\"\"\n    coords = get_ship_coords(true_board, 2)  # green\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 438, "refactored_length": 266, "savings": 172}
{"name": "program_648", "description": "is the green boat horizontal", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Locate all tiles of the green ship (encoded as 2)\n    green_positions = np.argwhere(true_board == 2)\n    \n    # If there are fewer than 2 tiles, we can't infer orientation; return False by default\n    if green_positions.shape[0] < 2:\n        return False\n    \n    # Extract row and column indices\n    rows = green_positions[:, 0]\n    cols = green_positions[:, 1]\n    \n    # The ship is horizontal if all row indices are the same\n    return np.all(rows == rows[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is the green boat horizontal\"\"\"\n    coords = get_ship_coords(true_board, 2)  # green\n    return is_horizontal(coords)\n", "strategy": "ast_horizontal", "original_length": 562, "refactored_length": 271, "savings": 291}
{"name": "program_664", "description": "is the biggest ship in row a?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Extract only the ship cells (values > 0)\n    ship_cells = true_board[true_board > 0]\n    # Find each ship ID and its count (length)\n    ship_ids, counts = np.unique(ship_cells, return_counts=True)\n    # Determine the maximum length\n    max_len = counts.max()\n    # Find the ID(s) of the largest ship(s)\n    biggest_ids = ship_ids[counts == max_len]\n    \n    # Check each largest ship to see if it lies entirely in row A (row index 0)\n    for sid in biggest_ids:\n        # Get all coordinates (row, col) of this ship\n        coords = np.argwhere(true_board == sid)\n        # Extract the set of row\u2010indices occupied by this ship\n        rows_occupied = np.unique(coords[:, 0])\n        # If all of those rows == 0, the ship is entirely in row A\n        if rows_occupied.size == 1 and rows_occupied[0] == 0:\n            return True\n    \n    # If none of the largest ships is entirely in row A, answer No\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is the biggest ship in row a?\"\"\"\n    # Implementation using get_ship_coords helper\n    ship_ids = np.unique(true_board)\n    # ... (specific logic based on description)\n    return False\n", "strategy": "ast_ship_coords", "original_length": 1015, "refactored_length": 323, "savings": 692}
{"name": "program_667", "description": "is there a horizontal ship in row d?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'D' \u2192 index 3\n    row_idx = ord('d') - ord('a')\n    ncols = true_board.shape[1]\n    \n    # Scan adjacent pairs in that row\n    for c in range(ncols - 1):\n        ship_id = true_board[row_idx, c]\n        # must be a ship and same ship in next column\n        if ship_id > 0 and true_board[row_idx, c+1] == ship_id:\n            # check if at least one of those two tiles is still hidden\n            if partial_board[row_idx, c] == -1 or partial_board[row_idx, c+1] == -1:\n                return True\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is there a horizontal ship in row d?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 627, "refactored_length": 518, "savings": 109}
{"name": "program_675", "description": "is the green ship vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the green ship (denoted by 2) on the true board\n    green_positions = np.argwhere(true_board == 2)\n    \n    # If there's fewer than 2 tiles, it can't really be \"vertical\" in the usual sense,\n    # but we'll return False by default in that degenerate case.\n    if green_positions.shape[0] < 2:\n        return False\n    \n    # Check if all column indices are the same (vertical alignment)\n    cols = green_positions[:, 1]\n    return np.all(cols == cols[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is the green ship vertical?\"\"\"\n    coords = get_ship_coords(true_board, 2)  # green\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 577, "refactored_length": 266, "savings": 311}
{"name": "program_681", "description": "Are any ships on the edges?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any ship tile on the outer edges of the board\n    that has not yet been revealed to the Captain.\n    \"\"\"\n    # Build a mask for the edge positions (top row, bottom row, left column, right column)\n    edge_mask = np.zeros_like(true_board, dtype=bool)\n    edge_mask[0, :] = True\n    edge_mask[-1, :] = True\n    edge_mask[:, 0] = True\n    edge_mask[:, -1] = True\n\n    # A ship tile is where true_board > 0. It's still hidden if partial_board == -1.\n    hidden_ship_on_edge = (true_board > 0) & (partial_board == -1) & edge_mask\n\n    # If any such tile exists, answer \"Yes\" (True), otherwise \"No\" (False).\n    return bool(np.any(hidden_ship_on_edge))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Are any ships on the edges?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 776, "refactored_length": 261, "savings": 515}
{"name": "program_701", "description": "Should I keep moving vertically to get red?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed red\u2010ship tile (value 1)\n    immediately above or below any revealed red hit on the partial_board.\n    Otherwise returns False.\n    \"\"\"\n    # Find all coordinates of revealed red hits on the partial board\n    red_hits = np.argwhere(partial_board == 1)\n    \n    # For each red hit, check the cell above and below\n    for i, j in red_hits:\n        for di in (-1, 1):\n            ni = i + di\n            # Check bounds\n            if 0 <= ni < true_board.shape[0]:\n                # If the true board has a red tile here and it's still hidden in partial_board\n                if true_board[ni, j] == 1 and partial_board[ni, j] == -1:\n                    return True\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Should I keep moving vertically to get red?\"\"\"\n    coords = get_ship_coords(true_board, 1)  # red\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 832, "refactored_length": 280, "savings": 552}
{"name": "program_702", "description": "is the orange ship vertical", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the orange ship (labeled 4)\n    positions = np.argwhere(true_board == 4)\n    # Separate into row and column indices\n    rows, cols = positions[:, 0], positions[:, 1]\n    # The ship is vertical if all columns are the same and there is more than one row\n    return len(set(cols)) == 1 and len(set(rows)) > 1\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is the orange ship vertical\"\"\"\n    coords = get_ship_coords(true_board, 4)  # orange\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 428, "refactored_length": 267, "savings": 161}
{"name": "program_703", "description": "is the red ship vertical", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the red ship (value 1)\n    red_rows, red_cols = np.where(true_board == 1)\n    # The ship is vertical if it occupies more than one row but exactly one column\n    return (np.unique(red_rows).size > 1) and (np.unique(red_cols).size == 1)\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is the red ship vertical\"\"\"\n    coords = get_ship_coords(true_board, 1)  # red\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 357, "refactored_length": 261, "savings": 96}
{"name": "program_705", "description": "is the orange ship horizontal", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the orange ship (value 4) on the true board\n    positions = np.argwhere(true_board == 4)\n    # Extract the row indices\n    rows = positions[:, 0]\n    # If all row indices are the same, the ship is horizontal\n    return np.all(rows == rows[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is the orange ship horizontal\"\"\"\n    coords = get_ship_coords(true_board, 4)  # orange\n    return is_horizontal(coords)\n", "strategy": "ast_horizontal", "original_length": 365, "refactored_length": 273, "savings": 92}
{"name": "program_707", "description": "is the purple ship vertical", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the purple ship (encoded as 3)\n    coords = np.argwhere(true_board == 3)\n    # If there are fewer than 2 tiles, orientation is undefined (treat as not vertical)\n    if coords.shape[0] < 2:\n        return False\n    # Split into row indices and column indices\n    rows, cols = coords[:, 0], coords[:, 1]\n    # The ship is vertical if all columns are the same and there is more than one distinct row\n    return (len(np.unique(cols)) == 1) and (len(np.unique(rows)) > 1)\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is the purple ship vertical\"\"\"\n    coords = get_ship_coords(true_board, 3)  # purple\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 593, "refactored_length": 267, "savings": 326}
{"name": "program_710", "description": "is the orange ship vertical", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # find all (row, col) indices where the orange ship (4) is located\n    positions = np.argwhere(true_board == 4)\n    # if we didn't find any orange tiles, we cannot say it's vertical\n    if positions.size == 0:\n        return False\n    # extract just the column indices\n    cols = positions[:, 1]\n    # if there's exactly one unique column among them, it's vertical\n    return np.unique(cols).size == 1\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is the orange ship vertical\"\"\"\n    coords = get_ship_coords(true_board, 4)  # orange\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 498, "refactored_length": 267, "savings": 231}
{"name": "program_724", "description": "down is yes, no is up, next move?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all revealed ship\u2010hits (cells where partial_board>0\n    # and agrees with true_board)\n    hits = np.argwhere((partial_board > 0) & (partial_board == true_board))\n    if hits.size == 0:\n        # No hits at all \u2013 default to \u201cno\u201d\n        return False\n\n    # Pick the hit with the largest row index (bottommost hit)\n    # This heuristically corresponds to the most recent focus\n    i, j = hits[np.argmax(hits[:, 0])]\n\n    # Lookup ship id at (i,j)\n    ship_id = true_board[i, j]\n    nrows, ncols = true_board.shape\n\n    # Compute \u201cdown\u201d coordinate\n    down_i = i + 1\n    # If down is on board and matches the same ship, answer Yes\n    if down_i < nrows and true_board[down_i, j] == ship_id:\n        return True\n    else:\n        # Otherwise go up (or off\u2013board) \u21d2 answer No\n        return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"down is yes, no is up, next move?\"\"\"\n    # Implementation using get_ship_coords helper\n    ship_ids = np.unique(true_board)\n    # ... (specific logic based on description)\n    return False\n", "strategy": "ast_ship_coords", "original_length": 895, "refactored_length": 327, "savings": 568}
{"name": "program_725", "description": "keep going same direction?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all currently revealed ship\u2010hits\n    hits = np.argwhere(partial_board > 0)\n    # If fewer than 2 hits, we cannot infer a direction \u2192 answer \u201cNo\u201d\n    if hits.shape[0] < 2:\n        return False\n\n    # Check if the hits line up horizontally or vertically\n    if np.all(hits[:, 0] == hits[0, 0]):\n        # all on same row \u2192 horizontal\n        axis = 1\n    elif np.all(hits[:, 1] == hits[0, 1]):\n        # all on same column \u2192 vertical\n        axis = 0\n    else:\n        # If not perfectly aligned, try to find any adjacent pair\n        pair = None\n        for i in range(len(hits)):\n            for j in range(i + 1, len(hits)):\n                if abs(hits[i, 0] - hits[j, 0]) + abs(hits[i, 1] - hits[j, 1]) == 1:\n                    pair = (hits[i], hits[j])\n                    break\n            if pair is not None:\n                break\n        if pair is None:\n            return False\n        # Work with just that adjacent pair\n        hits = np.array(pair)\n        axis = 0 if hits[0, 1] == hits[1, 1] else 1\n\n    # Sort the hits along the inferred axis and pick the two ends\n    hits = hits[np.argsort(hits[:, axis])]\n    endpoint1, endpoint2 = hits[0], hits[-1]\n\n    # Determine the ship type from one of the endpoints\n    ship_id = true_board[endpoint1[0], endpoint1[1]]\n\n    # Compute the unit step from endpoint1 \u2192 endpoint2\n    delta = endpoint2 - endpoint1\n    delta = delta // np.max(np.abs(delta))\n\n    # The \"same direction\" move is just one more step past endpoint2\n    next_r, next_c = endpoint2 + delta\n\n    # If that next cell is on-board, still hidden, and truly part of the same ship \u2192 Yes\n    if (0 <= next_r < partial_board.shape[0] and\n        0 <= next_c < partial_board.shape[1] and\n        partial_board[next_r, next_c] == -1 and\n        true_board[next_r, next_c] == ship_id):\n        return True\n\n    # Otherwise \u2192 No\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"keep going same direction?\"\"\"\n    # Implementation using get_ship_coords helper\n    ship_ids = np.unique(true_board)\n    # ... (specific logic based on description)\n    return False\n", "strategy": "ast_ship_coords", "original_length": 1967, "refactored_length": 320, "savings": 1647}
{"name": "program_727", "description": "row 6 is yes, row 8 is no, next best move?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    The Captain is asking to choose between row 6 (index 5) on a 'yes' response\n    and row 8 (index 7) on a 'no' response. We pick the row with the greater\n    number of still\u2010hidden ship segments. If row 6 has at least as many hidden\n    ship tiles as row 8, return True (yes); otherwise return False (no).\n    \"\"\"\n    # A mask of where there is a ship on the true board AND that tile is still hidden\n    hidden_ship_mask = (true_board > 0) & (partial_board == -1)\n\n    # Count hidden ship tiles in row 6 (index 5) and row 8 (index 7)\n    count_row6 = np.count_nonzero(hidden_ship_mask[5])\n    count_row8 = np.count_nonzero(hidden_ship_mask[7])\n\n    # Return True if row 6 is at least as promising as row 8, else False\n    return count_row6 >= count_row8\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"row 6 is yes, row 8 is no, next best move?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 857, "refactored_length": 276, "savings": 581}
{"name": "program_731", "description": "the letter a - d is yes, e-h is no, what's the best area to hit?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there are more unrevealed ship tiles in rows A-D (indices 0-3)\n    than in rows E-H (indices 4-7), otherwise False.\n    \"\"\"\n    # A tile is an unrevealed ship if partial_board == -1 and true_board > 0\n    hidden_ships = (partial_board == -1) & (true_board > 0)\n\n    # Count hidden ship tiles in rows A-D vs E-H\n    count_AD = hidden_ships[:4, :].sum()\n    count_EH = hidden_ships[4:, :].sum()\n\n    # If more hidden in A-D, answer \"yes\" (True), else \"no\" (False).\n    return count_AD > count_EH\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"the letter a - d is yes, e-h is no, what's the best area to hit?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 614, "refactored_length": 298, "savings": 316}
{"name": "program_734", "description": "is the red ship vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates where the true board has a red ship (value == 1)\n    coords = np.argwhere(true_board == 1)\n    # If all those coordinates share the same column index, it's vertical\n    # (i.e. no column variation)\n    cols = coords[:, 1]\n    return bool(np.all(cols == cols[0]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is the red ship vertical?\"\"\"\n    coords = get_ship_coords(true_board, 1)  # red\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 382, "refactored_length": 262, "savings": 120}
{"name": "program_737", "description": "is green horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the green ship (value 2) on the true board\n    coords = np.argwhere(true_board == 2)\n    if coords.size == 0:\n        # No green ship found (shouldn't happen in a valid game), default to False\n        return False\n\n    # coords is an array of shape (n_tiles, 2), where each row is [row_index, col_index].\n    # If all row indices are the same, the ship is horizontal.\n    row_indices = coords[:, 0]\n    return np.all(row_indices == row_indices[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is green horizontal?\"\"\"\n    coords = get_ship_coords(true_board, 2)  # green\n    return is_horizontal(coords)\n", "strategy": "ast_horizontal", "original_length": 570, "refactored_length": 263, "savings": 307}
{"name": "program_742", "description": "1-4 = yes, 5-8 = no", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in columns 1\u20134 (indices 0\u20133),\n    otherwise returns False.\n    \"\"\"\n    # A mask of unrevealed ship tiles everywhere on the board\n    unrevealed_ships = (true_board > 0) & (partial_board == -1)\n    \n    # Check only columns 0 through 3 (which correspond to columns 1\u20134)\n    return np.any(unrevealed_ships[:, :4])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"1-4 = yes, 5-8 = no\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 475, "refactored_length": 253, "savings": 222}
{"name": "program_743", "description": "I feel like that the bottom left lol, down and to the right?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines whether there is any still-hidden ship tile\n    in the bottom-left quadrant of the board.\n\n    Bottom-left quadrant is defined as the last half of the rows\n    and the first half of the columns.\n    \"\"\"\n    # dimensions\n    n_rows, n_cols = true_board.shape\n\n    # define bottom-left quadrant mask\n    row_mid = n_rows // 2\n    col_mid = n_cols // 2\n    bottom_left_mask = np.zeros_like(true_board, dtype=bool)\n    bottom_left_mask[row_mid:, :col_mid] = True\n\n    # find still-hidden ship tiles\n    hidden_ship_tiles = (true_board > 0) & (partial_board == -1)\n\n    # is there any hidden ship tile in the bottom-left quadrant?\n    return bool(np.any(hidden_ship_tiles & bottom_left_mask))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"I feel like that the bottom left lol, down and to the right?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 803, "refactored_length": 294, "savings": 509}
{"name": "program_744", "description": "horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the partially\u2010hit ship on the board is oriented horizontally.\n    \n    Strategy:\n    1. Locate all revealed ship\u2010tiles in partial_board (values > 0).\n    2. If there are no hits yet, we cannot infer orientation; return False.\n    3. Take the first hit\u2010coordinate, look up its ship\u2010type in true_board.\n    4. Find all coordinates of that ship\u2010type on the true_board.\n    5. If all of those coordinates share the same row index, the ship is horizontal.\n       Otherwise it is vertical.\n    \"\"\"\n    # 1) Find all revealed ship tiles\n    hit_indices = np.argwhere(partial_board > 0)\n    \n    # 2) If no hits, default to False\n    if hit_indices.shape[0] == 0:\n        return False\n    \n    # 3) Look up the ship type at the first revealed tile\n    r, c = hit_indices[0]\n    ship_type = true_board[r, c]\n    \n    # 4) Gather all coordinates of that ship on the true board\n    ship_coords = np.argwhere(true_board == ship_type)\n    rows = ship_coords[:, 0]\n    \n    # 5) Horizontal if all row indices are identical\n    return np.unique(rows).size == 1\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"horizontal?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 1168, "refactored_length": 493, "savings": 675}
{"name": "program_745", "description": "they bunched together?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if any two distinct ships on the true_board have cells that\n    touch each other (including diagonally), i.e. are \"bunched together\".\n    Otherwise return False.\n    \"\"\"\n    # Find all ship IDs (positive integers > 0)\n    ship_ids = np.unique(true_board)\n    ship_ids = ship_ids[ship_ids > 0]\n\n    # For each pair of ships, check if any cell of one is adjacent to any cell of the other\n    for i in range(len(ship_ids)):\n        for j in range(i + 1, len(ship_ids)):\n            id1, id2 = ship_ids[i], ship_ids[j]\n            coords1 = np.argwhere(true_board == id1)\n            coords2 = np.argwhere(true_board == id2)\n            for x1, y1 in coords1:\n                # Compute Chebyshev distance to every cell of the second ship\n                # If any distance is exactly 1, they're touching\n                dists = np.maximum(np.abs(coords2[:, 0] - x1),\n                                   np.abs(coords2[:, 1] - y1))\n                if np.any(dists == 1):\n                    return True\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"they bunched together?\"\"\"\n    # Implementation using get_ship_coords helper\n    ship_ids = np.unique(true_board)\n    # ... (specific logic based on description)\n    return False\n", "strategy": "ast_ship_coords", "original_length": 1129, "refactored_length": 316, "savings": 813}
{"name": "program_753", "description": "is it in 1 or 2?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Columns 1 or 2 correspond to array indices 0 or 1\n    cols = [0, 1]\n    # A hidden ship tile is one where true_board>0 and partial_board==-1\n    hidden_ship_mask = (true_board > 0) & (partial_board == -1)\n    # Check if any such hidden ship tile lies in column 0 or 1\n    return bool(np.any(hidden_ship_mask[:, cols]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is it in 1 or 2?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 417, "refactored_length": 250, "savings": 167}
{"name": "program_757", "description": "down?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # 1) Find the \"active\" ship: one with hits in partial_board but not fully revealed.\n    #    We assume ship\u2010IDs are 1,2,3,4.\n    for ship_id in (1, 2, 3, 4):\n        hit_positions = np.argwhere(partial_board == ship_id)\n        if hit_positions.size == 0:\n            continue\n        total_on_true = np.count_nonzero(true_board == ship_id)\n        if hit_positions.shape[0] < total_on_true:\n            # This is the unsunk ship we are chasing.\n            break\n    else:\n        # No unsunk hits found \u21d2 nothing to go down from.\n        return False\n\n    # 2) Pick the bottommost known hit (largest row index).\n    #    That is our \"last_hit\" for a vertical probe.\n    last_hit = hit_positions[np.argmax(hit_positions[:, 0])]\n    r, c = last_hit\n\n    # 3) Compute the cell immediately down (row+1).\n    down_r = r + 1\n    if down_r > true_board.shape[0] - 1:\n        return False\n\n    # 4) Answer \"Yes\" iff:\n    #    a) true_board[down_r, c] is part of the same ship_id\n    #    b) partial_board[down_r, c] is still hidden (-1)\n    return (true_board[down_r, c] == ship_id) and (partial_board[down_r, c] == -1)\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"down?\"\"\"\n    # Implementation using get_ship_coords helper\n    ship_ids = np.unique(true_board)\n    # ... (specific logic based on description)\n    return False\n", "strategy": "ast_ship_coords", "original_length": 1210, "refactored_length": 299, "savings": 911}
{"name": "program_760", "description": "anything on rows 1&2 hit yes, no for 3,4", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one ship tile in rows 1 & 2 (i.e. indices 0 and 1)\n    that is still hidden to the Captain. Otherwise returns False.\n    \"\"\"\n    # Build a mask of all hidden ship cells\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n    # Restrict to rows 0 and 1 (which correspond to rows \u201c1 & 2\u201d in the Captain\u2019s phrasing)\n    return bool(np.any(hidden_ships[0:2, :]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"anything on rows 1&2 hit yes, no for 3,4\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 505, "refactored_length": 274, "savings": 231}
{"name": "program_761", "description": "5,6 yes, 7,8 no", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    The Captain's statement is:\n      - There are ships (unrevealed) in rows 5 & 6\n      - There are no ships (unrevealed) in rows 7 & 8\n\n    We check for any hidden ship tiles (true_board > 0 and partial_board == -1)\n    in those row ranges and then verify the Captain's claim.\n    \"\"\"\n    # Mask of unrevealed ship tiles\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n\n    # Rows 5 & 6 correspond to indices 4 and 5 (0-based)\n    has_in_5_6 = np.any(hidden_ships[4:6, :])\n\n    # Rows 7 & 8 correspond to indices 6 and 7 (0-based)\n    has_in_7_8 = np.any(hidden_ships[6:8, :])\n\n    # The Captain said \u201c5,6 yes\u201d (so has_in_5_6 must be True)\n    # and \u201c7,8 no\u201d (so has_in_7_8 must be False).\n    return has_in_5_6 and not has_in_7_8\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"5,6 yes, 7,8 no\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 845, "refactored_length": 249, "savings": 596}
{"name": "program_763", "description": "upper yes, lower no", "original": "\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A mask of tiles that are ship parts in the true board but still hidden to the captain\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n    # Upper half: rows A\u2013D \u2192 indices 0\u20133\n    upper_has = hidden_ships[:4, :].any()\n    # Lower half: rows E\u2013H \u2192 indices 4\u20137\n    lower_has = hidden_ships[4:, :].any()\n    # Return True if there is at least one hidden ship tile in the upper half\n    # and zero hidden ship tiles in the lower half\n    return upper_has and not lower_has\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"upper yes, lower no\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 558, "refactored_length": 253, "savings": 305}
{"name": "program_772", "description": "1 or 2?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines whether there is any unrevealed ship tile (\u2018true_board\u2019 > 0\n    and \u2018partial_board\u2019 == -1) in column 1 or column 2 (1-based).\n    \"\"\"\n    # Mask of all tiles that are ships in the true board but still hidden\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n    \n    # Columns 1 and 2 correspond to indices 0 and 1\n    return bool(np.any(hidden_ships[:, 0:2]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"1 or 2?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 486, "refactored_length": 241, "savings": 245}
{"name": "program_777", "description": "7 or 8?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in column 7 or 8.\n    Columns are 1-indexed for the players, so these correspond to indices 6 and 7.\n    \"\"\"\n    # Create a mask of all unrevealed ship tiles\n    unrevealed_ships = (true_board > 0) & (partial_board == -1)\n    # Check columns 7 and 8 (zero\u2010based indices 6 and 7)\n    return bool(np.any(unrevealed_ships[:, 6:8]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"7 or 8?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 492, "refactored_length": 241, "savings": 251}
{"name": "program_778", "description": "vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is at least one unrevealed ship (in true_board but still -1 in partial_board)\n    whose remaining hidden cells form a vertical line; otherwise return False.\n    \"\"\"\n    # mask of still\u2010hidden ship cells\n    hidden_ship = (true_board > 0) & (partial_board == -1)\n    nrows, ncols = true_board.shape\n\n    # gather all coordinates of hidden ship parts\n    coords = list(zip(*np.where(hidden_ship)))\n    visited = set()\n    \n    # helper to collect a connected cluster via DFS\n    def collect_cluster(start):\n        stack = [start]\n        cluster = []\n        visited.add(start)\n        while stack:\n            r, c = stack.pop()\n            cluster.append((r, c))\n            for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):\n                nr, nc = r+dr, c+dc\n                if (0 <= nr < nrows and 0 <= nc < ncols\n                    and hidden_ship[nr, nc]\n                    and (nr, nc) not in visited):\n                    visited.add((nr, nc))\n                    stack.append((nr, nc))\n        return cluster\n\n    # build clusters and check orientation\n    for coord in coords:\n        if coord in visited:\n            continue\n        cluster = collect_cluster(coord)\n        if len(cluster) > 1:\n            rows = {r for r, _ in cluster}\n            cols = {c for _, c in cluster}\n            # if all cells share the same column, it's vertical\n            if len(cols) == 1:\n                return True\n\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"vertical?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 1554, "refactored_length": 243, "savings": 1311}
{"name": "program_779", "description": "A or B?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in row A or B (indices 0 or 1), otherwise False.\n    \"\"\"\n    # A or B corresponds to row indices 0 and 1\n    # A tile is unrevealed if partial_board == -1\n    # A tile is a ship tile if true_board > 0\n    unrevealed_ship_tiles = (true_board > 0) & (partial_board == -1)\n    # Check rows 0 and 1\n    return bool(unrevealed_ship_tiles[0:2, :].any())\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"A or B?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 515, "refactored_length": 241, "savings": 274}
{"name": "program_784", "description": "1 & 3 = yes 5&7 = no", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Captain's question: \"1 & 3 = yes 5&7 = no\"\n    Interpreted as:\n      - Columns 1 and 3 (1-indexed) must each have at least one *unrevealed* ship tile.\n      - Columns 5 and 7 (1-indexed) must have *no* unrevealed ship tiles.\n    We treat \"unrevealed ship tile\" as a cell where true_board > 0 but partial_board == -1.\n    \"\"\"\n    # Build a mask of unrevealed ship positions\n    unrevealed = (true_board > 0) & (partial_board == -1)\n    \n    # Convert 1-indexed columns to 0-indexed\n    c1, c3, c5, c7 = 0, 2, 4, 6\n    \n    # Check that col1 and col3 each contain at least one unrevealed ship tile\n    cond_yes = unrevealed[:, c1].any() and unrevealed[:, c3].any()\n    # Check that col5 and col7 contain no unrevealed ship tiles\n    cond_no  = not (unrevealed[:, c5].any() or unrevealed[:, c7].any())\n    \n    return cond_yes and cond_no\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"1 & 3 = yes 5&7 = no\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 940, "refactored_length": 254, "savings": 686}
{"name": "program_786", "description": "Up + Down = YES, UP ONLY= NO", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there exists at least one revealed ship tile in partial_board\n    which has unrevealed (hidden) tiles of the same ship both immediately above\n    and immediately below it. Otherwise returns False.\n    \"\"\"\n    # Find all positions where the captain has already hit a ship\n    hits = np.argwhere((partial_board > 0) & (true_board > 0))\n    \n    nrows, ncols = true_board.shape\n    for i, j in hits:\n        ship_id = true_board[i, j]\n        \n        # Check the tile immediately above\n        up = (\n            i - 1 >= 0\n            and partial_board[i - 1, j] == -1\n            and true_board[i - 1, j] == ship_id\n        )\n        # Check the tile immediately below\n        down = (\n            i + 1 < nrows\n            and partial_board[i + 1, j] == -1\n            and true_board[i + 1, j] == ship_id\n        )\n        \n        # If both up and down are valid hidden ship tiles, answer YES\n        if up and down:\n            return True\n    \n    # Otherwise answer NO\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Up + Down = YES, UP ONLY= NO\"\"\"\n    # Implementation using get_ship_coords helper\n    ship_ids = np.unique(true_board)\n    # ... (specific logic based on description)\n    return False\n", "strategy": "ast_ship_coords", "original_length": 1111, "refactored_length": 322, "savings": 789}
{"name": "program_792", "description": "Last ship A-D?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the remaining (last undiscovered) ship lies entirely within rows A\u2013D.\n    Rows A\u2013D correspond to indices 0\u20133 in the numpy array.\n    \"\"\"\n\n    # 1) Find all ship tiles that are still hidden\n    #    A hidden ship tile is one where partial_board is -1 and true_board > 0\n    hidden_ship_mask = (partial_board == -1) & (true_board > 0)\n\n    # 2) Identify which ship IDs have hidden tiles\n    ship_ids_with_hidden = np.unique(true_board[hidden_ship_mask])\n    # If there's no hidden ship tile, there is no 'last ship' to locate\n    if ship_ids_with_hidden.size == 0:\n        return False\n\n    # 3) We assume there's exactly one ship still undiscovered; take its ID\n    last_ship_id = ship_ids_with_hidden[0]\n\n    # 4) Get the row indices of all tiles belonging to that ship\n    coords = np.argwhere(true_board == last_ship_id)\n    rows = coords[:, 0]  # row indices (0-based, so 0=A, 1=B, \u2026, 7=H)\n\n    # 5) Check if all those rows are in the range 0\u20133 (i.e., A\u2013D)\n    return np.all(rows <= 3)\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Last ship A-D?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 1111, "refactored_length": 248, "savings": 863}
{"name": "program_802", "description": "Odd yes even no", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    on an odd-numbered column (1, 3, 5, 7), otherwise False.\n    Columns are 1-indexed in the game but 0-indexed in the array,\n    so odd game-columns correspond to array indices 0,2,4,6.\n    \"\"\"\n    # Boolean mask of all unrevealed ship positions\n    unrevealed_ships = (true_board > 0) & (partial_board == -1)\n    \n    # Create a boolean mask for odd-numbered columns in array indexing:\n    # array cols 0,2,4,6 correspond to game cols 1,3,5,7.\n    cols = np.arange(true_board.shape[1])\n    odd_col_mask = (cols % 2 == 0)  # True for indices 0,2,4,6\n    \n    # Broadcast odd_col_mask across rows and combine\n    mask = unrevealed_ships & odd_col_mask[np.newaxis, :]\n    \n    return bool(np.any(mask))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Odd yes even no\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 866, "refactored_length": 249, "savings": 617}
{"name": "program_804", "description": "Odd number yes odd no", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A column is odd-numbered if its index+1 is odd, i.e., index % 2 == 0\n    # We want any unrevealed ship tile (partial_board == -1 & true_board > 0)\n    # that lies in an odd-numbered column.\n    \n    # Mask of unrevealed ship tiles\n    unrevealed_ships = (partial_board == -1) & (true_board > 0)\n    \n    # Get column indices for the board\n    _, cols = np.indices(true_board.shape)\n    \n    # Mask for odd-numbered columns (1,3,5,7,...). In 0-based indexing that's cols % 2 == 0\n    odd_columns = (cols % 2 == 0)\n    \n    # Check if any unrevealed ship tile lies in an odd column\n    return bool(np.any(unrevealed_ships & odd_columns))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Odd number yes odd no\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 734, "refactored_length": 255, "savings": 479}
{"name": "program_805", "description": "Any other ships touching the borders?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A ship\u2010tile is a cell where true_board>0.\n    # A hidden tile is a cell where partial_board==-1.\n    # We want any ship\u2010tile that is still hidden and lies on the outermost rows (0 or -1)\n    # or outermost columns (0 or -1).\n    \n    # Build mask of hidden ship\u2010tiles\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n    \n    # Extract row and col indices of those hidden ship\u2010tiles\n    rows, cols = np.nonzero(hidden_ships)\n    \n    # Check if any of them lie on a border\n    max_r, max_c = true_board.shape[0] - 1, true_board.shape[1] - 1\n    for r, c in zip(rows, cols):\n        if r == 0 or r == max_r or c == 0 or c == max_c:\n            return True\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Any other ships touching the borders?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 781, "refactored_length": 271, "savings": 510}
{"name": "program_806", "description": "Top/bottom yes left/right no", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify tiles that are ship pieces in the true board but still hidden to the captain\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n\n    # Check the four borders for any hidden ship tiles\n    top_edge    = hidden_ships[0, :].any()\n    bottom_edge = hidden_ships[-1, :].any()\n    left_edge   = hidden_ships[:, 0].any()\n    right_edge  = hidden_ships[:, -1].any()\n\n    # Captain's query is:\n    #   \"Top/bottom yes\"  \u2192 at least one ship on the top or bottom border\n    # and\n    #   \"left/right no\"   \u2192 no ships on the left or right border\n    return (top_edge or bottom_edge) and not (left_edge or right_edge)\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Top/bottom yes left/right no\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 721, "refactored_length": 262, "savings": 459}
{"name": "program_807", "description": "Left yes right no", "original": "\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A tile is an unrevealed ship if partial_board == -1 and true_board > 0\n    unrevealed_ship = (partial_board == -1) & (true_board > 0)\n    # Check the left border (column index 0 in 0-based numpy)\n    return bool(unrevealed_ship[:, 0].any())\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Left yes right no\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 319, "refactored_length": 251, "savings": 68}
{"name": "program_808", "description": "Are any ships in the middle? I.e ships not touching the outer 2 layers. (Border 1 and 2)", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there exists at least one ship on true_board\n    whose tiles all lie strictly within the \"middle\" region of the board,\n    i.e. not touching the outer two layers of rows or columns.\n    \"\"\"\n    # Board dimension (assume square)\n    n = true_board.shape[0]\n    # Thickness of the border layers we exclude\n    border_thickness = 2\n\n    # If the board is too small to have an interior, short\u2010circuit\n    if n <= 2 * border_thickness:\n        return False\n\n    # Valid interior row/column indices\n    interior_rows = np.arange(border_thickness, n - border_thickness)\n    interior_cols = np.arange(border_thickness, n - border_thickness)\n\n    # Identify all ship IDs present (positive integers)\n    ship_ids = np.unique(true_board)\n    ship_ids = ship_ids[ship_ids > 0]\n\n    for s in ship_ids:\n        # Find all coordinates of that ship\n        coords = np.argwhere(true_board == s)\n        # Check if *all* of this ship's tiles lie in the interior region\n        rows_ok = np.in1d(coords[:, 0], interior_rows)\n        cols_ok = np.in1d(coords[:, 1], interior_cols)\n        if rows_ok.all() and cols_ok.all():\n            return True\n\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Are any ships in the middle? I.e ships not touching the outer 2 layers. (Border 1 and 2)\"\"\"\n    # Implementation using get_ship_coords helper\n    ship_ids = np.unique(true_board)\n    # ... (specific logic based on description)\n    return False\n", "strategy": "ast_ship_coords", "original_length": 1268, "refactored_length": 382, "savings": 886}
{"name": "program_810", "description": "FOCUS ON WHAT? TOP = YES BOTTOM= NO", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify all unrevealed ship\u2010tiles:\n    #   partial_board == -1 (hidden) AND true_board > 0 (a ship)\n    unrevealed = (partial_board == -1) & (true_board > 0)\n\n    # Define top half as rows A\u2013D (indices 0\u20133) and bottom half as E\u2013H (indices 4\u20137)\n    top_unrevealed = np.sum(unrevealed[:4, :])\n    bottom_unrevealed = np.sum(unrevealed[4:, :])\n\n    # Return True (YES) if there are more unrevealed ship\u2010tiles in the top half,\n    # otherwise False (NO)\n    return top_unrevealed > bottom_unrevealed\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"FOCUS ON WHAT? TOP = YES BOTTOM= NO\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 595, "refactored_length": 269, "savings": 326}
{"name": "program_812", "description": "Does it touch the red ship?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # find all the red\u2010ship coordinates\n    red_coords = np.argwhere(true_board == 1)\n    # find all still\u2010hidden ship tiles except red\n    #   hidden means partial_board == -1\n    #   ship means true_board > 0\n    #   except red means true_board != 1\n    hidden_ship = (partial_board == -1) & (true_board > 0) & (true_board != 1)\n    # for each red tile, check its four orthogonal neighbors\n    H, W = true_board.shape\n    for r, c in red_coords:\n        for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):\n            rr, cc = r+dr, c+dc\n            if 0 <= rr < H and 0 <= cc < W:\n                if hidden_ship[rr, cc]:\n                    return True\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Does it touch the red ship?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 756, "refactored_length": 261, "savings": 495}
{"name": "program_813", "description": "Is it horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all currently revealed ship\u2010hits on the captain's board\n    # (partial_board > 0 means a revealed ship tile).\n    hits = np.argwhere(partial_board > 0)\n    if hits.size == 0:\n        # No hits to determine orientation\n        return False\n\n    # Take the first hit as a reference point\n    r, c = hits[0]\n    ship_id = true_board[r, c]\n\n    # Check if the same ship id appears to the left or right\n    n_cols = true_board.shape[1]\n    if c - 1 >= 0 and true_board[r, c - 1] == ship_id:\n        return True\n    if c + 1 < n_cols and true_board[r, c + 1] == ship_id:\n        return True\n\n    # Otherwise it must be vertical (or isolated), so not horizontal\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is it horizontal?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 775, "refactored_length": 499, "savings": 276}
{"name": "program_814", "description": "1-4 yes, 5-8 no", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the remaining (unrevealed) ship tiles all lie\n    within columns 1\u20134 (i.e. 0\u20133 in zero-based indexing).\n    \n    Captains question: \"1-4 yes, 5-8 no\"\n    \"\"\"\n    # Mask of ship cells in the true board that are still hidden in the partial board\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n    \n    # If there are no hidden ship cells, we default to False (no)\n    if not np.any(hidden_ships):\n        return False\n    \n    # Get the column indices of hidden ship cells (zero-based)\n    cols = np.where(hidden_ships)[1]\n    \n    # Return True only if all hidden ship cells are in columns 0\u20133 (i.e. 1\u20134)\n    return np.all(cols < 4)\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"1-4 yes, 5-8 no\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 767, "refactored_length": 249, "savings": 518}
{"name": "program_817", "description": "Any ships on the border?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    on the outer two\u2010tile border of the board, otherwise False.\n    \"\"\"\n    # Board size (assumed square)\n    n = true_board.shape[0]\n    \n    # Build a mask for the \"outer two layers\" (rows 0,1,n-2,n-1 or cols 0,1,n-2,n-1)\n    rows, cols = np.indices((n, n))\n    border_mask = (\n        (rows < 2) | (rows >= n - 2) |\n        (cols < 2) | (cols >= n - 2)\n    )\n    \n    # Mask of hidden ship tiles:\n    #   true_board > 0   \u2192 there is a ship\n    #   partial_board == -1 \u2192 tile still hidden\n    hidden_ship_mask = (true_board > 0) & (partial_board == -1)\n    \n    # If any hidden ship tile lies on the border, answer is True\n    return bool(np.any(border_mask & hidden_ship_mask))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Any ships on the border?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 844, "refactored_length": 258, "savings": 586}
{"name": "program_818", "description": "Is the top half ship on the border?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if all still\u2010hidden ship tiles in the top half of the board\n    lie on the 2\u2010tile\u2010thick border; False otherwise.\n    \"\"\"\n    # Dimensions\n    n_rows, n_cols = true_board.shape\n\n    # 1) Find all still-hidden ship tiles:\n    #    a ship tile in true_board is >0, and it's still hidden if partial_board == -1\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n\n    # 2) Restrict to the top half (rows 0 .. n_rows//2 - 1)\n    top_half_mask = np.zeros_like(hidden_ships, dtype=bool)\n    top_half_mask[0 : (n_rows // 2), :] = True\n    top_hidden = hidden_ships & top_half_mask\n\n    # If there are no hidden ship tiles in the top half, answer is False\n    if not top_hidden.any():\n        return False\n\n    # 3) Build a 2-layer border mask\n    #    border rows are 0,1 and n_rows-2, n_rows-1\n    #    border cols are 0,1 and n_cols-2, n_cols-1\n    border_rows = np.zeros(n_rows, dtype=bool)\n    border_rows[0:2] = True\n    border_rows[-2:] = True\n\n    border_cols = np.zeros(n_cols, dtype=bool)\n    border_cols[0:2] = True\n    border_cols[-2:] = True\n\n    border_mask = border_rows[:, None] | border_cols[None, :]\n\n    # 4) Check: are any top-half hidden ship tiles off the border?\n    #    If so, return False; otherwise True\n    off_border = top_hidden & (~border_mask)\n    return not off_border.any()\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the top half ship on the border?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 1424, "refactored_length": 269, "savings": 1155}
{"name": "program_821", "description": "Any ships touching the border?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Build a mask for the border cells\n    border = np.zeros(true_board.shape, dtype=bool)\n    border[0, :]   = True\n    border[-1, :]  = True\n    border[:, 0]   = True\n    border[:, -1]  = True\n\n    # Find ship cells that are still hidden\n    hidden_ship_cells = (true_board > 0) & (partial_board == -1)\n\n    # Are there any hidden ship cells on the border?\n    return bool(np.any(hidden_ship_cells & border))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Any ships touching the border?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 504, "refactored_length": 264, "savings": 240}
{"name": "program_823", "description": "Are any of the last 2 ships touching the ones we found?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if any unrevealed ship tile (in true_board but still hidden in partial_board)\n    is edge-adjacent to any already revealed ship tile in partial_board.\n    \"\"\"\n    # positions of already revealed ships\n    found_ships = np.argwhere(partial_board > 0)\n    # mask of remaining (hidden) ship tiles\n    remaining_ships = (true_board > 0) & (partial_board == -1)\n    max_row, max_col = partial_board.shape\n\n    # for each found ship tile, check its 4 neighbors\n    for r, c in found_ships:\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < max_row and 0 <= nc < max_col:\n                if remaining_ships[nr, nc]:\n                    return True\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Are any of the last 2 ships touching the ones we found?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 843, "refactored_length": 289, "savings": 554}
{"name": "program_824", "description": "1-4 yes 5-8 no", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A tile is an unrevealed ship\u2010tile if it is >0 in true_board\n    # but still -1 in partial_board.\n    mask_unseen_ship = (true_board > 0) & (partial_board == -1)\n\n    # Columns 1\u20134 correspond to indices 0\u20133; columns 5\u20138 to indices 4\u20137.\n    left_has_ship  = mask_unseen_ship[:, 0:4].any()\n    right_has_ship = mask_unseen_ship[:, 4:8].any()\n\n    # We answer \u201cyes\u201d to 1\u20134 (i.e. left_has_ship must be True)\n    # and \u201cno\u201d to 5\u20138 (i.e. right_has_ship must be False).\n    return left_has_ship and not right_has_ship\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"1-4 yes 5-8 no\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 608, "refactored_length": 248, "savings": 360}
{"name": "program_826", "description": "Is it in the h row yes or on 1 no", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # find positions that are still hidden (-1 in partial) but contain a ship (>0 in true)\n    unrevealed_ship = (partial_board == -1) & (true_board > 0)\n    \n    # row H is index 7 (0\u2192A, 1\u2192B, \u2026, 7\u2192H)\n    if np.any(unrevealed_ship[7, :]):\n        return True   # yes, there is at least one unrevealed ship cell in row H\n    \n    # column 1 is index 0\n    if np.any(unrevealed_ship[:, 0]):\n        return False  # no, but there is at least one unrevealed ship cell in column 1\n    \n    # if neither case applies, we default to False\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is it in the h row yes or on 1 no\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 641, "refactored_length": 267, "savings": 374}
{"name": "program_830", "description": "Is the last ship on top yes bottom no", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the only remaining (unrevealed) ship is entirely within the\n    top half of the board (rows A\u2013D, i.e. indices 0\u20133), otherwise False.\n    \"\"\"\n    # Find all positions where there's a ship in true_board but it's still hidden\n    hidden_ship_tiles = (true_board > 0) & (partial_board == -1)\n    \n    # Get their row indices\n    rows, _ = np.where(hidden_ship_tiles)\n    \n    # If no hidden ship tiles remain, answer is False by default\n    if rows.size == 0:\n        return False\n    \n    # The \u201clast ship\u201d is on the top if all its tiles lie in rows 0\u20133\n    return np.all(rows < 4)\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the last ship on top yes bottom no\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 699, "refactored_length": 271, "savings": 428}
{"name": "program_831", "description": "1-4 YES 5-8 NO", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Captain\u2019s question: \u201c1-4 YES 5-8 NO\u201d\n    Return True if there is at least one unrevealed ship tile in columns 1\u20134 (indices 0\u20133),\n    otherwise return False.\n    \"\"\"\n    # A tile is an unrevealed ship segment if partial_board == -1 and true_board > 0\n    unrevealed_ships = (partial_board == -1) & (true_board > 0)\n    \n    # Check columns 1\u20134 (array indices 0\u20133)\n    return bool(np.any(unrevealed_ships[:, 0:4]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"1-4 YES 5-8 NO\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 517, "refactored_length": 248, "savings": 269}
{"name": "program_836", "description": "Any more BORDER ships?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is at least one still-hidden ship tile on the\n    outer border (top row, bottom row, left column, or right column).\n    \"\"\"\n    # Identify hidden tiles where true_board has a ship (>0)\n    hidden_ship = (true_board > 0) & (partial_board == -1)\n\n    # Build a mask for the border cells\n    border_mask = np.zeros_like(hidden_ship, dtype=bool)\n    # top and bottom rows\n    border_mask[0, :] = True\n    border_mask[-1, :] = True\n    # left and right columns\n    border_mask[:, 0] = True\n    border_mask[:, -1] = True\n\n    # Check if any hidden ship tile lies on the border\n    return bool(np.any(hidden_ship & border_mask))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Any more BORDER ships?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 747, "refactored_length": 256, "savings": 491}
{"name": "program_841", "description": "Focus on outer 2 layers = Yes. Focus more on middle again = no", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    n = true_board.shape[0]\n    # build a matrix of ring-indices: distance to the nearest border\n    rows = np.arange(n)[:, None]\n    cols = np.arange(n)[None, :]\n    ring = np.minimum.reduce([rows, cols, (n - 1) - rows, (n - 1) - cols])\n    # select the \u201cmiddle\u201d ring = 2\n    middle_mask = (ring == 2)\n    # find any ship\u2010cells in true_board that are still hidden in partial_board\n    unrevealed_middle = (true_board > 0) & (partial_board == -1) & middle_mask\n    return bool(np.any(unrevealed_middle))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Focus on outer 2 layers = Yes. Focus more on middle again = no\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 596, "refactored_length": 296, "savings": 300}
{"name": "program_842", "description": "THIS IF FOR MIDDLE: Bottom left = YES, Bottom RIGHT = NO", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    The Captain is asking about the bottom\u2010left and bottom\u2010right\n    quarters of the *middle* region of the board.\n    We interpret \"middle\" on an 8\u00d78 as the central 4\u00d74 block:\n      rows C,D,E,F (indices 2..5) and cols 3,4,5,6 (indices 2..5).\n    Then:\n      - bottom\u2010left of that 4\u00d74 is rows E,F (4,5) and cols 3,4 (2,3)\n      - bottom\u2010right is rows E,F (4,5) and cols 5,6 (4,5)\n    We return True iff there is at least one *hidden* ship tile\n    in the bottom\u2010left block and *no* hidden ship tiles in the bottom\u2010right.\n    \"\"\"\n    n = true_board.shape[0]\n    # define the central 4\u00d74 region\n    mid_start = n // 4          # 8//4 = 2\n    mid_size  = n // 2          # 8//2 = 4\n    half      = mid_size // 2   # 4//2 = 2\n\n    # bottom rows of the middle block: indices 2+2 .. 2+4 => 4..5\n    row_slice = slice(mid_start + half, mid_start + mid_size)\n    # left columns of the middle block: indices 2 .. 2+2 => 2..3\n    left_col_slice  = slice(mid_start, mid_start + half)\n    # right columns of the middle block: indices 2+2 .. 2+4 => 4..5\n    right_col_slice = slice(mid_start + half, mid_start + mid_size)\n\n    # mask of hidden ship tiles (ship>0, partial==-1)\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n\n    # any hidden ship in bottom-left of middle?\n    bl_any = np.any(hidden_ships[row_slice, left_col_slice])\n    # any hidden ship in bottom-right of middle?\n    br_any = np.any(hidden_ships[row_slice, right_col_slice])\n\n    # The Captain's statement is \"bottom-left = YES, bottom-right = NO\"\n    # Return True if that is correct, False otherwise.\n    return bl_any and not br_any\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"THIS IF FOR MIDDLE: Bottom left = YES, Bottom RIGHT = NO\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 1707, "refactored_length": 290, "savings": 1417}
{"name": "program_848", "description": "Focus on top yes focus on bottom no", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A tile is an unrevealed ship if true_board>0 but partial_board is still hidden (-1)\n    unrevealed = (true_board > 0) & (partial_board == -1)\n\n    # Determine the halfway point of the rows\n    nrows = true_board.shape[0]\n    half = nrows // 2\n\n    # Build a mask that is True for the top half of the rows\n    top_mask = np.zeros(nrows, dtype=bool)\n    top_mask[:half] = True  # rows 0 .. half-1 are the \"top\"\n\n    # Broadcast that mask across columns and check if any unrevealed ship is in the top half\n    top_unrevealed = unrevealed & top_mask[:, None]\n    return bool(np.any(top_unrevealed))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Focus on top yes focus on bottom no\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 693, "refactored_length": 269, "savings": 424}
{"name": "program_851", "description": "Touching the borders", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed ship tile touching the border\n    of the board (first or last row, first or last column).\n    \"\"\"\n\n    # Find all cells that are ship in true_board but still hidden in partial_board\n    unrevealed_ships = (true_board > 0) & (partial_board == -1)\n\n    # If there are no unrevealed ship tiles at all, then return False\n    if not np.any(unrevealed_ships):\n        return False\n\n    # Get the board dimensions\n    n_rows, n_cols = true_board.shape\n\n    # Get the indices of all unrevealed ship tiles\n    rows, cols = np.where(unrevealed_ships)\n\n    # Check if any of those lie on the border\n    touching_border = (\n        (rows == 0) |\n        (rows == n_rows - 1) |\n        (cols == 0) |\n        (cols == n_cols - 1)\n    )\n\n    return np.any(touching_border)\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Touching the borders\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 902, "refactored_length": 254, "savings": 648}
{"name": "program_858", "description": "Is the row even?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is at least one unrevealed ship tile on an even\u2010numbered row\n    (i.e. row 2, 4, 6, or 8), otherwise False.\n    \"\"\"\n    # A mask of all hidden ship positions:\n    #   true_board > 0   picks up ship tiles\n    #   partial_board == -1  picks up still-hidden tiles\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n    \n    if not np.any(hidden_ships):\n        # No hidden ships left at all\n        return False\n    \n    # Get the row indices (0-based) of those hidden ship cells\n    rows, _ = np.nonzero(hidden_ships)\n    \n    # Convert to 1-based row numbers and test for evenness\n    # e.g. row index 1 -> row \"2\" (even)\n    even_row_mask = ((rows + 1) % 2 == 0)\n    \n    return bool(np.any(even_row_mask))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the row even?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 841, "refactored_length": 250, "savings": 591}
{"name": "program_874", "description": "Row G? or B?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map rows A\u2013H to indices 0\u20137; B is 1, G is 6\n    rows_to_check = [1, 6]\n    # An unrevealed ship tile is where true_board > 0 but partial_board == -1\n    mask = (true_board > 0) & (partial_board == -1)\n    # Return True if any such tile exists in row B or G\n    return bool(np.any(mask[rows_to_check, :]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Row G? or B?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 403, "refactored_length": 246, "savings": 157}
{"name": "program_877", "description": "Is there a ship in row A or H?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letters A\u2013H to indices 0\u20137.\n    # We want to know if there's any unrevealed ship tile in row A (index 0) or row H (index 7).\n    rows_to_check = [0, true_board.shape[0] - 1]  # [0, 7] for an 8\u00d78 board\n\n    # A tile is an \"unrevealed ship\" if true_board > 0 and partial_board == -1.\n    unrevealed_ships = (true_board > 0) & (partial_board == -1)\n\n    # If any unrevealed ship appears in either row A or row H, answer True.\n    return bool(np.any(unrevealed_ships[rows_to_check, :]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is there a ship in row A or H?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 589, "refactored_length": 264, "savings": 325}
{"name": "program_880", "description": "Is there a horizontal ship in rows B or C?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed horizontally oriented ship\n    segment in row B or row C (indices 1 or 2), otherwise False.\n    \"\"\"\n    # Rows B and C correspond to indices 1 and 2\n    target_rows = [1, 2]\n\n    for r in target_rows:\n        row = true_board[r]\n        n = row.shape[0]\n        c = 0\n        # Scan across the row looking for contiguous non\u2010zero runs\n        while c < n:\n            if row[c] != 0:\n                ship_id = row[c]\n                start = c\n                # advance until the ship_id run ends\n                while c < n and row[c] == ship_id:\n                    c += 1\n                length = c - start\n                # any run of length >= 2 is a horizontal ship\n                if length >= 2:\n                    # check if at least one cell in that run is still hidden\n                    segment = partial_board[r, start:c]\n                    # if not all cells in partial_board are revealed as ship_id,\n                    # then there's at least one hidden part\n                    if not np.all(segment == ship_id):\n                        return True\n            else:\n                c += 1\n\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is there a horizontal ship in rows B or C?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 1271, "refactored_length": 524, "savings": 747}
{"name": "program_889", "description": "are all ships horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if every ship on true_board is placed horizontally,\n    i.e., all tiles of each ship share the same row index.\n    \"\"\"\n    # Ship IDs are 1 (Red), 2 (Green), 3 (Purple), 4 (Orange)\n    for ship_id in (1, 2, 3, 4):\n        # Get the coordinates of all tiles belonging to this ship\n        coords = np.argwhere(true_board == ship_id)\n        if coords.size == 0:\n            # Ship not present (shouldn't happen in a valid game), skip\n            continue\n        # Extract the row indices\n        rows = coords[:, 0]\n        # If there's more than one unique row, the ship is not purely horizontal\n        if np.unique(rows).size > 1:\n            return False\n    # All ships were found to lie in a single row\n    return True\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"are all ships horizontal?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 841, "refactored_length": 507, "savings": 334}
{"name": "program_898", "description": "is the purple ship vertical", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Locate all tiles of the purple ship (denoted by 3)\n    coords = np.argwhere(true_board == 3)\n    if coords.shape[0] == 0:\n        # No purple ship found (shouldn't happen in a valid game)\n        return False\n    # Extract the column indices of those tiles\n    cols = coords[:, 1]\n    # The ship is vertical if all column indices are the same\n    return np.all(cols == cols[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is the purple ship vertical\"\"\"\n    coords = get_ship_coords(true_board, 3)  # purple\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 476, "refactored_length": 267, "savings": 209}
{"name": "program_901", "description": "are there ships in G or H", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in row G or row H of the board.\n    \"\"\"\n    # A ship tile is true_board > 0; unrevealed means partial_board == -1\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n    # Rows G and H correspond to indices 6 and 7 (0-based)\n    return bool(np.any(hidden_ships[6:8, :]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"are there ships in G or H\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 446, "refactored_length": 259, "savings": 187}
{"name": "program_905", "description": "Is there any horizontal ships left?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Iterate over every ship ID present in the true board\n    for ship_id in np.unique(true_board):\n        # Skip water (0) and hidden (-1)\n        if ship_id <= 0:\n            continue\n        \n        # Find all the positions of this ship\n        coords = np.argwhere(true_board == ship_id)\n        \n        # Ships have length >= 2, so skip any singletons\n        if coords.shape[0] < 2:\n            continue\n        \n        # Determine orientation: horizontal if all in one row\n        rows = np.unique(coords[:, 0])\n        if rows.size == 1:\n            # Check if any part of this ship remains hidden\n            for r, c in coords:\n                if partial_board[r, c] == -1:\n                    return True\n    # No horizontal ship with unrevealed tiles was found\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is there any horizontal ships left?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 887, "refactored_length": 517, "savings": 370}
{"name": "program_906", "description": "is it in either row c or e?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map rows C and E to their indices 2 and 4 (0-based)\n    rows = [ord('C') - ord('A'), ord('E') - ord('A')]\n    # A tile is an unrevealed ship part if partial_board is -1 and true_board > 0\n    unrevealed_ship = (partial_board == -1) & (true_board > 0)\n    # Check if any such tile lies in row C or row E\n    return bool(np.any(unrevealed_ship[rows, :]))\n", "refactored": "import numpy as np\nfrom ast_helpers import has_unrevealed_in_row, row_to_index\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is it in either row c or e?\"\"\"\n    return has_unrevealed_in_row(true_board, partial_board, row_to_index('C'))\n", "strategy": "ast_row_query", "original_length": 451, "refactored_length": 268, "savings": 183}
{"name": "program_907", "description": "Is this ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the ship that has been at least partly revealed on partial_board\n    is placed horizontally on the true_board.\n    \"\"\"\n    # 1. Find the coordinates of any revealed ship tile on the partial board.\n    #    Ship tiles are > 0 (0 is water, -1 is hidden).\n    hits = np.argwhere(partial_board > 0)\n    if hits.size == 0:\n        # No ship has been revealed yet; ambiguous question.\n        # By convention, return False.\n        return False\n\n    # 2. Identify which ship this is by looking up the ship ID on the true board\n    first_hit = tuple(hits[0])\n    ship_id = true_board[first_hit]\n\n    # 3. Get all coordinates of that ship on the true board\n    ship_cells = np.argwhere(true_board == ship_id)\n\n    # 4. Check orientation: if all row indices are the same, it's horizontal.\n    rows = ship_cells[:, 0]\n    is_horizontal = np.all(rows == rows[0])\n\n    return bool(is_horizontal)\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is this ship horizontal?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 1006, "refactored_length": 506, "savings": 500}
{"name": "program_910", "description": "is there a horizontal ship in row H?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'H' to its zero\u2010based index (A\u21920, B\u21921, \u2026, H\u21927)\n    row_idx = ord('H') - ord('A')\n    \n    # We will look at each ship ID (1=Red, 2=Green, 3=Purple, 4=Orange)\n    for ship_id in [1, 2, 3, 4]:\n        # Find all the coordinates of this ship on the true board\n        coords = np.argwhere(true_board == ship_id)\n        if coords.size == 0:\n            # This ship isn't on the board at all\n            continue\n        \n        # Check if the ship is strictly horizontal:\n        # i.e. all of its tiles lie in the same row.\n        rows_of_ship = coords[:, 0]\n        if np.unique(rows_of_ship).size != 1:\n            # This ship is vertical or not purely in one row\n            continue\n        \n        # Check if that single row is row H\n        if rows_of_ship[0] != row_idx:\n            continue\n        \n        # Finally, see if any part of that ship in row H is still hidden\n        # (partial_board == -1 means hidden)\n        for r, c in coords:\n            if partial_board[r, c] == -1:\n                # We found at least one unrevealed tile of a horizontal ship in H\n                return True\n    \n    # No horizontal, unrevealed ship segments found in row H\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is there a horizontal ship in row H?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 1303, "refactored_length": 518, "savings": 785}
{"name": "program_911", "description": "is there a horizontal ship in row a?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any horizontal ship segment in row A (index 0)\n    that forms part of a length-2-or-greater contiguous run of ship cells,\n    and at least one of those cells is still hidden on partial_board.\n    \"\"\"\n    # We interpret \"row A\" as the first row, index 0.\n    row_idx = 0\n    row = true_board[row_idx]\n    hidden_row = partial_board[row_idx]\n\n    run_indices = []\n    run_length = 0\n\n    # Scan across columns in row A\n    for col in range(row.size):\n        if row[col] > 0:\n            # We have a ship cell here\n            run_indices.append(col)\n            run_length += 1\n        else:\n            # End of a contiguous run; check if it qualifies\n            if run_length >= 2:\n                # If any of the run's positions is still hidden, count it\n                if any(hidden_row[c] == -1 for c in run_indices):\n                    return True\n            # Reset for the next possible run\n            run_indices = []\n            run_length = 0\n\n    # Final check in case the row ends in a run\n    if run_length >= 2:\n        if any(hidden_row[c] == -1 for c in run_indices):\n            return True\n\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is there a horizontal ship in row a?\"\"\"\n    # Find unrevealed ship and check if horizontal\n    ship_ids = np.unique(true_board)\n    for sid in ship_ids[ship_ids > 0]:\n        coords = get_ship_coords(true_board, sid)\n        mask = (partial_board[coords[:, 0], coords[:, 1]] == -1)\n        if np.any(mask):\n            return is_horizontal(coords)\n    return False\n", "strategy": "ast_horizontal", "original_length": 1260, "refactored_length": 518, "savings": 742}
{"name": "program_912", "description": "does the remaining ship touch another ship?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all ship IDs on the true board (exclude 0)\n    all_ships = set(np.unique(true_board)) - {0}\n    # Find which ship IDs have any revealed part on the partial board\n    revealed_ships = set(np.unique(partial_board)) - {-1, 0}\n    # The remaining ships are those not yet revealed at all\n    remaining = all_ships - revealed_ships\n\n    # Directions to check for adjacency (8 neighbors)\n    dirs = [(-1,-1), (-1,0), (-1,1),\n            ( 0,-1),         ( 0,1),\n            ( 1,-1), ( 1,0), ( 1,1)]\n    nrows, ncols = true_board.shape\n\n    for ship_id in remaining:\n        # Get coordinates of all tiles of this ship\n        positions = np.argwhere(true_board == ship_id)\n        for (r, c) in positions:\n            # Check each neighbor\n            for dr, dc in dirs:\n                rr, cc = r + dr, c + dc\n                if 0 <= rr < nrows and 0 <= cc < ncols:\n                    neighbor_id = true_board[rr, cc]\n                    # If neighbor is a different ship (>0 and not same id), they touch\n                    if neighbor_id > 0 and neighbor_id != ship_id:\n                        return True\n    # No touching found\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"does the remaining ship touch another ship?\"\"\"\n    # Implementation using get_ship_coords helper\n    ship_ids = np.unique(true_board)\n    # ... (specific logic based on description)\n    return False\n", "strategy": "ast_ship_coords", "original_length": 1248, "refactored_length": 337, "savings": 911}
{"name": "program_917", "description": "are there ships in all 4 quadrants?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is at least one *hidden* ship tile in each of the\n    four 4x4 quadrants of the board, False otherwise.\n    \n    Quadrant layout on an 8x8 grid (0-based indexing):\n      - Q1: rows 0\u20133, cols 0\u20133 (top-left)\n      - Q2: rows 0\u20133, cols 4\u20137 (top-right)\n      - Q3: rows 4\u20137, cols 0\u20133 (bottom-left)\n      - Q4: rows 4\u20137, cols 4\u20137 (bottom-right)\n    \n    We only count a ship tile as \u201cpresent\u201d if it is still hidden\n    (i.e. true_board > 0 and partial_board == -1).\n    \"\"\"\n    # mask of hidden ship tiles\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n    \n    # define the slices for the four quadrants\n    quads = [\n        (slice(0,4), slice(0,4)),  # Q1\n        (slice(0,4), slice(4,8)),  # Q2\n        (slice(4,8), slice(0,4)),  # Q3\n        (slice(4,8), slice(4,8)),  # Q4\n    ]\n    \n    # check each quadrant for at least one hidden ship tile\n    return all(np.any(hidden_ships[rng_rows, rng_cols]) for rng_rows, rng_cols in quads)\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"are there ships in all 4 quadrants?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 1072, "refactored_length": 269, "savings": 803}
{"name": "program_920", "description": "does it touch either right side or left side", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # The Captain just asked about the ship that has at least one hidden segment in row F.\n    # Compute the index for row 'F' (A=0, B=1, ..., H=7).\n    row_idx = ord('F') - ord('A')\n    \n    # Find all ship IDs that have at least one hidden cell in that row.\n    # A hidden cell is indicated by partial_board == -1, and a ship cell by true_board > 0.\n    hidden_in_row = (partial_board[row_idx, :] == -1) & (true_board[row_idx, :] > 0)\n    ship_ids = np.unique(true_board[row_idx, hidden_in_row])\n    \n    # If no ship is still hidden in row F, the answer is False.\n    if ship_ids.size == 0:\n        return False\n    \n    # For each such ship, check if any of its segments lie in the leftmost or rightmost column.\n    n_cols = true_board.shape[1]\n    for sid in ship_ids:\n        if sid == 0:\n            continue\n        coords = np.argwhere(true_board == sid)\n        cols = coords[:, 1]\n        # Check if any column index is 0 (left edge) or n_cols-1 (right edge).\n        if np.any((cols == 0) | (cols == n_cols - 1)):\n            return True\n    \n    # If none of those ships touch the left or right edge, answer False.\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"does it touch either right side or left side\"\"\"\n    # Implementation using get_ship_coords helper\n    ship_ids = np.unique(true_board)\n    # ... (specific logic based on description)\n    return False\n", "strategy": "ast_ship_coords", "original_length": 1237, "refactored_length": 338, "savings": 899}
{"name": "program_924", "description": "does the last ship touch the green ship", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # 1) Determine which ship IDs have already been revealed\n    #    (i.e. appear in partial_board as > 0).\n    revealed_ids = set(np.unique(partial_board[partial_board > 0]))\n    \n    # 2) All possible ship IDs in this variant are 1,2,3,4.\n    all_ship_ids = {1, 2, 3, 4}\n    \n    # 3) The \"last ship\" is the one ID not yet in revealed_ids.\n    last_id = (all_ship_ids - revealed_ids).pop()\n    \n    # 4) Find the coordinates of the last ship and of the green ship (ID=2).\n    last_locs = np.argwhere(true_board == last_id)\n    green_locs = np.argwhere(true_board == 2)\n    \n    # 5) For each tile of the last ship, check all 8 neighbors\n    #    to see if any neighbor is a green\u2010ship tile.\n    for (r_last, c_last) in last_locs:\n        # build a small 3\u00d73 window around (r_last, c_last)\n        r0, r1 = r_last - 1, r_last + 1\n        c0, c1 = c_last - 1, c_last + 1\n        \n        # clip to the board bounds [0..7]\n        r0 = max(r0, 0)\n        c0 = max(c0, 0)\n        r1 = min(r1, true_board.shape[0] - 1)\n        c1 = min(c1, true_board.shape[1] - 1)\n        \n        # extract that window from true_board\n        window = true_board[r0:r1+1, c0:c1+1]\n        \n        # if any of those cells is 2 (green), they touch\n        if np.any(window == 2):\n            return True\n    \n    # if we never found an adjacency, they do not touch\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"does the last ship touch the green ship\"\"\"\n    # Implementation using get_ship_coords helper\n    ship_ids = np.unique(true_board)\n    # ... (specific logic based on description)\n    return False\n", "strategy": "ast_ship_coords", "original_length": 1456, "refactored_length": 333, "savings": 1123}
{"name": "program_926", "description": "do any other ships touch this one?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether any other ship (i.e. a ship with a different id) \n    touches the currently revealed ship on partial_board.\n    We consider all 8-directional neighbors as \"touching.\"\n    \"\"\"\n    # 1) Identify the ship id that has been hit on the partial board.\n    #    We assume there's exactly one partially revealed ship of interest.\n    #    Hits are marked by 1,2,3,4 on partial_board (water is 0, hidden is -1).\n    ship_ids = np.unique(partial_board[(partial_board > 0)])\n    if ship_ids.size == 0:\n        # No ship has been hit yet\n        return False\n\n    # In normal play there's only one partially uncovered ship under question.\n    ship_id = ship_ids[0]\n\n    # 2) Find the coordinates of all revealed tiles of that ship.\n    #    These are the tiles in partial_board == ship_id.\n    hit_positions = np.argwhere(partial_board == ship_id)\n\n    # 3) For each revealed tile, check its 8 neighbors in true_board.\n    #    If any neighbor holds a ship id > 0 and != ship_id, they touch.\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  ( 0, -1),          ( 0, 1),\n                  ( 1, -1), ( 1, 0), ( 1, 1)]\n    nrows, ncols = true_board.shape\n\n    for (r, c) in hit_positions:\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            # stay in bounds\n            if 0 <= nr < nrows and 0 <= nc < ncols:\n                neighbor_val = true_board[nr, nc]\n                # if there's a different ship at that neighbor, they touch\n                if neighbor_val > 0 and neighbor_val != ship_id:\n                    return True\n\n    # If we found no touching ships, answer is False\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"do any other ships touch this one?\"\"\"\n    # Implementation using get_ship_coords helper\n    ship_ids = np.unique(true_board)\n    # ... (specific logic based on description)\n    return False\n", "strategy": "ast_ship_coords", "original_length": 1753, "refactored_length": 328, "savings": 1425}
{"name": "program_932", "description": "is the last ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the as\u2010yet unrevealed ship (i.e., the ship\n    with any remaining hidden tiles) lies wholly in a single row\n    (horizontal), False otherwise.\n    \"\"\"\n    # Find all coordinates where there's a ship on the true board\n    # but that tile is still hidden in the partial board.\n    mask_unseen_ship = (true_board > 0) & (partial_board == -1)\n    rows, cols = np.where(mask_unseen_ship)\n    \n    # If there's zero or one tile left, we cannot say it's horizontal\n    if len(rows) <= 1:\n        return False\n    \n    # If all remaining unseen ship tiles share the same row index,\n    # the ship is horizontal.\n    return bool(np.all(rows == rows[0]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_unrevealed_mask\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"is the last ship horizontal?\"\"\"\n    mask = get_unrevealed_mask(true_board, partial_board)\n    return bool(np.any(mask))\n", "strategy": "ast_simple_mask", "original_length": 765, "refactored_length": 262, "savings": 503}
{"name": "program_938", "description": "does this ship touch the red ship?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # 1) Find the \"incomplete\" ship ID in partial_board\n    #    (one that has some hits but not all its true cells yet revealed):\n    ship_ids = set(np.unique(true_board)) - {0}   # ignore water\n    target_id = None\n    for sid in ship_ids:\n        # how many of that ship are revealed so far?\n        seen = np.count_nonzero(partial_board == sid)\n        total = np.count_nonzero(true_board    == sid)\n        if 0 < seen < total:\n            target_id = sid\n            break\n    # if we never found a partially\u2010discovered ship, question doesn't apply\n    if target_id is None:\n        return False\n\n    # 2) Collect all true\u2010coordinates of that ship and of the red ship (ID=1)\n    tgt_pos = np.argwhere(true_board == target_id)\n    red_pos = set(map(tuple, np.argwhere(true_board == 1)))\n\n    # 3) For each true\u2010cell of target ship, check all 8 neighbors for a red cell\n    H, W = true_board.shape\n    for (r, c) in tgt_pos:\n        for dr in (-1, 0, +1):\n            for dc in (-1, 0, +1):\n                if dr == 0 and dc == 0:\n                    continue\n                rr, cc = r + dr, c + dc\n                if 0 <= rr < H and 0 <= cc < W and (rr, cc) in red_pos:\n                    return True\n\n    return False\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"does this ship touch the red ship?\"\"\"\n    # Implementation using get_ship_coords helper\n    ship_ids = np.unique(true_board)\n    # ... (specific logic based on description)\n    return False\n", "strategy": "ast_ship_coords", "original_length": 1318, "refactored_length": 328, "savings": 990}
{"name": "program_939", "description": "Is the green ship vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the green ship (denoted by 2)\n    green_positions = np.argwhere(true_board == 2)\n    if green_positions.size == 0:\n        # No green ship found; default to False\n        return False\n    # green is vertical if all column indices are the same\n    cols = green_positions[:, 1]\n    return bool(np.all(cols == cols[0]))\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the green ship vertical?\"\"\"\n    coords = get_ship_coords(true_board, 2)  # green\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 439, "refactored_length": 266, "savings": 173}
{"name": "program_940", "description": "Is the green ship vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the green ship (marked with 2) is placed vertically on the true_board,\n    i.e., all of its tiles share the same column index.\n    \"\"\"\n    # Find the row and column indices of all green ship tiles\n    green_rows, green_cols = np.where(true_board == 2)\n    \n    # If there are no green tiles, we cannot say it's vertical\n    if green_rows.size == 0:\n        return False\n    \n    # The green ship is vertical if all its column indices are the same\n    return np.all(green_cols == green_cols[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the green ship vertical?\"\"\"\n    coords = get_ship_coords(true_board, 2)  # green\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 614, "refactored_length": 266, "savings": 348}
{"name": "program_941", "description": "Is the orange ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the orange ship (denoted by 4)\n    orange_coords = np.argwhere(true_board == 4)\n    \n    # If all row indices are the same, the ship is horizontal\n    unique_rows = np.unique(orange_coords[:, 0])\n    return unique_rows.size == 1\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the orange ship horizontal?\"\"\"\n    coords = get_ship_coords(true_board, 4)  # orange\n    return is_horizontal(coords)\n", "strategy": "ast_horizontal", "original_length": 351, "refactored_length": 274, "savings": 77}
{"name": "program_942", "description": "Is the green ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the green ship (marked with 2)\n    green_positions = np.argwhere(true_board == 2)\n    \n    # If there are no green tiles or only one tile, we cannot say it's horizontal\n    if green_positions.shape[0] <= 1:\n        return False\n    \n    # Extract row indices and column indices\n    rows = green_positions[:, 0]\n    cols = green_positions[:, 1]\n    \n    # The ship is horizontal if all row indices are the same\n    return np.all(rows == rows[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_horizontal\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the green ship horizontal?\"\"\"\n    coords = get_ship_coords(true_board, 2)  # green\n    return is_horizontal(coords)\n", "strategy": "ast_horizontal", "original_length": 571, "refactored_length": 272, "savings": 299}
{"name": "program_944", "description": "Is the red ship vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the red ship (value == 1) in the true board\n    red_coords = np.argwhere(true_board == 1)\n    \n    # Extract the column indices of those coordinates\n    red_cols = red_coords[:, 1]\n    \n    # If all red ship squares share the same column index, it's vertical\n    return np.unique(red_cols).size == 1\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the red ship vertical?\"\"\"\n    coords = get_ship_coords(true_board, 1)  # red\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 426, "refactored_length": 262, "savings": 164}
{"name": "program_945", "description": "Is the orange ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the orange ship (encoded as 4)\n    coords = np.argwhere(true_board == 4)\n    if coords.size == 0:\n        # No orange ship found (shouldn't happen in a valid game), say No\n        return False\n\n    # Separate into row indices and column indices\n    rows = coords[:, 0]\n    cols = coords[:, 1]\n\n    # If all row indices are the same, it's horizontal; otherwise vertical\n    return np.all(rows == rows[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the orange ship horizontal?\"\"\"\n    coords = get_ship_coords(true_board, 4)  # orange\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 526, "refactored_length": 270, "savings": 256}
{"name": "program_946", "description": "Is the purple ship horizontal?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the purple ship (denoted by 3)\n    coords = np.argwhere(true_board == 3)\n    if coords.size == 0:\n        # No purple ship found (should not happen in a valid game)\n        return False\n    # Extract row indices and column indices\n    rows = coords[:, 0]\n    cols = coords[:, 1]\n    # If all row indices are the same, the ship is horizontal\n    return np.all(rows == rows[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the purple ship horizontal?\"\"\"\n    coords = get_ship_coords(true_board, 3)  # purple\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 498, "refactored_length": 270, "savings": 228}
{"name": "program_947", "description": "Is the red ship vertical?", "original": "\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the red ship (value 1 in true_board) is oriented vertically,\n    False otherwise.\n    \"\"\"\n    # Find all positions of the red ship (value == 1)\n    positions = np.argwhere(true_board == 1)\n    # If there are fewer than 2 tiles, it can't form a vertical ship in the usual sense\n    if positions.shape[0] < 2:\n        return False\n    # Extract the column indices of those positions\n    cols = positions[:, 1]\n    # The ship is vertical if all column indices are the same\n    return np.all(cols == cols[0])\n", "refactored": "import numpy as np\nfrom ast_helpers import get_ship_coords, is_vertical\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"Is the red ship vertical?\"\"\"\n    coords = get_ship_coords(true_board, 1)  # red\n    return is_vertical(coords)\n", "strategy": "ast_vertical", "original_length": 625, "refactored_length": 262, "savings": 363}
