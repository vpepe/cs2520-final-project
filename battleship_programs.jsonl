{"description":"is there a ship longer than 3 tiles","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there exists any ship on the true_board whose length\n    (i.e., the number of connected tiles of that ship ID) is greater than 3.\n    Ships are encoded as positive integers 1\u20134. Water is 0 and hidden is -1.\n    \"\"\"\n    # Find all unique ship IDs on the board (ignore water=0 and hidden=-1)\n    ship_ids = np.unique(true_board)\n    # Check each ship ID to see if its total tile count exceeds 3\n    for ship_id in ship_ids:\n        if ship_id > 0:  # skip water and any hidden markers\n            if np.sum(true_board == ship_id) > 3:\n                return True\n    return False\n","name":"program_0","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a horizantal ship on G or H","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # rows G and H correspond to indices 6 and 7\n    rows_to_check = [6, 7]\n    ncols = true_board.shape[1]\n    \n    for r in rows_to_check:\n        # scan for any horizontal adjacency of the same ship\u2010id\n        for c in range(ncols - 1):\n            ship_id = true_board[r, c]\n            if ship_id > 0 and true_board[r, c+1] == ship_id:\n                # we've found a ship laying horizontally at (r,c) and (r,c+1)\n                # now gather all columns in row r that belong to this same ship\n                ship_cols = np.where(true_board[r] == ship_id)[0]\n                # if any of those columns are still hidden, answer yes\n                if np.any(partial_board[r, ship_cols] == -1):\n                    return True\n    # no horizontal ship on G or H with at least one hidden tile\n    return False\n","name":"program_1","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the a horizantal dhip after G5 OR H5","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any ship tile in row G or H strictly to the right\n    of column 5 (i.e., in columns 6, 7, or 8). Otherwise returns False.\n    \"\"\"\n    # define the queried positions\n    queries = [\"G5\", \"H5\"]\n    \n    for q in queries:\n        # parse row letter and column number\n        row_letter = q[0]\n        col_number = int(q[1:])\n        # convert to 0-based indices\n        row_idx = ord(row_letter) - ord('A')\n        col_idx = col_number - 1\n        \n        # slice the row to the right of the queried column\n        right_slice = true_board[row_idx, col_idx+1:]\n        # if any ship tile (> 0) exists in that slice, answer is True\n        if np.any(right_slice > 0):\n            return True\n    \n    # if neither row G nor row H has any ship tiles to the right of col 5\n    return False\n","name":"program_2","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the final ship below G","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify ship types (1=Red, 2=Green, 3=Purple, 4=Orange)\n    ship_types = [s for s in np.unique(true_board) if s > 0]\n    \n    # Find which ship is not yet fully revealed (the \"final\" ship)\n    remaining_ship = None\n    for s in ship_types:\n        # all positions of this ship on true_board\n        positions = np.argwhere(true_board == s)\n        # check if any of these positions are still hidden in partial_board\n        still_hidden = [\n            (r, c)\n            for r, c in positions\n            if partial_board[r, c] == -1\n        ]\n        if still_hidden:\n            # this ship has at least one unrevealed tile\n            remaining_ship = positions\n            break\n    \n    if remaining_ship is None:\n        # no remaining ship found (edge case)\n        return False\n    \n    # Map row letter 'G' to its 0-based index: 'A'->0, ..., 'G'->6\n    row_G_index = ord('G') - ord('A')\n    \n    # \"Below G\" means a row index strictly greater than row_G_index\n    return np.any(remaining_ship[:, 0] > row_G_index)\n","name":"program_3","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it above c","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether any part of the remaining (unrevealed) ship(s) lies in rows above row 'C'\n    (i.e., in rows 'A' or 'B').\n\n    We identify the unrevealed ship squares by looking for positions where true_board>0\n    but partial_board is still hidden (-1).  We then map numpy row\u2010indices 0\u2192'A', 1\u2192'B', 2\u2192'C', \u2026\n    and test if any of those unrevealed ship\u2010cells have index < 2.\n    \"\"\"\n    # mask of all unrevealed ship cells\n    unrevealed = (true_board > 0) & (partial_board == -1)\n    # if there are no unrevealed ship cells, answer is False\n    if not np.any(unrevealed):\n        return False\n\n    # get the row indices of those cells\n    rows, _ = np.where(unrevealed)\n    # row 'C' corresponds to index 2; \"above C\" means index < 2\n    return np.any(rows < 2)\n","name":"program_4","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is green ship fully sunk","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if every tile of the green ship (value==2 in true_board)\n    has been revealed (value==2 in partial_board). Otherwise return False.\n    \"\"\"\n    # Mask of where the green ship is on the true board\n    green_mask = (true_board == 2)\n    # Check that every green ship cell appears as a hit (2) in the partial board\n    return np.all(partial_board[green_mask] == 2)\n","name":"program_5","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there now 2 ships that are fully sunk","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all ship IDs on the true board (positive integers)\n    ship_ids = np.unique(true_board)\n    ship_ids = ship_ids[ship_ids > 0]\n\n    sunk_count = 0\n    for sid in ship_ids:\n        # total tiles of this ship on the true board\n        total_tiles = np.count_nonzero(true_board == sid)\n        # tiles of this ship already revealed on the partial board\n        revealed_tiles = np.count_nonzero(partial_board == sid)\n        # if all of them are revealed, the ship is sunk\n        if revealed_tiles == total_tiles:\n            sunk_count += 1\n\n    # Return True if at least two ships are fully sunk\n    return sunk_count >= 2\n","name":"program_6","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it below e","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A ship tile is unrevealed if true_board>0 but partial_board==-1 there\n    unrevealed = (true_board > 0) & (partial_board == -1)\n    # Row indices of all unrevealed ship tiles\n    rows, cols = np.nonzero(unrevealed)\n    # Row \"E\" is index 4 (0\u2192A, 1\u2192B, \u2026, 4\u2192E).  Test if any tile is below it.\n    return bool(np.any(rows > 4))\n","name":"program_7","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship at most 1 tile away from E7","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We interpret \"at most 1 tile away\" as direct (Manhattan) adjacency.\n    # The question refers to cell E7.\n    # Map row 'E' to index 4, column 7 to index 6.\n    row_idx = ord('E') - ord('A')\n    col_idx = 7 - 1\n\n    # Directions for Manhattan distance = 1 (up, down, left, right)\n    neighbors = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    h, w = true_board.shape\n\n    for dr, dc in neighbors:\n        r = row_idx + dr\n        c = col_idx + dc\n        if 0 <= r < h and 0 <= c < w:\n            # true_board > 0 indicates there is a ship segment here\n            # partial_board == -1 means that segment is still hidden\n            if true_board[r, c] > 0 and partial_board[r, c] == -1:\n                return True\n    return False\n","name":"program_8","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship to the left of green","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the green ship (encoded as 2)\n    green_rows, green_cols = np.where(true_board == 2)\n    \n    # For each green\u2010ship coordinate, check the tile immediately to its left\n    for r, c in zip(green_rows, green_cols):\n        if c - 1 >= 0:\n            # If that tile is part of some ship (true_board > 0)\n            # and still hidden on the partial board (partial_board == -1),\n            # then there is a ship to the left of green.\n            if true_board[r, c - 1] > 0 and partial_board[r, c - 1] == -1:\n                return True\n    \n    # If no adjacent\u2010left tile of green contains an unrevealed ship, answer No\n    return False\n","name":"program_9","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship below F3","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to check the tile immediately below F3, i.e. G3.\n    # Map row letter 'F' to index 5 (0-based), column 3 to index 2.\n    row_idx = ord('F') - ord('A')   # 'F' -> 5\n    col_idx = 3 - 1                 # 3 -> 2\n    below_row = row_idx + 1        # row index for 'G'\n    # If 'below' goes off the board, there can't be a ship there.\n    if below_row >= true_board.shape[0]:\n        return False\n    # Return True if the true board has a ship (>0) at G3.\n    return bool(true_board[below_row, col_idx] > 0)\n","name":"program_10","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship after d5 and before column 5?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Captain asked: \"Is there a ship after d5 and before column 5?\"\n    Interpreting \"after d5\" as any row > D (i.e. rows E\u2013H) \n    and \"before column 5\" as columns 1\u20134.\n    We return True if there is any unrevealed ship cell in that region.\n    \"\"\"\n    # Row index of 'D' is 3 (A=0, B=1, C=2, D=3)\n    # Column index of '5' is 4 (1\u21920, 2\u21921, \u2026, 5\u21924)\n    \n    # Build a mask for the region: rows > 3 (E\u2013H), cols < 4 (1\u20134)\n    n_rows, n_cols = true_board.shape\n    row_idx = np.arange(n_rows)[:, None]   # shape (n_rows, 1)\n    col_idx = np.arange(n_cols)[None, :]   # shape (1, n_cols)\n    region_mask = (row_idx > 3) & (col_idx < 4)\n    \n    # Mask of unrevealed ship cells\n    # Ship cells in true_board are > 0, and still hidden in partial_board == -1\n    unrevealed_ship_mask = (true_board > 0) & (partial_board == -1)\n    \n    # If any such cell lies in our region, answer is True\n    return bool(np.any(region_mask & unrevealed_ship_mask))\n","name":"program_11","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it after F?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Compute the index of row 'F' (A\u21920, B\u21921, \u2026, H\u21927)\n    f_index = ord('F') - ord('A')\n    # Consider all rows strictly after 'F'\n    rows_after_f = slice(f_index + 1, None)  # this will pick rows 6 and 7 (G and H)\n    \n    # Extract the corresponding subboards\n    true_sub = true_board[rows_after_f, :]\n    partial_sub = partial_board[rows_after_f, :]\n    \n    # A concealed ship tile is where true_board > 0 (a ship)\n    # but partial_board == -1 (still hidden)\n    concealed_ship_tiles = (true_sub > 0) & (partial_sub == -1)\n    \n    # If any such tile exists in rows G or H, answer \"Yes\"\n    return bool(np.any(concealed_ship_tiles))\n","name":"program_12","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it on row G?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row G corresponds to index 6 (0-based)\n    row = 6\n    # A ship tile is > 0. An unrevealed tile in partial_board is -1.\n    # We want to know if there's any unrevealed ship tile in row G.\n    unrevealed = (partial_board[row, :] == -1)\n    ship_tiles = (true_board[row, :] > 0)\n    # If both are true at any position, there's an unrevealed ship on row G\n    return bool(np.any(unrevealed & ship_tiles))\n","name":"program_13","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there one on row d?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'D' to its zero\u2010based index (A\u21920, B\u21921, \u2026, D\u21923)\n    row_idx = ord('D') - ord('A')\n    # A hidden ship tile is one where true_board > 0 (there is a ship)\n    # and partial_board == -1 (it is still unrevealed).\n    hidden_ship_in_row = (true_board[row_idx, :] > 0) & (partial_board[row_idx, :] == -1)\n    return bool(np.any(hidden_ship_in_row))\n","name":"program_14","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it between columns 1 and 3 but below row E?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We interpret \"below row E\" as rows F, G, H (zero-based indices 5, 6, 7)\n    # and \"between columns 1 and 3\" as columns 1, 2, 3 (zero-based indices 0, 1, 2).\n    # We check whether there is any ship tile (true_board > 0) in that region\n    # that is still hidden on the captain's view (partial_board == -1).\n    \n    # Define the region mask\n    region_mask = np.zeros_like(true_board, dtype=bool)\n    region_mask[5:, 0:3] = True\n    \n    # Mask of unrevealed ship tiles\n    unrevealed_ship = (true_board > 0) & (partial_board == -1)\n    \n    # If any such tile lies in the region, answer is True, otherwise False\n    return bool(np.any(region_mask & unrevealed_ship))\n","name":"program_15","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it in column 8 above G?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Column 8 corresponds to index 7.\n    # \"Above G\" means rows A\u2013F, i.e. indices 0\u20135.\n    col_idx = 7\n    # Build a mask of hidden cells in column 8, rows 0\u20135,\n    # that actually contain a ship in the true board.\n    hidden_ship_mask = (partial_board[:6, col_idx] == -1) & (true_board[:6, col_idx] > 0)\n    # If any of those positions is True, then there is an unrevealed ship there.\n    return bool(np.any(hidden_ship_mask))\n","name":"program_16","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is therer one on row C","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the zero\u2010based index for row 'C'\n    row_index = ord('C') - ord('A')\n    # Extract the true and partial rows\n    true_row = true_board[row_index]\n    partial_row = partial_board[row_index]\n    # Check if there is any ship tile in the true row that is still hidden in the partial row\n    hidden_ship_mask = (true_row > 0) & (partial_row == -1)\n    return bool(np.any(hidden_ship_mask))\n","name":"program_17","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it after 4","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship\u2010occupied tile\n    in a column after column 4 (i.e. columns 5\u20138), otherwise False.\n    \"\"\"\n    # 1) Find all unrevealed positions:\n    hidden = (partial_board == -1)\n    # 2) Restrict to actual ship tiles on the true board:\n    ship_tiles = (true_board > 0)\n    # 3) Create a column mask for columns 5\u20138 (0\u2010based indices 4\u20137):\n    cols = np.arange(true_board.shape[1])\n    after_four = (cols >= 4)  # True for col indices 4,5,6,7\n    # 4) Broadcast the column mask to full board shape:\n    after_four_mask = after_four[np.newaxis, :]\n    # 5) Combine all masks:\n    target_mask = hidden & ship_tiles & after_four_mask\n    # 6) If any such tile exists, answer is True (Yes), else False (No)\n    return bool(np.any(target_mask))\n","name":"program_18","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there 2 ships that are touching each other","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if any two distinct ships on the true_board are touching\n    (orthogonally or diagonally), otherwise False.\n    \"\"\"\n    # Define the 8 possible neighbor offsets\n    neighbors = [(-1, -1), (-1, 0), (-1, 1),\n                 ( 0, -1),          ( 0, 1),\n                 ( 1, -1), ( 1, 0), ( 1, 1)]\n    \n    rows, cols = true_board.shape\n    for r in range(rows):\n        for c in range(cols):\n            ship_id = true_board[r, c]\n            # Skip water or hidden\n            if ship_id <= 0:\n                continue\n            # Check all neighbors\n            for dr, dc in neighbors:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    neighbor_id = true_board[nr, nc]\n                    # If there's a different ship touching\n                    if neighbor_id > 0 and neighbor_id != ship_id:\n                        return True\n    return False\n","name":"program_19","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"split the board in 4 with quadrants 1-4 is it in 1 or 2","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the midpoint to split rows and columns into two halves\n    n_rows, n_cols = true_board.shape\n    mid_row = n_rows \/\/ 2\n    mid_col = n_cols \/\/ 2\n\n    # Quadrant 1: top-left (rows 0 to mid_row-1, cols 0 to mid_col-1)\n    q1_true = true_board[:mid_row, :mid_col]\n    q1_part = partial_board[:mid_row, :mid_col]\n\n    # Quadrant 2: top-right (rows 0 to mid_row-1, cols mid_col to end)\n    q2_true = true_board[:mid_row, mid_col:]\n    q2_part = partial_board[:mid_row, mid_col:]\n\n    # A hidden ship tile is one where true_board > 0 (ship) and partial_board == -1 (hidden)\n    q1_has_hidden_ship = np.any((q1_true > 0) & (q1_part == -1))\n    q2_has_hidden_ship = np.any((q2_true > 0) & (q2_part == -1))\n\n    # Return True if there is any hidden ship tile in quadrant 1 or 2\n    return bool(q1_has_hidden_ship or q2_has_hidden_ship)\n","name":"program_20","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it in column 3","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Column 3 corresponds to index 2 (0-based indexing)\n    col_index = 2\n\n    # Identify ship tiles in column 3 on the true board\n    ship_mask = true_board[:, col_index] > 0\n\n    # Identify which of those tiles are still hidden on the partial board\n    hidden_mask = partial_board[:, col_index] == -1\n\n    # If there's any tile that is both a ship and still hidden, answer \"Yes\"\n    return bool(np.any(ship_mask & hidden_mask))\n","name":"program_21","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it in 1","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in quadrant 1.\n    Quadrant 1 is defined as the top\u2010left quarter of the board:\n    rows 0..(n_rows\/2\u22121) and columns 0..(n_cols\/2\u22121).\n    \"\"\"\n    n_rows, n_cols = true_board.shape\n    half_rows = n_rows \/\/ 2\n    half_cols = n_cols \/\/ 2\n\n    # Extract quadrant 1\n    true_q1 = true_board[:half_rows, :half_cols]\n    partial_q1 = partial_board[:half_rows, :half_cols]\n\n    # A ship tile is unrevealed if true_board>0 but partial_board==-1\n    unrevealed_ship_in_q1 = np.any((true_q1 > 0) & (partial_q1 == -1))\n    return bool(unrevealed_ship_in_q1)\n","name":"program_22","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the a ship above e but before 4","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We interpret \"above E\" as rows A\u2013D, and \"before 4\" as columns 1\u20133.\n    # Row 'E' is index 4 (0-based), so rows above it are indices 0\u20133.\n    # Column '4' is index 3, so columns before it are indices 0\u20132.\n    row_limit = ord('E') - ord('A')    # = 4\n    col_limit = 4 - 1                  # = 3\n\n    # Extract the region of interest\n    true_region = true_board[:row_limit, :col_limit]\n    partial_region = partial_board[:row_limit, :col_limit]\n\n    # A ship is present if there's any tile > 0 in true_board\n    # that remains hidden (== -1) in partial_board.\n    mask_unrevealed = (partial_region == -1)\n    mask_ship       = (true_region > 0)\n\n    # If there's any position where both masks are True, answer is Yes.\n    return bool(np.any(mask_unrevealed & mask_ship))\n","name":"program_23","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it vertical","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine if the one remaining (partially hidden) ship is oriented vertically.\n\n    We identify each ship by its numeric label in true_board (1\u20134).  For each ship:\n    - Gather its full coordinates from true_board.\n    - Check if any of those coordinates are still hidden on partial_board.\n    - If so, that is the ship of interest.\n    - Finally, test whether all of its column indices are the same (vertical)\n      or all of its row indices are the same (horizontal).\n    \"\"\"\n    # All positive labels correspond to ships\n    ship_labels = np.unique(true_board)\n    ship_labels = ship_labels[(ship_labels > 0)]\n    \n    for label in ship_labels:\n        # Find all positions of this ship on the true board\n        coords = np.argwhere(true_board == label)  # shape (n_cells, 2)\n        \n        # Check if any of those positions remain hidden in the partial board\n        still_hidden = any(partial_board[tuple(pos)] == -1 for pos in coords)\n        if not still_hidden:\n            # This ship is fully revealed; skip it\n            continue\n        \n        # This is the ship we're being asked about\n        rows = coords[:, 0]\n        cols = coords[:, 1]\n        \n        # If all columns are the same, it's vertical; otherwise horizontal\n        return bool(np.all(cols == cols[0]))\n    \n    # If we find no partially hidden ships, default to False\n    return False\n","name":"program_24","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it on c","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in row C,\n    otherwise False.\n    \"\"\"\n    # Compute a mask of all unrevealed ship tiles\n    unrevealed = (true_board > 0) & (partial_board == -1)\n    # Row C corresponds to index 2 (A=0, B=1, C=2)\n    return bool(np.any(unrevealed[2, :]))\n","name":"program_25","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship on or below f","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one ship tile on or below row F\n    that remains hidden (i.e., true_board > 0 and partial_board == -1),\n    otherwise returns False.\n    \"\"\"\n    # Rows on or below 'F' correspond to indices 5, 6, 7\n    sub_true = true_board[5:]\n    sub_partial = partial_board[5:]\n    # Check for any ship (>0) that is still hidden (-1)\n    return bool(np.any((sub_true > 0) & (sub_partial == -1)))\n","name":"program_26","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"A?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in row A (row index 0).\n    \"\"\"\n    row_index = 0  # Row A corresponds to index 0\n    # A tile is an unrevealed ship if it's hidden in partial_board and >0 in true_board\n    hidden_ship_mask = (partial_board[row_index] == -1) & (true_board[row_index] > 0)\n    return bool(np.any(hidden_ship_mask))\n","name":"program_27","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is one on or below e","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # mask of unrevealed ship tiles\n    unrevealed_ship = (true_board > 0) & (partial_board == -1)\n    # check rows E\u2013H (index 4 through 7)\n    return bool(unrevealed_ship[4:, :].any())\n","name":"program_28","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it afte r4","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all still-hidden ship cells:\n    hidden_ship = (true_board > 0) & (partial_board == -1)\n    # Build an array of column indices, shape (1, ncols), values 0..ncols-1\n    cols = np.arange(true_board.shape[1])[None, :]\n    # Check if any hidden ship lies in a column after column 4 (i.e. index >= 4)\n    after4 = cols >= 4\n    return bool(np.any(hidden_ship & after4))\n","name":"program_29","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there one is c","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We're interpreting \"Is there one in C?\" as\n    # \"Is there any unrevealed ship tile in row C?\"\n    row_idx = ord('C') - ord('A')   # 0-based index for row C\n    # A ship tile in true_board is > 0; a hidden tile in partial_board is -1\n    mask_ship    = true_board[row_idx, :] > 0\n    mask_hidden  = partial_board[row_idx, :] == -1\n    return bool(np.any(mask_ship & mask_hidden))\n","name":"program_30","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship located above the green ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the green ship (value == 2)\n    green_cells = np.argwhere(true_board == 2)\n    for i, j in green_cells:\n        # look at the cell directly above (row index i-1)\n        if i > 0:\n            # is there a ship part there?\n            if true_board[i-1, j] > 0:\n                # only count it if it's still hidden to the captain\n                if partial_board[i-1, j] == -1:\n                    return True\n    return False\n","name":"program_31","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it on or before c6 or d6?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines whether there is any unrevealed ship tile in rows A\u2013D and columns 1\u20136,\n    i.e. on or before C6 or D6 (regions up to row D, column 6).\n    \"\"\"\n    # Rows A\u2013D correspond to indices 0\u20133, columns 1\u20136 correspond to indices 0\u20135\n    region_mask = np.zeros_like(true_board, dtype=bool)\n    region_mask[:4, :6] = True\n\n    # A ship tile is true_board > 0; unrevealed means partial_board == -1\n    hidden_ships_in_region = (true_board > 0) & (partial_board == -1) & region_mask\n\n    return bool(np.any(hidden_ships_in_region))\n","name":"program_32","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the green ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the green ship (value == 2)\n    green_coords = np.argwhere(true_board == 2)\n    \n    # If there are fewer than 2 tiles, it's not a valid (length>=2) ship,\n    # so we treat it as not vertical.\n    if green_coords.shape[0] < 2:\n        return False\n    \n    # Extract the column indices of those tiles\n    cols = green_coords[:, 1]\n    \n    # If all column indices are the same, the ship is placed vertically\n    return np.all(cols == cols[0])\n","name":"program_33","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the longest ship vertical","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the longest ship on the true_board is vertically oriented.\n    If there are multiple ships tied for longest, returns True only if all of them\n    are vertical.\n    \"\"\"\n    # Find all ship IDs (exclude 0=water and -1=hidden)\n    ship_ids = np.unique(true_board)\n    ship_ids = ship_ids[(ship_ids > 0)]\n\n    max_length = 0\n    # Map ship_id -> (length, orientation)\n    # orientation is 'vertical' or 'horizontal'\n    info = {}\n    for sid in ship_ids:\n        coords = np.argwhere(true_board == sid)\n        length = coords.shape[0]\n        max_length = max(max_length, length)\n\n        rows = coords[:, 0]\n        cols = coords[:, 1]\n        if np.all(cols == cols[0]):\n            orientation = 'vertical'\n        elif np.all(rows == rows[0]):\n            orientation = 'horizontal'\n        else:\n            # Ships should be straight, but handle any weird case\n            orientation = 'unknown'\n\n        info[sid] = (length, orientation)\n\n    # Check all ships with the maximal length\n    for length, orientation in info.values():\n        if length == max_length and orientation != 'vertical':\n            return False\n\n    return True\n","name":"program_34","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is ther a ship above e but after 5","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We interpret \"above E\" as rows A\u2013D (indices 0\u20133)\n    # and \"after 5\" as columns 6\u20138 (indices 5\u20137).\n    # Find any hidden ship tile in that region.\n    \n    # rows 0\u20133\n    row_mask = np.arange(true_board.shape[0]) < 4\n    # cols 5\u20137\n    col_mask = np.arange(true_board.shape[1]) > 4\n    \n    # build a mask for the region\n    region_mask = np.outer(row_mask, col_mask)\n    \n    # ship tiles in the true board\n    ship_mask = true_board > 0\n    # hidden tiles in the partial board\n    hidden_mask = partial_board == -1\n    \n    # if there exists any tile that is in the region, is a ship, and is hidden\n    return bool(np.any(region_mask & ship_mask & hidden_mask))\n","name":"program_35","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is on row 246 or 8","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed ship tile on row 2, 4, 6, or 8\n    (i.e. rows B, D, F, H in 1-based lettered notation), otherwise False.\n    \"\"\"\n    # 0-based row indices corresponding to rows 2,4,6,8 are 1,3,5,7\n    target_rows = [1, 3, 5, 7]\n\n    # Build a mask for those rows\n    row_mask = np.zeros_like(true_board, dtype=bool)\n    row_mask[target_rows, :] = True\n\n    # Mask of ship locations in the true board\n    ship_mask = (true_board > 0)\n\n    # Mask of unrevealed tiles in the partial board\n    unrevealed_mask = (partial_board == -1)\n\n    # Check if any tile satisfies all three conditions\n    return bool(np.any(row_mask & ship_mask & unrevealed_mask))\n","name":"program_36","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it on c","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row C corresponds to index 2 (0-based indexing: A=0, B=1, C=2)\n    # We want to know if there is any ship tile (true_board > 0)\n    # on row C that is still hidden (partial_board == -1).\n    row_index = 2\n    # Create a mask for hidden ship tiles in row C\n    hidden_ship_mask = (true_board[row_index, :] > 0) & (partial_board[row_index, :] == -1)\n    return bool(np.any(hidden_ship_mask))\n","name":"program_37","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there one below e but after 5 if it is on e or 5 then say no","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any *unrevealed* ship tile strictly below row E\n    (i.e. rows F, G, H) and strictly after column 5 (i.e. columns 6, 7, 8).\n    If a ship tile lies on row E or on column 5, it is excluded by the question.\n    \"\"\"\n    # Determine which rows are strictly below E (E is index 4 in 0-based)\n    rows_below_E = np.arange(true_board.shape[0]) > 4\n    # Determine which columns are strictly after 5 (5 is index 4 in 0-based)\n    cols_after_5 = np.arange(true_board.shape[1]) > 5\n    \n    # Build a 2D mask for the region of interest\n    region_mask = np.outer(rows_below_E, cols_after_5)  # shape (8,8)\n    \n    # A tile counts if:\n    #  1) true_board > 0 (there is a ship there),\n    #  2) partial_board == -1 (it is still hidden),\n    #  3) region_mask is True (in rows F-H and columns 6-8).\n    hidden_ship_tiles_in_region = (\n        (true_board > 0) &\n        (partial_board == -1) &\n        region_mask\n    )\n    \n    # If any such tile exists, answer is Yes (True); otherwise, No (False).\n    return bool(np.any(hidden_ship_tiles_in_region))\n","name":"program_38","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it above c but before or on 5","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We're checking for any unrevealed ship tile in rows above 'C' (i.e. rows A or B)\n    # and in columns 1 through 5 inclusive.\n    # Row 'C' has index 2 (0-based: A=0, B=1, C=2), so \"above C\" means row indices <2.\n    # Column 5 has index 4 in 0-based indexing.\n    \n    # 1) Identify all unrevealed ship cells:\n    #    - partial_board == -1 => hidden\n    #    - true_board > 0      => ship present\n    unrevealed = (partial_board == -1) & (true_board > 0)\n    \n    # 2) Build a mask for the region \"above C\" and \"col \u2264 5\"\n    row_limit = ord('c') - ord('a')      # 2\n    col_limit = 5 - 1                    # 4\n    region_mask = np.zeros_like(unrevealed, dtype=bool)\n    region_mask[:row_limit, :col_limit + 1] = True\n    \n    # 3) If any unrevealed ship tile lies in that region, answer is True\n    return bool(np.any(unrevealed & region_mask))\n","name":"program_39","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"So there is a ship on a or b but before 5","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows A and B correspond to indices 0 and 1.\n    # \"Before 5\" means columns 1\u20134, which are indices 0\u20133.\n    # We look for any unrevealed ship tile (value > 0 in true_board \n    # and -1 in partial_board) in that subgrid.\n    sub_true = true_board[0:2, 0:4]\n    sub_partial = partial_board[0:2, 0:4]\n    # Check if any position is a ship (>0) and still hidden (-1)\n    return bool(((sub_true > 0) & (sub_partial == -1)).any())\n","name":"program_40","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is on on e or c","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed ship tile in row C or row E,\n    given the full true_board and the current partial_board view.\n    Row indices: A=0, B=1, C=2, D=3, E=4, ...\n    An unrevealed ship tile is one where partial_board == -1 and true_board > 0.\n    \"\"\"\n    # Create a mask of unrevealed ship tiles\n    unrevealed_ship = (partial_board == -1) & (true_board > 0)\n\n    # Check rows C (index 2) and E (index 4)\n    return bool(np.any(unrevealed_ship[2]) or np.any(unrevealed_ship[4]))\n","name":"program_41","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is orange vertical","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the Orange ship (marked with 4)\n    orange_positions = np.argwhere(true_board == 4)\n    # Extract the column indices of those positions\n    cols = orange_positions[:, 1]\n    # If all columns are the same, the ship is vertical\n    return np.all(cols == cols[0])\n","name":"program_42","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is one on f before 5","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the index for row 'F' (rows A\u2013H map to indices 0\u20137)\n    row_idx = ord('f') - ord('a')\n    # Columns \"before 5\" means columns 1 through 4, i.e. indices 0 through 3\n    # We're looking for any ship tile (> 0) there that is still hidden (-1)\n    region_true   = true_board[row_idx, :5]    # indices 0\u20134, but the 5th (index 4) is column 5\n    region_partial = partial_board[row_idx, :5]\n    # We only want columns strictly before 5, so ignore index 4:\n    region_true   = region_true[:4]\n    region_partial = region_partial[:4]\n    # Check if any of those spots is a ship in the true board and still hidden in the partial\n    hidden_ship_tiles = (region_true > 0) & (region_partial == -1)\n    return bool(np.any(hidden_ship_tiles))\n","name":"program_43","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is one on f after 5 or on g","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile either\n    on row F after column 5 (i.e., columns 6, 7, 8) or anywhere on row G.\n    Otherwise returns False.\n    \"\"\"\n    # Row indices: A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7\n    row_F = 5\n    row_G = 6\n\n    # Check F6, F7, F8\n    f_slice = true_board[row_F, 6:] > 0\n    f_unrevealed = partial_board[row_F, 6:] == -1\n\n    # Check all of row G\n    g_slice = true_board[row_G, :] > 0\n    g_unrevealed = partial_board[row_G, :] == -1\n\n    # If any of those positions contain a ship in the true_board\n    # and remain hidden in the partial_board, answer is True.\n    return bool(np.any(f_slice & f_unrevealed) or np.any(g_slice & g_unrevealed))\n","name":"program_44","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"it is on h","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row \"H\" to its 0-based index (A->0, B->1, ..., H->7)\n    row_idx = ord('H') - ord('A')\n    # A ship tile in the true board is > 0; an unrevealed tile in the partial board is -1\n    # We want to know if there's any ship tile on row H that is still hidden.\n    return np.any((true_board[row_idx] > 0) & (partial_board[row_idx] == -1))\n","name":"program_45","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is  ther a ship on or above d","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile on or above row D\n    (i.e., rows A, B, C, or D). Otherwise returns False.\n    \"\"\"\n    # Rows A, B, C, D correspond to indices 0, 1, 2, 3.\n    # Create a mask for those rows:\n    rows_mask = np.zeros_like(true_board, dtype=bool)\n    rows_mask[0:4, :] = True\n\n    # Mask for ship tiles in the true board:\n    ship_mask = (true_board > 0)\n    # Mask for tiles that are still hidden on the partial board:\n    hidden_mask = (partial_board == -1)\n\n    # If there exists any tile that is (a) on or above row D, (b) a ship in true_board,\n    # and (c) still hidden, then the answer is True.\n    return bool(np.any(rows_mask & ship_mask & hidden_mask))\n","name":"program_46","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it Directly below orange","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is any ship tile immediately below the Orange ship.\n    Orange ship tiles are marked with 4 in true_board.\n    \"\"\"\n    # find all the coordinates of the orange ship\n    orange_coords = np.argwhere(true_board == 4)\n    if orange_coords.size == 0:\n        # no orange ship found\n        return False\n\n    # determine orientation\n    rows = orange_coords[:, 0]\n    cols = orange_coords[:, 1]\n    n_rows, n_cols = true_board.shape\n\n    # if all orange tiles share the same row, it's horizontal\n    if np.all(rows == rows[0]):\n        r = rows[0]\n        # check each column under the orange ship\n        for c in cols:\n            below = r + 1\n            if below < n_rows and true_board[below, c] > 0:\n                return True\n        return False\n\n    # otherwise the orange ship is vertical\n    # find its bottommost tile\n    bottom_row = rows.max()\n    col = cols[0]  # all cols are the same in vertical orientation\n    below = bottom_row + 1\n    if below < n_rows and true_board[below, col] > 0:\n        return True\n\n    return False\n","name":"program_47","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it on row E?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row 'E' to zero\u2010based index 4\n    row_idx = ord('E') - ord('A')\n    # A ship tile is indicated by > 0 in true_board\n    # A hidden tile is indicated by -1 in partial_board\n    # We ask: is there any ship on row E that remains unrevealed?\n    hidden_ships_in_E = (true_board[row_idx, :] > 0) & (partial_board[row_idx, :] == -1)\n    return bool(np.any(hidden_ships_in_E))\n","name":"program_48","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"This goign to be crazy tough....  Is there a ship on evens?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile on any even-numbered column.\n    Columns are 1-indexed for the Captain, so we look at 0-based indices 1, 3, 5, 7.\n    \"\"\"\n    # Extract the subarrays corresponding to even-numbered columns (2,4,6,8 in 1-based indexing)\n    true_even_cols = true_board[:, 1::2]\n    partial_even_cols = partial_board[:, 1::2]\n\n    # A ship tile is indicated by true_board > 0; unrevealed by partial_board == -1\n    unrevealed_ships_in_evens = (true_even_cols > 0) & (partial_even_cols == -1)\n    \n    # If any such tile exists, answer Yes (True), otherwise No (False)\n    return bool(np.any(unrevealed_ships_in_evens))\n","name":"program_49","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it on row G?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row 'G' to index 6 (0-based indexing: A=0, B=1, \u2026, G=6)\n    row_idx = ord('G') - ord('A')\n    # A hidden ship tile is one where true_board > 0 and partial_board == -1\n    hidden_ships_in_G = (true_board[row_idx, :] > 0) & (partial_board[row_idx, :] == -1)\n    return bool(np.any(hidden_ships_in_G))\n","name":"program_50","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are any ships directly below the orange and green ships meaning any part of them directly under?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there exists any ship tile (of a different ship)\n    directly below any tile of the orange (4) or green (2) ships.\n    \"\"\"\n    n_rows, n_cols = true_board.shape\n\n    # Check for both green (2) and orange (4)\n    for ship_id in (2, 4):\n        # Find all the coordinates occupied by this ship\n        ship_rows, ship_cols = np.where(true_board == ship_id)\n        for r, c in zip(ship_rows, ship_cols):\n            # look one row below\n            if r + 1 < n_rows:\n                below_id = true_board[r + 1, c]\n                # if there's a ship tile there AND it's not the same ship\n                if below_id > 0 and below_id != ship_id:\n                    return True\n\n    return False\n","name":"program_51","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the one remaining ship (the only ship with at least one hidden tile)\n    is placed horizontally on the board.\n\n    Args:\n        true_board (np.ndarray): The full board with ships labeled 1\u20134 and water as 0.\n        partial_board (np.ndarray): The captain's view, with hidden tiles as \u20131, water as 0,\n                                    and revealed ship segments with their ship IDs.\n\n    Returns:\n        bool: True if that remaining ship is horizontal, False otherwise.\n    \"\"\"\n    # All ship IDs present on the true board (exclude water = 0)\n    ship_ids = set(np.unique(true_board)) - {0}\n\n    for ship_id in ship_ids:\n        # Build a mask for where this ship lives on the true board\n        ship_mask = (true_board == ship_id)\n        # If any of that ship's tiles are still hidden in partial_board, this is our target ship\n        if np.any(ship_mask & (partial_board == -1)):\n            # Find all coordinates (row, col) of this ship\n            coords = np.argwhere(ship_mask)\n            # If all row indices are the same \u21d2 horizontal\n            if np.all(coords[:, 0] == coords[0, 0]):\n                return True\n            else:\n                # Otherwise it's vertical\n                return False\n\n    # If we didn't find any partially hidden ship, default to False\n    return False\n","name":"program_52","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships directly to the left of the two known ships","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify the two known ships (orange=4 and green=2) on the partial board\n    known_mask = (partial_board == 2) | (partial_board == 4)\n    # Get their coordinates\n    rows, cols = np.where(known_mask)\n    # Determine which ship\u2010IDs are already known so we don't count adjacency to them\n    known_ids = set(np.unique(partial_board[known_mask]))\n    \n    # For each revealed segment of orange or green, check the tile immediately to its left\n    for r, c in zip(rows, cols):\n        if c == 0:\n            continue  # no tile to the left\n        left_id = true_board[r, c - 1]\n        # If that tile is part of a ship (nonzero) and not one of the known ships, report True\n        if left_id != 0 and left_id not in known_ids:\n            return True\n    \n    # No unknown ship tile was found directly to the left of any green\/orange segment\n    return False\n","name":"program_53","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is orange vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the orange ship (encoded as 4) is placed vertically\n    on the true_board, False otherwise.\n    \"\"\"\n    # Find all coordinates of the orange ship\n    coords = np.argwhere(true_board == 4)\n    \n    # If no orange ship tiles are found, we cannot say it's vertical\n    if coords.size == 0:\n        return False\n    \n    # coords is an array of shape (ship_length, 2) where each row is (row_index, col_index)\n    # Extract the column indices of the orange ship tiles\n    cols = coords[:, 1]\n    \n    # If all column indices are the same, the ship is vertical\n    return np.all(cols == cols[0])\n","name":"program_54","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it on column 8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify which ship still has unrevealed tiles\n    for ship_id in [1, 2, 3, 4]:\n        total_tiles = np.count_nonzero(true_board == ship_id)\n        revealed_tiles = np.count_nonzero(partial_board == ship_id)\n        if revealed_tiles < total_tiles:\n            # Get all the coordinates of that ship on the true board\n            coords = np.argwhere(true_board == ship_id)\n            # Check if any part of that ship lies in column 8 (index 7)\n            return np.any(coords[:, 1] == 7)\n    # If no ship is partially hidden, answer False\n    return False\n","name":"program_55","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it on column 6?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify all ship\u2010colors on the true board (exclude water\/0)\n    ship_colors = set(np.unique(true_board)) - {0}\n\n    # Identify which colors have already been discovered on the partial board\n    # (exclude water\/0 and hidden\/-1)\n    discovered_colors = set(np.unique(partial_board)) - {0, -1}\n\n    # The \u201clast ship\u201d is the one color not yet discovered\n    remaining_colors = ship_colors - discovered_colors\n    # In normal play there should be exactly one remaining color\n    if len(remaining_colors) == 1:\n        target_color = remaining_colors.pop()\n    else:\n        # Fallback: just pick one if something unexpected happened\n        target_color = next(iter(remaining_colors))\n\n    # Find all coordinates of that ship on the true board\n    # np.argwhere returns a list of [row, col] pairs\n    coords = np.argwhere(true_board == target_color)\n\n    # We interpret \u201cIs it on column 6?\u201d as:\n    # Does any part of that ship occupy column index 5 (0\u2010based)?\n    return bool(np.any(coords[:, 1] == 5))\n","name":"program_56","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"IS it on column 5?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify all ship values on the true board (1=Red, 2=Green, 3=Purple, 4=Orange)\n    all_ships = {v for v in np.unique(true_board) if v > 0}\n    # Identify which ships have already been at least partly revealed on the partial board\n    revealed_ships = {v for v in np.unique(partial_board) if v > 0}\n    # The \u201clast\u201d ship is the one that hasn\u2019t appeared at all in partial_board\n    remaining = all_ships - revealed_ships\n    if not remaining:\n        # No remaining ship to ask about\n        return False\n    # There should be exactly one remaining ship\n    ship_value = remaining.pop()\n    # Find its positions on the true board\n    positions = np.argwhere(true_board == ship_value)\n    # Check if any of those positions lie in column 5 (0-indexed col == 4)\n    return np.any(positions[:, 1] == 4)\n","name":"program_57","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Yo uare clearly sabotaging this. Saying it is on row g that is impossible. Is it on row H?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the index for row 'H' (0-indexed, A=0, B=1, ..., H=7)\n    row_idx = ord('H') - ord('A')\n    # A ship tile is any true_board entry > 0\n    # A hidden tile in the partial board is marked as -1\n    unrevealed_ship_in_H = (partial_board[row_idx, :] == -1) & (true_board[row_idx, :] > 0)\n    # If any position in row H is both hidden and contains a ship, answer Yes\n    return bool(np.any(unrevealed_ship_in_H))\n","name":"program_58","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship before E and after 4?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines whether there exists at least one unrevealed ship tile\n    in any row before 'E' (i.e., rows A-D) and in any column after 4\n    (i.e., columns 5-8).\n    \"\"\"\n    # Map 'E' to its zero-based index (A=0, B=1, C=2, D=3, E=4)\n    row_cut = ord('E') - ord('A')  # 4\n    # Columns after 4 means zero-based indices >= 4\n    col_cut = 4\n\n    # Slice out the region: rows A\u2013D (0:4), columns 5\u20138 (4:)\n    true_region = true_board[:row_cut, col_cut:]\n    partial_region = partial_board[:row_cut, col_cut:]\n\n    # A ship tile in the true board is > 0; an unrevealed tile in partial is == -1\n    unrevealed_ship_tiles = (true_region > 0) & (partial_region == -1)\n\n    return bool(np.any(unrevealed_ship_tiles))\n","name":"program_59","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the last ship directly to the right of the purple ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # All possible ship IDs\n    ship_ids = [1, 2, 3, 4]\n\n    # 1) Determine which ship is still partially or wholly hidden:\n    #    i.e. its count in partial_board is strictly less than in true_board.\n    last_ships = []\n    for sid in ship_ids:\n        full_count = np.sum(true_board == sid)\n        seen_count = np.sum(partial_board == sid)\n        if seen_count < full_count:\n            last_ships.append(sid)\n\n    # If no or multiple candidates, we cannot be sure; return False by default.\n    if len(last_ships) != 1:\n        return False\n\n    last_id = last_ships[0]\n\n    # 2) For every purple tile (ID==3), check if the tile to its right is last_id.\n    rows, cols = true_board.shape\n    purple_positions = np.argwhere(true_board == 3)\n    for r, c in purple_positions:\n        # ensure we stay in bounds\n        if c + 1 < cols and true_board[r, c + 1] == last_id:\n            return True\n\n    return False\n","name":"program_60","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"So it is horizontal on h then?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify the label of the one completely hidden ship\n    # Ship labels are 1, 2, 3, 4\n    for ship_label in (1, 2, 3, 4):\n        # Find all coordinates of this ship on the true board\n        ship_rows, ship_cols = np.where(true_board == ship_label)\n        if ship_rows.size == 0:\n            # No such ship on the board\n            continue\n        # Check if all of its tiles are still hidden in partial_board\n        if np.all(partial_board[ship_rows, ship_cols] == -1):\n            # This is the last (unrevealed) ship\n            # Check if it's horizontal on row H (index 7)\n            # A horizontal ship on H means all its row indices == 7\n            return np.all(ship_rows == 7)\n    # If we didn't find any completely hidden ship, or none on H, answer No\n    return False\n","name":"program_61","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it directly to the right of the yellow ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the one remaining (unrevealed) ship has at least one tile\n    directly to the right of the 'yellow' ship (which we take to be the orange\n    ship, code 4). Otherwise returns False.\n    \"\"\"\n    # All ship\u2010codes we expect\n    ALL_SHIPS = {1, 2, 3, 4}\n    # Figure out which ship\u2010codes have already been revealed in partial_board\n    revealed = set(np.unique(partial_board)) & ALL_SHIPS\n    # The one left unrevealed\n    unknown = ALL_SHIPS - revealed\n    if len(unknown) != 1:\n        # If ambiguous (or none), we cannot assert a positive adjacency\n        return False\n    unknown_code = unknown.pop()\n    yellow_code = 4  # interpret 'yellow' as the orange ship (code 4)\n    \n    # Look through all tiles of the unknown ship in the true board\n    # and see if any has an orange tile immediately to its left.\n    ub_rows, ub_cols = np.where(true_board == unknown_code)\n    for r, c in zip(ub_rows, ub_cols):\n        if c > 0 and true_board[r, c - 1] == yellow_code:\n            return True\n    return False\n","name":"program_62","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships within E-H?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed ship tile in rows E\u2013H (zero-indexed rows 4\u20137),\n    otherwise False.\n    \"\"\"\n    # Extract rows E (4) through H (7) inclusive\n    sub_true    = true_board[4:8, :]\n    sub_partial = partial_board[4:8, :]\n    # A ship tile is > 0 in true_board; hidden tiles are == -1 in partial_board\n    hidden_ship_tiles = (sub_true > 0) & (sub_partial == -1)\n    return bool(np.any(hidden_ship_tiles))\n","name":"program_63","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships in quadrant A (1-8)?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Quadrant A corresponds to row 0 (A) and columns 1\u20138 (0\u20137 in 0-based indexing).\n    # We check for any ship parts (true_board > 0) in row 0 that remain hidden (partial_board == -1).\n    rowA_true = true_board[0, :]\n    rowA_partial = partial_board[0, :]\n    hidden_ship_tiles = (rowA_true > 0) & (rowA_partial == -1)\n    return bool(np.any(hidden_ship_tiles))\n","name":"program_64","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships between G 1-4?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row G corresponds to index 6 (A=0, B=1, \u2026, G=6)\n    row_idx = ord('G') - ord('A')\n    # Columns 1-4 correspond to indices 0-3\n    cols = slice(0, 4)\n    # A ship tile is present if true_board > 0, and it's still hidden if partial_board == -1\n    unrevealed_ships = (true_board[row_idx, cols] > 0) & (partial_board[row_idx, cols] == -1)\n    return bool(np.any(unrevealed_ships))\n","name":"program_65","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship between E1 to E8","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We're interested in row E, which is the 5th row (0\u2010indexed index 4)\n    row_idx = ord('E') - ord('A')  # 4\n    # Columns 1 through 8 correspond to indices 0 through 7\n    true_segment = true_board[row_idx, 0:8]\n    partial_segment = partial_board[row_idx, 0:8]\n    # A ship tile is present and still hidden if true_board > 0 and partial_board == -1\n    unrevealed_ship_mask = (true_segment > 0) & (partial_segment == -1)\n    # If any such tile exists, the answer is Yes (True), otherwise No (False)\n    return bool(np.any(unrevealed_ship_mask))\n","name":"program_66","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there orange ships between B1 to B8","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is any unrevealed orange ship tile (value 4) \n    in row B between columns 1 and 8 inclusive.\n    \"\"\"\n    # Compute the index for row 'B'\n    row_index = ord('B') - ord('A')\n    # Slice out columns 1\u20138 (0-based indices 0\u20137)\n    true_segment = true_board[row_index, 0:8]\n    partial_segment = partial_board[row_index, 0:8]\n    # Check for any tile that is orange (4) in the true board and still hidden (-1) in the partial board\n    unrevealed_orange = (true_segment == 4) & (partial_segment == -1)\n    return bool(np.any(unrevealed_orange))\n","name":"program_67","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there purple ships from H1 to H8","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row H corresponds to index 7 (0-based indexing: A\u21920, B\u21921, \u2026, H\u21927)\n    row_idx = ord('H') - ord('A')\n    # Identify purple ship tiles (value == 3) in the true board on row H\n    is_purple = (true_board[row_idx, :] == 3)\n    # Identify which of those tiles are still hidden on the captain's board (value == -1)\n    is_unrevealed = (partial_board[row_idx, :] == -1)\n    # If there is at least one unrevealed purple tile in H1\u2013H8, answer \"Yes\"\n    return bool(np.any(is_purple & is_unrevealed))\n","name":"program_68","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there several ships from A1 to H1","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines whether there are multiple distinct ships occupying the tiles\n    from A1 to H1 (i.e., the entire 1st column of the board).\n\n    We look at true_board[:, 0] to get the contents of A1..H1:\n      0 = water, >0 = ship ID.\n    We collect the set of ship IDs in that column (excluding 0),\n    and check if there are at least two distinct IDs.\n    \"\"\"\n    # extract the first column (A1 through H1)\n    column_1 = true_board[:, 0]\n    \n    # find all distinct ship IDs (> 0) in that column\n    ship_ids = set(column_1[column_1 > 0])\n    \n    # return True if there are two or more distinct ships\n    return len(ship_ids) > 1\n","name":"program_69","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships between D1-8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row 'D' to its zero-based index: A\u21920, B\u21921, C\u21922, D\u21923\n    row_index = 3\n\n    # A ship tile is any value > 0 in true_board.\n    # We only care about tiles still hidden to the Captain (partial_board == -1).\n    unrevealed_in_row = (true_board[row_index, :] > 0) & (partial_board[row_index, :] == -1)\n\n    # If there's any unrevealed ship tile in row D, return True; otherwise False.\n    return bool(np.any(unrevealed_in_row))\n","name":"program_70","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"A1 to H1?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine if there are any unrevealed ship tiles in the segment A1 to H1\n    (i.e., the entire first column).\n    \"\"\"\n    # Extract the first column from both boards\n    true_col = true_board[:, 0]\n    partial_col = partial_board[:, 0]\n    \n    # A ship tile is present if true_board > 0\n    # It's unrevealed if partial_board == -1\n    unrevealed_ships = (true_col > 0) & (partial_col == -1)\n    \n    # If any position in that column has an unrevealed ship, return True (\"Yes\"),\n    # otherwise return False (\"No\").\n    return bool(np.any(unrevealed_ships))\n","name":"program_71","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there ships from A8 to H8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in the vertical slice from A8 to H8, otherwise False.\n    \"\"\"\n    # Column index for \"8\" is 7 (0\u2010based indexing)\n    col_idx = 7\n    \n    # A ship tile is indicated by a value > 0 in true_board.\n    # An unrevealed tile is indicated by -1 in partial_board.\n    ship_tiles = true_board[:, col_idx] > 0\n    hidden_tiles = partial_board[:, col_idx] == -1\n    \n    # If any position in that column is both a ship and still hidden,\n    # answer \"Yes\" (True), otherwise \"No\" (False).\n    return bool(np.any(ship_tiles & hidden_tiles))\n","name":"program_72","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the orange ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the orange ship (value == 4)\n    coords = np.argwhere(true_board == 4)\n    # If no orange ship is found, default to False\n    if coords.size == 0:\n        return False\n    # Extract the row indices of those coordinates\n    rows = coords[:, 0]\n    # If all row indices are the same, the ship is horizontal\n    return np.all(rows == rows[0])\n","name":"program_73","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any parts of a ship in row H","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'H' to zero-based index\n    row_index = ord('H') - ord('A')\n    # A tile counts if it's part of a ship in the true board (> 0)\n    # and is still hidden (== -1) in the partial board.\n    unrevealed_ship_tiles = (true_board[row_index, :] > 0) & (partial_board[row_index, :] == -1)\n    return bool(np.any(unrevealed_ship_tiles))\n","name":"program_74","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any parts of a ship in rows A-C and columns 6-8","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine if there are any unrevealed ship parts in rows A-C (0\u20132) and columns 6\u20138 (5\u20137).\n\n    Arguments:\n    - true_board:   full 8\u00d78 board with 0=water, 1\u20134=ship IDs\n    - partial_board: current 8\u00d78 board with -1=hidden, 0=revealed water, >0=revealed ship\n\n    Returns:\n    - True if there's at least one ship tile in the specified subgrid that remains hidden.\n    - False otherwise.\n    \"\"\"\n    # Extract the subgrid for rows A\u2013C (0:3) and columns 6\u20138 (5:8)\n    sub_true = true_board[0:3, 5:8]\n    sub_partial = partial_board[0:3, 5:8]\n\n    # A tile is an unrevealed ship part if true_board>0 and partial_board==-1\n    unrevealed_ship = (sub_true > 0) & (sub_partial == -1)\n\n    # Return True if any such tile exists\n    return bool(np.any(unrevealed_ship))\n","name":"program_75","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any parts of a ship in the rows A-C and columns 1-3","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows A\u2013C correspond to indices 0 through 2, columns 1\u20133 correspond to indices 0 through 2\n    sub_true = true_board[0:3, 0:3]\n    sub_partial = partial_board[0:3, 0:3]\n\n    # A ship part is any value > 0 in true_board.\n    # We only care about parts that are still hidden to the Captain (partial_board == -1).\n    hidden_ship_parts = (sub_true > 0) & (sub_partial == -1)\n\n    return np.any(hidden_ship_parts)\n","name":"program_76","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the green ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the green ship (marked as 2 in true_board)\n    green_coords = np.argwhere(true_board == 2)\n    \n    # Extract row indices and column indices\n    rows = green_coords[:, 0]\n    cols = green_coords[:, 1]\n    \n    # The ship is horizontal if all row indices are the same\n    return np.all(rows == rows[0])\n","name":"program_77","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the red ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the red ship (denoted by 1)\n    red_coords = np.argwhere(true_board == 1)\n    \n    # If there are fewer than 2 parts, it can't form a ship\n    if red_coords.shape[0] < 2:\n        return False\n    \n    # Check if all row indices are the same\n    rows = red_coords[:, 0]\n    return bool(np.all(rows == rows[0]))\n","name":"program_78","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Does E7 have a part of a ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Question is asking about E7, which corresponds to row index 4 (E) and column index 6 (7).\n    row = ord('E') - ord('A')   # 4\n    col = 7 - 1                 # 6\n    # Return True if there's a ship part (>0) at that location, False otherwise\n    return true_board[row, col] > 0\n","name":"program_79","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there part of an yet to be discovered ship in column 5","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Column index for column 5 is 4 (0-based indexing)\n    col = 4\n    # A tile is a yet-to-be-discovered ship part if:\n    #   true_board has a ship (>0) at that position\n    #   AND partial_board still shows it as hidden (-1)\n    hidden_ship_parts = (true_board[:, col] > 0) & (partial_board[:, col] == -1)\n    return bool(np.any(hidden_ship_parts))\n","name":"program_80","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any parts of a ship in rows E-G and columns 1-3","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows E-G correspond to indices 4,5,6; columns 1-3 correspond to indices 0,1,2\n    # We're looking for any ship part (true_board > 0) that remains hidden (partial_board == -1)\n    region_true = true_board[4:7, 0:3]\n    region_partial = partial_board[4:7, 0:3]\n    # If any tile in that region is a ship and still hidden, return True, otherwise False\n    return bool(np.any((region_true > 0) & (region_partial == -1)))\n","name":"program_81","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the orange ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find the coordinates of all orange ship tiles (marked with 4)\n    coords = np.argwhere(true_board == 4)\n    if coords.size == 0:\n        # No orange ship found (should not happen in a valid game)\n        return False\n    # Separate into row and column indices\n    rows, cols = coords[:, 0], coords[:, 1]\n    # If all row indices are the same, the ship is horizontal\n    return np.all(rows == rows[0])\n","name":"program_82","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any parts of the ship in rowD","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'D' to zero\u2010based index 3\n    row_idx = ord('D') - ord('A')\n    # Extract the true and partial rows\n    true_row = true_board[row_idx]\n    partial_row = partial_board[row_idx]\n    # A ship part is present if true_board>0, and it's unrevealed if partial_board==-1\n    unrevealed_ships = (true_row > 0) & (partial_row == -1)\n    # If any such tile exists, answer Yes (True), otherwise No (False)\n    return bool(unrevealed_ships.any())\n","name":"program_83","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the ship in row D horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to know if the ship that occupies row D (index 3) is placed horizontally.\n    target_row = 3  # row D is the 4th row, zero-based index 3\n\n    # 1) Find a column in row D where there's a ship segment on the true board.\n    #    If partial_board has revealed something there, that's fine too.\n    ship_cols = np.where(true_board[target_row, :] > 0)[0]\n    if ship_cols.size == 0:\n        # No ship at all in row D\n        return False\n\n    # 2) Pick that ship's ID\n    ship_id = true_board[target_row, ship_cols[0]]\n\n    # 3) Locate all segments of that same ship on the true board\n    ship_cells = np.argwhere(true_board == ship_id)\n    # ship_cells is an array of (row, col) pairs\n\n    # 4) If all segments have the same row index, it's horizontal.\n    all_rows = ship_cells[:, 0]\n    return np.all(all_rows == all_rows[0])\n","name":"program_84","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ship parts in row F?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the 0-based row index for row 'F'\n    row_index = ord('F') - ord('A')\n    # A ship part is \"unrevealed\" if true_board > 0 but partial_board is still -1\n    unrevealed_in_row = (true_board[row_index] > 0) & (partial_board[row_index] == -1)\n    # If any such tile exists, the answer is True; otherwise False\n    return bool(np.any(unrevealed_in_row))\n","name":"program_85","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ship parts in row E?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'E' to its 0-based index (A\u21920, B\u21921, \u2026, H\u21927)\n    row_idx = ord('E') - ord('A')\n    # Identify ship cells in the true board (>0)\n    ship_cells = true_board[row_idx, :] > 0\n    # Identify which of those ship cells are still hidden in the partial board (-1)\n    hidden_ship_cells = (partial_board[row_idx, :] == -1) & ship_cells\n    # If any ship cell in row E remains hidden, answer \"Yes\" (True)\n    return bool(np.any(hidden_ship_cells))\n","name":"program_86","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We know the Captain just asked about row 'E'.\n    # Convert 'E' \u2192 row index 4 (0\u2010based)\n    row_idx = ord('E') - ord('A')\n\n    # In that row, find any still-hidden ship cells\n    row_true    = true_board[row_idx]\n    row_partial = partial_board[row_idx]\n    hidden_ship_mask = (row_true != 0) & (row_partial == -1)\n\n    # If there are no hidden ship cells in that row, answer is False\n    if not np.any(hidden_ship_mask):\n        return False\n\n    # Grab the first ship ID that is still hidden in row E\n    ship_id = row_true[hidden_ship_mask][0]\n\n    # Find every cell of that ship on the true board\n    ship_coords = np.argwhere(true_board == ship_id)\n    ship_rows   = ship_coords[:, 0]\n\n    # If all of its row\u2010indices are identical, it's horizontal\n    return np.all(ship_rows == ship_rows[0])\n","name":"program_87","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any ship parts in column 8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed ship part in column 8,\n    i.e. any cell in the 8th column where true_board>0 but partial_board is still hidden (-1).\n    \"\"\"\n    col_idx = 7  # zero-based index for column 8\n    true_col = true_board[:, col_idx]\n    partial_col = partial_board[:, col_idx]\n    # A ship part is unrevealed if true_board>0 and partial_board==-1\n    return bool(np.any((true_col > 0) & (partial_col == -1)))\n","name":"program_88","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship part in row B?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to know if there's any unrevealed ship tile in row B.\n    # Row B corresponds to index 1 (0-based indexing).\n    row_idx = 1\n\n    # Identify tiles in row B that are still hidden on the partial board\n    hidden_mask = partial_board[row_idx] == -1\n\n    # Among those hidden tiles, check if any are ship parts on the true board\n    ship_mask = true_board[row_idx] > 0\n\n    # If there is at least one position where both masks are True, return True\n    return bool(np.any(hidden_mask & ship_mask))\n","name":"program_89","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify which ship is partially revealed but not yet fully sunk\n    ship_ids = [1, 2, 3, 4]\n    partially_found = []\n    for s in ship_ids:\n        # All true positions of ship s\n        true_pos = np.argwhere(true_board == s)\n        if true_pos.size == 0:\n            continue\n        # All revealed positions of ship s\n        found_pos = np.argwhere(partial_board == s)\n        # If we've found at least one part but not all parts, it's our target ship\n        if 0 < len(found_pos) < len(true_pos):\n            partially_found.append(s)\n\n    # If exactly one ship meets the criteria, use it; otherwise pick the ship with the most hits\n    if len(partially_found) == 1:\n        target = partially_found[0]\n    else:\n        # Fallback: choose the ship with the most revealed parts\n        max_hits = -1\n        target = None\n        for s in ship_ids:\n            hits = np.count_nonzero(partial_board == s)\n            if hits > max_hits:\n                max_hits = hits\n                target = s\n\n    # Get the true coordinates of the target ship\n    coords = np.argwhere(true_board == target)\n    rows, cols = coords[:, 0], coords[:, 1]\n\n    # If all row indices are the same, the ship is horizontal\n    return np.all(rows == rows[0])\n","name":"program_90","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are their any ship parts in row H?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letters A\u2013H to indices 0\u20137; here we check row H\n    row_index = ord('H') - ord('A')\n    # A ship part is unrevealed if true_board > 0 but partial_board is still hidden (-1)\n    unrevealed_in_row = (true_board[row_index] > 0) & (partial_board[row_index] == -1)\n    return bool(np.any(unrevealed_in_row))\n","name":"program_91","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ship parts in row G?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row G corresponds to index 6 (0-based, A=0, B=1, ..., G=6)\n    row_index = ord('G') - ord('A')\n    \n    # Identify where there are ship parts in the true board for row G\n    ship_parts_in_true = true_board[row_index] > 0\n    \n    # Identify which of those ship parts are still hidden in the partial board\n    hidden_in_partial = partial_board[row_index] == -1\n    \n    # If any ship part in true_board at row G is still hidden in partial_board, answer Yes (True)\n    return bool(np.any(ship_parts_in_true & hidden_in_partial))\n","name":"program_92","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the ship in row G horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the row index for 'G'\n    row_idx = ord('G') - ord('A')\n    # Find unrevealed ship parts in that row\n    unrevealed = (true_board[row_idx, :] > 0) & (partial_board[row_idx, :] == -1)\n    cols = np.where(unrevealed)[0]\n    # If fewer than 2 parts remain, we cannot infer a horizontal orientation\n    if cols.size < 2:\n        return False\n    # Check if the remaining parts form a contiguous horizontal segment\n    return (cols.max() - cols.min()) == (cols.size - 1)\n","name":"program_93","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any parts of a ship in Row B?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there are any unrevealed ship parts in Row B, False otherwise.\n    \"\"\"\n    # Row B corresponds to index 1 (since A=0, B=1, C=2, ...)\n    row_idx = 1\n    \n    # Identify cells in Row B that are still hidden on the partial board\n    hidden_cells = (partial_board[row_idx, :] == -1)\n    \n    # Identify cells in Row B that actually contain a ship in the true board\n    ship_cells   = (true_board[row_idx, :] > 0)\n    \n    # If any cell is both hidden and a ship, return True; else False\n    return bool(np.any(hidden_cells & ship_cells))\n","name":"program_94","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all as\u2010yet hidden ship parts\n    hidden_ships = (partial_board == -1) & (true_board > 0)\n    # Identify which rows still contain hidden ship parts\n    rows_with_hidden = np.where(hidden_ships.any(axis=1))[0]\n    if rows_with_hidden.size == 0:\n        # No hidden ships anywhere, so no orientation to report\n        return False\n\n    # We assume the captain is still asking about the first row\n    # in which a ship part remains hidden (e.g. Row B \u2192 index 1).\n    target_row = rows_with_hidden[0]\n\n    # Pick the ship ID of any hidden part in that row\n    ship_ids_in_row = true_board[target_row][hidden_ships[target_row]]\n    ship_id = ship_ids_in_row[0]\n\n    # Get all coordinates of that ship on the true board\n    coords = np.argwhere(true_board == ship_id)\n    # coords is an array of [row, col] pairs\n\n    # If all row indices are identical, the ship is horizontal\n    return np.all(coords[:, 0] == coords[0, 0])\n","name":"program_95","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any parts of a boat in column 1?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert human column \"1\" to zero-based index 0\n    col = 0\n    # A ship part is undiscovered if true_board>0 but partial_board is still -1\n    ship_cells = (true_board[:, col] > 0)\n    hidden_cells = (partial_board[:, col] == -1)\n    # If any undiscovered ship cell remains in column 1, answer \"yes\"\n    return bool(np.any(ship_cells & hidden_cells))\n","name":"program_96","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there any part of a boat in row F?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We need to check if there are any *unrevealed* ship parts in row F.\n    # Row F is the 6th row, index 5 in 0-based indexing.\n    row_idx = ord('F') - ord('A')  # = 5\n    # A ship part is represented by >0 in true_board.\n    # An unrevealed tile is represented by -1 in partial_board.\n    unrevealed_ship_parts = (true_board[row_idx, :] > 0) & (partial_board[row_idx, :] == -1)\n    return bool(np.any(unrevealed_ship_parts))\n","name":"program_97","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row g?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine if there are any undiscovered ship parts in row G.\n    \n    Rows are labeled A=0, B=1, \u2026, H=7. 'G' corresponds to index 6.\n    We look for cells where the true_board has a ship (> 0) but\n    the partial_board is still hidden (-1).\n    \"\"\"\n    # Compute the row index for 'G'\n    row_index = ord('G') - ord('A')  # 6\n\n    # Boolean mask of ship parts in true_board on row G that are still hidden in partial_board\n    undiscovered = (true_board[row_index] > 0) & (partial_board[row_index] == -1)\n\n    # If any True in the mask, there is at least one undiscovered ship part\n    return bool(np.any(undiscovered))\n","name":"program_98","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any non-discovered parts of a boat in column 3?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Column 3 in human terms is index 2 in a 0-based numpy array\n    col_idx = 2\n    # A ship part exists where true_board > 0\n    ships_in_col = true_board[:, col_idx] > 0\n    # A tile is undiscovered where partial_board == -1\n    hidden_in_col = partial_board[:, col_idx] == -1\n    # If any tile in column 3 is both a ship and still hidden, return True\n    return bool(np.any(ships_in_col & hidden_in_col))\n","name":"program_99","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines whether the ship that still has hidden parts in column 3\n    is oriented horizontally.\n\n    We identify which ship type (1\u20134) has at least one hidden tile\n    in column index 2 (i.e. column 3), then inspect all of that ship's\n    true_board coordinates.  If its row indices are constant, it's\n    horizontal; if its column indices are constant, it's vertical.\n    \"\"\"\n    # Column we're inspecting is the 3rd column (0-based index 2)\n    col_idx = 2\n\n    # Find which ship IDs have at least one hidden cell in that column\n    target_ships = []\n    for ship_id in [1, 2, 3, 4]:\n        hidden_in_col = (true_board[:, col_idx] == ship_id) & (partial_board[:, col_idx] == -1)\n        if np.any(hidden_in_col):\n            target_ships.append(ship_id)\n\n    # If we don't have exactly one such ship, the question is ambiguous;\n    # we conservatively return False (i.e. \"No\").\n    if len(target_ships) != 1:\n        return False\n\n    ship_id = target_ships[0]\n\n    # Get all coordinates of that ship in the true board\n    coords = np.argwhere(true_board == ship_id)\n    rows = coords[:, 0]\n    cols = coords[:, 1]\n\n    # Check orientation:\n    #   horizontal \u2192 all rows are the same\n    #   vertical   \u2192 all columns are the same\n    if np.all(rows == rows[0]):\n        return True\n    else:\n        return False\n","name":"program_100","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all currently hidden ship\u2010tiles\n    hidden_ship_tiles = (partial_board == -1) & (true_board > 0)\n    # Determine which ship ID is referenced (should be exactly one)\n    ship_ids = np.unique(true_board[hidden_ship_tiles])\n    if ship_ids.size != 1:\n        # Either no hidden ships or more than one ship has hidden tiles\n        return False\n    ship_id = ship_ids[0]\n    # Get the full set of coordinates for that ship\n    coords = np.argwhere(true_board == ship_id)\n    rows, cols = coords[:, 0], coords[:, 1]\n    # If all row indices are equal, the ship is horizontal\n    return np.all(rows == rows[0])\n","name":"program_101","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any parts of a boat in row H?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row H is index 7 (A\u21920, B\u21921, \u2026, H\u21927)\n    row_idx = 7\n    # Find where there is a ship part (>0) in the true board\n    ship_parts = true_board[row_idx, :] > 0\n    # Find where the captain still sees the tile as hidden\n    still_hidden = partial_board[row_idx, :] == -1\n    # If any position has both a ship part and is still hidden, return True\n    return bool(np.any(ship_parts & still_hidden))\n","name":"program_102","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there any part of a boat in column 6?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Column 6 corresponds to index 5 (0-based indexing)\n    col_idx = 5\n    \n    # A cell is \u201cundiscovered ship\u201d if partial_board is still hidden (-1)\n    # but true_board has a ship (>0) at that location.\n    undiscovered_in_col = (partial_board[:, col_idx] == -1) & (true_board[:, col_idx] > 0)\n    \n    # If any such cell exists, answer is True, otherwise False.\n    return bool(np.any(undiscovered_in_col))\n","name":"program_103","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the (unrevealed) ship parts in the most recently probed column\n    are part of a vertically oriented ship.\n\n    Strategy:\n    1. Find all columns that the Captain has probed (i.e. any cell != -1 in partial_board).\n    2. In column\u2010order, look for the first column where there still exists at least one\n       unrevealed ship cell (true_board > 0 and partial_board == -1).\n    3. For one of those unrevealed cells, check the true_board above\/below:\n       - If the same ship ID appears directly above or below, the ship is vertical \u2192 return True.\n       - Otherwise it's horizontal \u2192 return False.\n    4. If no column qualifies, default to False.\n    \"\"\"\n    # 1) Which columns have been probed?\n    probed_cols = np.where((partial_board != -1).any(axis=0))[0]\n\n    # 2) Find the first probed column that still holds hidden ship parts\n    for col in probed_cols:\n        # rows in this column which are ship parts in true_board but are still hidden\n        hidden_ship_rows = np.where((partial_board[:, col] == -1) & (true_board[:, col] > 0))[0]\n        if hidden_ship_rows.size > 0:\n            # pick one unrevealed segment\n            row = hidden_ship_rows[0]\n            ship_id = true_board[row, col]\n            H, W = true_board.shape\n\n            # 3) check vertical neighbors\n            up   = row > 0      and true_board[row - 1, col] == ship_id\n            down = row < H - 1  and true_board[row + 1, col] == ship_id\n\n            return bool(up or down)\n\n    # 4) no unrevealed ship in any probed column\n    return False\n","name":"program_104","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ship parts in Row D?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'D' to a 0-based index (A\u21920, B\u21921, \u2026, D\u21923)\n    row_idx = ord('D') - ord('A')\n    \n    # Extract that row from both boards\n    true_row = true_board[row_idx, :]\n    partial_row = partial_board[row_idx, :]\n    \n    # A ship part is indicated by a positive number in true_board.\n    # It is still hidden if the corresponding partial_board entry is -1.\n    hidden_ship_parts = (true_row > 0) & (partial_row == -1)\n    \n    # If there's at least one such tile, the answer is \"Yes\"\n    return bool(np.any(hidden_ship_parts))\n","name":"program_105","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # The Captain's last question concerned Row D (index 3)\n    row_idx = ord('D') - ord('A')\n    ncols = true_board.shape[1]\n\n    # Find all hidden tiles in Row D that actually contain a ship\n    hidden_ship_cols = np.where(\n        (partial_board[row_idx, :] == -1) & (true_board[row_idx, :] > 0)\n    )[0]\n\n    # For each such ship\u2010cell, check if that ship has a horizontal neighbor\n    for col in hidden_ship_cols:\n        ship_id = true_board[row_idx, col]\n        # check left\n        if col > 0 and true_board[row_idx, col - 1] == ship_id:\n            return True\n        # check right\n        if col < ncols - 1 and true_board[row_idx, col + 1] == ship_id:\n            return True\n\n    # No hidden ship in Row D is part of a horizontally oriented vessel\n    return False\n","name":"program_106","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ship parts in column 8?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to know if there are any *unrevealed* ship parts in column 8.\n    # Column 8 has index 7 (0-based indexing).\n    col_idx = 7\n\n    # A tile is hidden if partial_board == -1\n    hidden_mask = partial_board[:, col_idx] == -1\n    # A tile has a ship part if true_board > 0\n    ship_mask = true_board[:, col_idx] > 0\n\n    # There is an unrevealed ship part in column 8 if any position is both hidden and a ship.\n    return bool(np.any(hidden_mask & ship_mask))\n","name":"program_107","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We're answering \"Is the ship that has hidden parts in column 8 vertical?\"\n    # Column 8 in human terms is index 7 in zero\u2010based numpy indexing.\n    col_idx = 7\n    \n    # Find all unrevealed ship parts in that column\n    # A ship part is true_board > 0, and unrevealed means partial_board == -1\n    hidden_in_col = np.argwhere((true_board > 0) &\n                                (partial_board == -1) &\n                                (np.arange(true_board.shape[1])[None, :] == col_idx))\n    \n    # If there are no hidden ship parts in column 8, the question is moot: return False\n    if hidden_in_col.size == 0:\n        return False\n    \n    # Identify the ship ID at the first hidden tile in that column\n    r0, c0 = hidden_in_col[0]\n    ship_id = true_board[r0, c0]\n    \n    # Extract all coordinates of that ship on the true board\n    ship_coords = np.argwhere(true_board == ship_id)\n    rows = np.unique(ship_coords[:, 0])\n    cols = np.unique(ship_coords[:, 1])\n    \n    # The ship is vertical if it spans multiple rows but only one column\n    return (cols.size == 1 and rows.size > 1)\n","name":"program_108","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there parts of the boat in column 8 in rows d, e, or f?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows D, E, F correspond to indices 3, 4, 5; column 8 is index 7.\n    rows = [3, 4, 5]\n    col = 7\n    # Check for any unrevealed ship part in those positions.\n    region_has_hidden_ship = np.any(\n        (true_board[rows, col] > 0) &\n        (partial_board[rows, col] == -1)\n    )\n    return bool(region_has_hidden_ship)\n","name":"program_109","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any parts of a boat in the square A-C and 1-3","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in the sub\u2010grid defined by rows A\u2013C (indices 0\u20132) and columns 1\u20133 (indices 0\u20132).\n    \"\"\"\n    # Extract the 3\u00d73 region A\u2013C, 1\u20133\n    sub_true = true_board[0:3, 0:3]\n    sub_partial = partial_board[0:3, 0:3]\n    \n    # A ship tile is any cell in true_board > 0, and it's still hidden if partial_board == -1\n    unrevealed_ship_tiles = (sub_true > 0) & (sub_partial == -1)\n    \n    # If any such tile exists, answer \"Yes\"\n    return bool(np.any(unrevealed_ship_tiles))\n","name":"program_110","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any ship parts in row g?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row labels A\u2013H map to indices 0\u20137; row \u201cG\u201d is index 6\n    row_idx = 6\n    # A tile is an unrevealed ship part if true_board>0 and partial_board is still hidden (-1)\n    mask = (true_board[row_idx, :] > 0) & (partial_board[row_idx, :] == -1)\n    return bool(np.any(mask))\n","name":"program_111","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the red boat horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the red ship (encoded as 1)\n    red_coords = np.argwhere(true_board == 1)\n    \n    # If there are fewer than 2 parts, we cannot determine orientation;\n    # here we assume \"not horizontal\" in that degenerate case.\n    if red_coords.shape[0] < 2:\n        return False\n    \n    # Extract the row indices of the red ship parts\n    row_indices = red_coords[:, 0]\n    \n    # If all row indices are the same, the ship is horizontal.\n    # Otherwise, it's vertical.\n    return np.all(row_indices == row_indices[0])\n","name":"program_112","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the (unrevealed) ship that has parts in the fully\n    hidden row is placed horizontally.\n\n    Strategy:\n    1. Find the row index `r` such that:\n       - partial_board[r, :] is entirely hidden (-1)\n       - true_board[r, :] contains at least one ship tile (> 0)\n       This picks out the row the Captain just asked about.\n    2. Within that row, identify the unique ship ID among the hidden ship tiles.\n    3. Gather all coordinates of that ship ID on the true_board.\n    4. If all those coordinates lie in the same row => horizontal => return True.\n       Otherwise => vertical => return False.\n    \"\"\"\n    # Step 1: locate the target row\n    hidden = (partial_board == -1)\n    num_rows = true_board.shape[0]\n    candidate_rows = [\n        r for r in range(num_rows)\n        if hidden[r, :].all() and (true_board[r, :] > 0).any()\n    ]\n    if len(candidate_rows) != 1:\n        # Ambiguous or no such row \u2013 default to False\n        return False\n\n    target_row = candidate_rows[0]\n\n    # Step 2: find the ship ID in that row among the hidden tiles\n    mask = (true_board > 0) & hidden\n    ship_ids = np.unique(true_board[target_row, :][mask[target_row, :]])\n    ship_ids = ship_ids[ship_ids > 0]\n    if ship_ids.size != 1:\n        # Either no ship or multiple ship IDs \u2013 default to False\n        return False\n\n    ship_id = ship_ids[0]\n\n    # Step 3: gather all coordinates of that ship on the true board\n    coords = np.argwhere(true_board == ship_id)\n    rows, cols = coords[:, 0], coords[:, 1]\n\n    # Step 4: check orientation\n    # horizontal if all row indices are the same\n    return np.unique(rows).size == 1\n","name":"program_113","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there ship parts in column 8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Column 8 in 1-based indexing corresponds to index 7 in 0-based numpy arrays\n    col_idx = 7\n    # A hidden ship part is where true_board > 0 (ship) and partial_board == -1 (still hidden)\n    hidden_ships_in_col = (true_board[:, col_idx] > 0) & (partial_board[:, col_idx] == -1)\n    return bool(np.any(hidden_ships_in_col))\n","name":"program_114","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Fair lol - is it vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the ship that has at least one tile in column 8\n    is oriented vertically, False otherwise.\n    \"\"\"\n    # Column index for \"8\" is 7 (0-based)\n    col_idx = 7\n\n    # Find all ship\u2010IDs that appear in column 8 of the true board\n    ship_ids_in_col8 = np.unique(true_board[:, col_idx])\n    # Remove water (0) and any hidden markers (if present)\n    ship_ids_in_col8 = ship_ids_in_col8[ship_ids_in_col8 > 0]\n\n    # If there are no ships in column 8, answer False\n    if ship_ids_in_col8.size == 0:\n        return False\n\n    # We assume there is one ship of interest; if more, we check the first\n    ship_id = ship_ids_in_col8[0]\n\n    # Get all coordinates of that ship on the true board\n    coords = np.argwhere(true_board == ship_id)\n    # coords is an array of [row, col] pairs\n\n    # A ship is vertical if all of its column indices are the same\n    is_vertical = np.all(coords[:, 1] == coords[0, 1])\n    return bool(is_vertical)\n","name":"program_115","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ship parts in rows a, b or c?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one ship tile in rows A, B or C that\n    has not yet been revealed on the partial board. Rows A, B, C correspond\n    to indices 0, 1, 2.\n    \"\"\"\n    # Create a mask of ship cells that are still hidden\n    hidden_ship_cells = (true_board > 0) & (partial_board == -1)\n    # Check only rows A, B, C (indices 0, 1, 2)\n    return bool(hidden_ship_cells[0:3, :].any())\n","name":"program_116","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any parts in column 7?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert the human question \"Any parts in column 7?\" to a zero\u2010based index:\n    col_idx = 7 - 1\n    \n    # A ship part is any cell where true_board > 0\n    # It is undiscovered if partial_board == -1\n    mask_ship = true_board[:, col_idx] > 0\n    mask_hidden = partial_board[:, col_idx] == -1\n    \n    # If there is any position in that column which is a ship and still hidden,\n    # we answer \"Yes\" (True); otherwise \"No\" (False).\n    return bool(np.any(mask_ship & mask_hidden))\n","name":"program_117","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are they horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether all ships that have at least one (unrevealed or revealed)\n    tile in rows A, B, or C are oriented horizontally.\n    Rows A, B, C correspond to indices 0, 1, 2 in the numpy array.\n    \"\"\"\n    # Rows of interest (A, B, C)\n    rows = [0, 1, 2]\n    \n    # Find all ship labels appearing in those rows (exclude water 0 and hidden -1)\n    tiles_in_abc = true_board[rows, :].ravel()\n    ship_labels = set(np.unique(tiles_in_abc)) - {0, -1}\n    \n    # For each such ship, check orientation\n    for label in ship_labels:\n        # Get all coordinates of this ship on the true board\n        coords = np.argwhere(true_board == label)\n        if coords.shape[0] <= 1:\n            # A single-tile \"ship\" is trivially both, but real ships are length \u2265 2\n            continue\n        # Rows are coords[:,0], columns are coords[:,1]\n        same_row = np.all(coords[:, 0] == coords[0, 0])\n        same_col = np.all(coords[:, 1] == coords[0, 1])\n        # If it's not strictly horizontal (same_row), answer is False\n        if not same_row:\n            return False\n    # If we never found a non-horizontal ship, answer True\n    return True\n","name":"program_118","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any ship parts in row H?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'H' to its zero\u2010based index (A\u21920, B\u21921, \u2026, H\u21927)\n    row_idx = ord('H') - ord('A')\n    \n    # A tile is an undiscovered ship part if:\n    #  1) partial_board has it still hidden (== -1)\n    #  2) true_board has a ship part (> 0)\n    undiscovered_in_H = (partial_board[row_idx] == -1) & (true_board[row_idx] > 0)\n    \n    # If any such tile exists in row H, answer is Yes (True), otherwise No (False)\n    return bool(np.any(undiscovered_in_H))\n","name":"program_119","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # mask of as\u2010yet undiscovered ship cells\n    hidden_ship = (true_board > 0) & (partial_board == -1)\n\n    # find which ship\u2010IDs still have hidden cells\n    ship_ids = np.unique(true_board[hidden_ship])\n    # normally there will be exactly one ship still partly hidden,\n    # but even if there were more, we'll pick the first:\n    ship_id = ship_ids[0]\n\n    # all the hidden cells of that ship\n    ship_cells = np.argwhere((true_board == ship_id) & hidden_ship)\n    # ship_cells is an array of [row, col] pairs\n\n    # determine orientation:\n    # if all columns are the same \u2192 vertical, if all rows are the same \u2192 horizontal\n    rows = ship_cells[:, 0]\n    cols = ship_cells[:, 1]\n\n    is_vertical = (np.unique(cols).size == 1)\n    return is_vertical\n","name":"program_120","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any undiscovered ship parts in row A?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row A corresponds to index 0\n    row_idx = 0\n\n    # A ship part is any cell in true_board > 0\n    ship_mask = true_board[row_idx, :] > 0\n    # An unrevealed cell in partial_board is marked -1\n    hidden_mask = partial_board[row_idx, :] == -1\n\n    # Check if there is any cell in row A that is both a ship part and still hidden\n    return bool(np.any(ship_mask & hidden_mask))\n","name":"program_121","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any undiscovered in Row B?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row B corresponds to index 1 (A\u21920, B\u21921, \u2026)\n    row_idx = 1\n    # A ship part is any cell where true_board > 0.\n    # An undiscovered (hidden) cell in partial_board is marked -1.\n    # We look for positions in row B that are ships in true_board but still -1 in partial_board.\n    undiscovered_mask = (true_board[row_idx, :] > 0) & (partial_board[row_idx, :] == -1)\n    return bool(np.any(undiscovered_mask))\n","name":"program_122","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any parts in Row D?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to know if there are any *undiscovered* ship parts in row D.\n    # Undiscovered ship parts are those where true_board has a ship (> 0)\n    # and partial_board is still hidden (-1).\n    #\n    # Row D corresponds to index 3 (0-based: A=0, B=1, C=2, D=3).\n    row_idx = ord('D') - ord('A')\n    \n    # Mask of ship parts in the true board for row D\n    ships_in_true = true_board[row_idx] > 0\n    # Mask of hidden tiles in the partial board for row D\n    hidden_in_partial = partial_board[row_idx] == -1\n    \n    # Any position that is both a ship (in true) and still hidden (in partial)?\n    return bool(np.any(ships_in_true & hidden_in_partial))\n","name":"program_123","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any parts in row E?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row E corresponds to index 4 (A=0, B=1, C=2, D=3, E=4)\n    row_idx = ord('E') - ord('A')\n    # A ship part is indicated by true_board > 0.\n    # An undiscovered tile is indicated by partial_board == -1.\n    undiscovered_parts = (true_board[row_idx] > 0) & (partial_board[row_idx] == -1)\n    return bool(np.any(undiscovered_parts))\n","name":"program_124","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any parts in RowG?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the zero\u2010based index for row 'G'\n    row_index = ord('G') - ord('A')\n    \n    # A cell is an undiscovered ship part if:\n    # 1) true_board has a ship (> 0) at that location\n    # 2) partial_board is still hidden (-1) at that location\n    undiscovered = (true_board[row_index, :] > 0) & (partial_board[row_index, :] == -1)\n    \n    # Return True if any such cell exists\n    return bool(np.any(undiscovered))\n","name":"program_125","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any ship parts in column 8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We're checking for any undiscovered ship parts in column 8 (index 7)\n    col_idx = 7\n    # A tile is undiscovered if partial_board == -1\n    undiscovered = partial_board[:, col_idx] == -1\n    # Check if any of those undiscovered positions actually contain a ship (> 0)\n    return bool(np.any((true_board[:, col_idx] > 0) & undiscovered))\n","name":"program_126","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are any ships in corner?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in any of the four corners;\n    otherwise returns False.\n    \"\"\"\n    # Determine board dimensions\n    rows, cols = true_board.shape\n\n    # Define the four corner coordinates\n    corners = [\n        (0, 0),\n        (0, cols - 1),\n        (rows - 1, 0),\n        (rows - 1, cols - 1)\n    ]\n\n    # Check each corner: we want a true ship (true_board > 0)\n    # that is still hidden in the partial board (partial_board == -1).\n    for r, c in corners:\n        if true_board[r, c] != 0 and partial_board[r, c] == -1:\n            return True\n\n    return False\n","name":"program_127","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"any ship touching that miss?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is at least one unrevealed ship tile\n    orthogonally adjacent to the most recently revealed miss.\n    We locate the revealed miss(es) in the partial_board by finding\n    cells marked 0 (water). For each such cell, we check its\n    up\/down\/left\/right neighbors; if any neighbor is a ship\n    in true_board (>0) and is still hidden in partial_board (-1),\n    we return True.\n    \"\"\"\n    # Find all revealed water cells\n    misses = np.argwhere(partial_board == 0)\n    # Check each miss\n    for r, c in misses:\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nr, nc = r + dr, c + dc\n            # Stay in bounds\n            if 0 <= nr < true_board.shape[0] and 0 <= nc < true_board.shape[1]:\n                # If there's a ship in the true board and it's still hidden\n                if true_board[nr, nc] > 0 and partial_board[nr, nc] == -1:\n                    return True\n    return False\n","name":"program_128","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"a1 corner?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A1 corresponds to row 0, column 0 in the numpy arrays.\n    # Return True if there's a ship (value > 0) at A1, False otherwise.\n    return bool(true_board[0, 0] > 0)\n","name":"program_129","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"does c row have a ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the zero\u2010based index for row 'C'\n    row_idx = ord('C') - ord('A')\n    # A ship tile in the true board is > 0\n    # A hidden tile in the partial board is == -1\n    # We return True if there's any hidden ship tile in row C\n    return np.any((true_board[row_idx, :] > 0) & (partial_board[row_idx, :] == -1))\n","name":"program_130","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"a8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert coordinate A8 to zero-based indices (row 0, column 7)\n    row_index = ord('A') - ord('A')  # 0\n    col_index = 8 - 1                # 7\n\n    # Check if the true board at A8 contains a ship (values 1\u20134)\n    return true_board[row_index, col_index] != 0\n","name":"program_131","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"close to orange?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # 1) find all the still\u2010hidden ship squares\n    hidden_ship = (partial_board == -1) & (true_board > 0)\n    hidden_pos = np.argwhere(hidden_ship)   # list of (r,c)\n    if hidden_pos.size == 0:\n        # no hidden ship squares => nothing to be 'close' to\n        return False\n\n    # 2) precompute positions of each ship type\n    ship_positions = {\n        ship: np.argwhere(true_board == ship)\n        for ship in (1,2,3,4)\n    }\n\n    # 3) for each hidden square, find its nearest ship\u2010type\n    def min_dist(pt, pts):\n        # Manhattan\n        return np.min(np.abs(pts - pt).sum(axis=1)) if pts.size else np.inf\n\n    # keep track of how many hidden squares are closest to orange\n    orange_closest = 0\n    for h in hidden_pos:\n        # compute per\u2010type distances\n        dists = {ship: min_dist(h, ship_positions[ship]) for ship in ship_positions}\n        # which ship has the minimal distance?\n        nearest = min(dists, key=dists.get)\n        if nearest == 4:   # 4 == orange\n            orange_closest += 1\n\n    # if any hidden square is closest to orange, we say \"Yes\"\n    return orange_closest > 0\n","name":"program_132","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify which ship the captain is currently probing:\n    # find all revealed ship\u2010tiles and count per ship ID\n    revealed = partial_board > 0\n    ship_ids, counts = np.unique(partial_board[revealed], return_counts=True)\n    if len(ship_ids) == 0:\n        # no revealed ship pieces at all\n        return False\n    # assume the ship under investigation is the one with the fewest revealed pieces\n    target_id = ship_ids[np.argmin(counts)]\n    \n    # get all coordinates of that ship in the true board\n    coords = np.argwhere(true_board == target_id)\n    if coords.size == 0:\n        # no such ship on the true board\n        return False\n    \n    rows = coords[:, 0]\n    cols = coords[:, 1]\n    \n    # if all rows are the same, it's horizontal -> \"vertical?\" => False\n    if np.all(rows == rows[0]):\n        return False\n    # if all cols are the same, it's vertical -> \"vertical?\" => True\n    if np.all(cols == cols[0]):\n        return True\n    \n    # otherwise ambiguous; default to False\n    return False\n","name":"program_133","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # 1) Find which ship\u2010ID has been hit (any positive cell in partial_board)\n    hit_cells = partial_board > 0\n    if not np.any(hit_cells):\n        # No hits yet => can\u2019t ask about orientation\n        return False\n\n    # 2) If there's more than one ship\u2010ID present, pick the first\u2014\n    #    we assume the question refers to the newly hit ship.\n    ship_ids = np.unique(partial_board[hit_cells])\n    ship_id = ship_ids[0]\n\n    # 3) Gather all positions of that ship in the true board\n    positions = np.argwhere(true_board == ship_id)\n    # If it\u2019s only a single tile (shouldn\u2019t happen in standard Battleship), treat as not vertical\n    if positions.shape[0] < 2:\n        return False\n\n    # 4) Check if all column indices are the same\n    cols = positions[:, 1]\n    return np.all(cols == cols[0])\n","name":"program_134","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"how about h8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # The Captain is asking about tile H8:\n    # Row 'H' corresponds to index 7 (0-based), column '8' corresponds to index 7.\n    # If the true_board at (7,7) is nonzero, there's a ship there.\n    return true_board[7, 7] != 0\n","name":"program_135","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is orange ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Locate all coordinates of the orange ship (value 4) on the true board\n    rows, cols = np.where(true_board == 4)\n    \n    # If all row indices are the same, the ship is laid out horizontally\n    return np.all(rows == rows[0])\n","name":"program_136","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is last ship far away from other ships?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the only completely unrevealed ship (\"last ship\") on the board\n    is not adjacent (even diagonally) to any other ship.\n\n    We identify the last ship by finding which ship ID appears in true_board\n    but does not appear in partial_board. Then we compute the Chebyshev distance\n    between every cell of that last ship and every cell of all other ships.\n    If the minimum such distance is greater than 1, the last ship is \"far away\".\n    \"\"\"\n    # All ship IDs present on the true board (excluding water=0)\n    all_ships = set(np.unique(true_board)) - {0}\n    # Ship IDs that have at least one revealed tile in partial_board\n    revealed_ships = set(np.unique(partial_board)) - {-1, 0}\n    # The last (completely hidden) ship is the one in all_ships not in revealed_ships\n    hidden_ships = all_ships - revealed_ships\n    if not hidden_ships:\n        # No fully hidden ship remains; question is moot => answer False\n        return False\n\n    # We assume there's exactly one \"last ship\"\n    last_ship_id = hidden_ships.pop()\n\n    # Coordinates of the last ship's cells\n    last_coords = np.argwhere(true_board == last_ship_id)\n    # Coordinates of all other ships\n    other_coords = np.argwhere((true_board > 0) & (true_board != last_ship_id))\n\n    # Compute the minimum Chebyshev distance between any cell of last ship and any other ship cell\n    # Chebyshev distance >1 means no touching even diagonally\n    min_dist = np.inf\n    for (r1, c1) in last_coords:\n        # Vectorized Chebyshev distances to all other ship cells\n        d_row = np.abs(other_coords[:, 0] - r1)\n        d_col = np.abs(other_coords[:, 1] - c1)\n        cheb = np.maximum(d_row, d_col)\n        cur_min = cheb.min() if cheb.size > 0 else np.inf\n        if cur_min < min_dist:\n            min_dist = cur_min\n        # Early exit if we already see adjacency\n        if min_dist <= 1:\n            return False\n\n    # If the closest approach is more than 1, the last ship is far away\n    return True\n","name":"program_137","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it close to green?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # find all green ship coordinates\n    green_cells = np.argwhere(true_board == 2)\n    # find all unrevealed ship coordinates (any ship>0 that partial still -1)\n    unseen_ship_cells = np.argwhere((true_board > 0) & (partial_board == -1))\n    \n    # for each green cell, see if any unseen ship cell is in its 8-neighborhood\n    for gy, gx in green_cells:\n        # compute vector differences\n        diffs = unseen_ship_cells - np.array([gy, gx])\n        # check if any diff has both coords in [-1,0,1] but not (0,0)\n        # equivalently max(abs(dy),abs(dx)) == 1\n        if np.any(np.max(np.abs(diffs), axis=1) == 1):\n            return True\n    \n    return False\n","name":"program_138","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are other ships touching green or orange?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any ship other than green (2) or orange (4)\n    that is adjacent (including diagonals) to any green or orange tile.\n    \"\"\"\n    # IDs for ships we care about\n    target_ships = {2, 4}      # green and orange\n    other_ships  = {1, 3}      # red and purple\n\n    # Directions to check for adjacency (8 neighbors)\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  ( 0, -1),          ( 0, 1),\n                  ( 1, -1), ( 1, 0), ( 1, 1)]\n\n    rows, cols = true_board.shape\n\n    for r in range(rows):\n        for c in range(cols):\n            if true_board[r, c] in target_ships:\n                # Check all neighbors\n                for dr, dc in directions:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        if true_board[nr, nc] in other_ships:\n                            return True\n    return False\n","name":"program_139","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any ships in A or B row?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows A and B correspond to indices 0 and 1\n    # We check for any tile in those rows where:\n    #   - true_board > 0 (there is a ship)\n    #   - partial_board == -1 (it is still hidden)\n    mask_ships = (true_board[:2, :] > 0) & (partial_board[:2, :] == -1)\n    return bool(np.any(mask_ships))\n","name":"program_140","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is red verticle?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Locate all cells of the red ship (denoted by 1)\n    red_positions = np.argwhere(true_board == 1)\n    # If there are fewer than 2 cells, we can't determine orientation; assume not vertical\n    if red_positions.shape[0] < 2:\n        return False\n    # Extract row indices and column indices\n    rows, cols = red_positions[:, 0], red_positions[:, 1]\n    # The ship is vertical if all column indices are the same\n    return np.all(cols == cols[0])\n","name":"program_141","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any ships in C or D row?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows C and D correspond to indices 2 and 3 (0-based indexing).\n    rows_to_check = [2, 3]\n    \n    # Extract the true and partial board slices for rows C and D\n    true_slice = true_board[rows_to_check, :]\n    partial_slice = partial_board[rows_to_check, :]\n    \n    # A ship tile is any cell where true_board > 0.\n    # An unrevealed tile in partial_board is indicated by -1.\n    # We want to know if there's any cell in C or D that is a ship\n    # on the true board AND still hidden on the partial board.\n    ships_hidden = (true_slice > 0) & (partial_slice == -1)\n    \n    return bool(np.any(ships_hidden))\n","name":"program_142","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Does A B C or D Hold a ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in rows A, B, C, or D; otherwise False.\n    Rows A\u2013D correspond to indices 0\u20133 in the numpy arrays.\n    \"\"\"\n    # Select rows A\u2013D (indices 0 through 3)\n    tb_sub = true_board[0:4, :]\n    pb_sub = partial_board[0:4, :]\n    \n    # A ship tile is any true_board cell > 0\n    is_ship = tb_sub > 0\n    # An unrevealed tile is any partial_board cell == -1\n    is_hidden = pb_sub == -1\n    \n    # Check if any cell in A\u2013D is both a ship and still hidden\n    return np.any(is_ship & is_hidden)\n","name":"program_143","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Answers keep getting timed out is there a ship in A or B row?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in row A or row B (indices 0 or 1), otherwise False.\n    \"\"\"\n    # Select rows A and B (0 and 1)\n    rows_ab = true_board[0:2, :]\n    partial_ab = partial_board[0:2, :]\n    \n    # A tile is an unrevealed ship if true_board > 0 and partial_board == -1\n    unrevealed_ship = (rows_ab > 0) & (partial_ab == -1)\n    \n    # Return True if any such tile exists\n    return bool(np.any(unrevealed_ship))\n","name":"program_144","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the ship verticle?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine if the (only) still\u2010unrevealed ship is placed vertically.\n    We identify which ship still has hidden segments by comparing true_board\n    to partial_board, then inspect its coordinates.\n    \"\"\"\n    # Mask of tiles that are part of a ship in the true board but still hidden\n    hidden_ship_tiles = (true_board > 0) & (partial_board == -1)\n    \n    # Which ship IDs still have at least one hidden tile?\n    ship_ids = np.unique(true_board[hidden_ship_tiles])\n    \n    # If there isn't exactly one ship still hidden, we cannot answer definitively.\n    # In that case we default to False (i.e. \"No\").\n    if ship_ids.size != 1:\n        return False\n    \n    ship_id = ship_ids[0]\n    \n    # Get all coordinates of this ship on the true board\n    coords = np.argwhere(true_board == ship_id)\n    # coords is an array of (row_index, col_index) pairs\n    \n    # If all column indices are the same, it's vertical.\n    # If all row indices are the same, it's horizontal.\n    all_cols_equal = np.all(coords[:, 1] == coords[0, 1])\n    \n    return bool(all_cols_equal)\n","name":"program_145","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is orange verticle?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the orange ship (value 4) on the true board\n    orange_positions = np.argwhere(true_board == 4)\n    \n    # If all of the positions share the same column index, it's vertical\n    # argwhere gives (row, col) pairs; we look at the col component\n    cols = orange_positions[:, 1]\n    is_vertical = np.all(cols == cols[0])\n    \n    return bool(is_vertical)\n","name":"program_146","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the ship more in D E and F and G?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines whether there is any unrevealed ship tile in rows D, E, F, or G.\n\n    Rows are 0-indexed as A=0, B=1, \u2026, H=7. We check rows 3,4,5,6 for any cell\n    where the true_board has a ship (>0) but the partial_board is still hidden (-1).\n    \"\"\"\n    # row indices for D, E, F, G\n    target_rows = [3, 4, 5, 6]\n\n    # extract the sub\u2010matrices for those rows\n    true_sub = true_board[target_rows, :]\n    partial_sub = partial_board[target_rows, :]\n\n    # check if any position has a ship in true_board and is still hidden in partial_board\n    return np.any((true_sub > 0) & (partial_sub == -1))\n","name":"program_147","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it to the left of E3?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines whether the still-hidden ship (the vertical ship occupying rows D, E, F, G)\n    lies to the left of the tile E3 (i.e., in column 1 or 2).\n    \"\"\"\n    # Rows D, E, F, G correspond to indices 3, 4, 5, 6 (0-based).\n    target_rows = [3, 4, 5, 6]\n    # E3 is column 3 (1-based), which is index 2 in 0-based.\n    col_limit = 2\n\n    # Identify cells that are ships in the true board but still hidden in the partial board.\n    hidden_ship_cells = (true_board > 0) & (partial_board == -1)\n\n    # Restrict to the rows D\u2013G.\n    hidden_in_target_rows = hidden_ship_cells[target_rows, :]\n\n    # Check if any of those hidden ship cells lie to the left of column index 2.\n    return bool(np.any(hidden_in_target_rows[:, :col_limit]))\n","name":"program_148","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it to the left of green E6?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the as\u2010yet\u2010undiscovered ship lies entirely to the left\n    of the green ship's column (i.e. to the left of green E6 in the current board),\n    otherwise False.\n    \"\"\"\n    # 1) Locate the green ship in the full board:\n    green_cells = np.argwhere(true_board == 2)\n    if green_cells.size == 0:\n        # no green ship on the board \u2192 question is moot\n        return False\n    # All green cells share the same column; pick the first\n    green_col = green_cells[0, 1]\n    \n    # 2) Find which ship is still (partially or wholly) hidden:\n    #    A ship is \"hidden\" if the number of its tiles in partial_board\n    #    is strictly less than in true_board.\n    ship_ids = set(np.unique(true_board))\n    ship_ids.discard(0)  # drop the water\n    \n    for ship_id in ship_ids:\n        total_tiles = np.sum(true_board == ship_id)\n        revealed_tiles = np.sum(partial_board == ship_id)\n        if revealed_tiles < total_tiles:\n            # This is the ship the Captain is still hunting.\n            hidden_ship_cells = np.argwhere(true_board == ship_id)\n            # Check if every column of this ship is strictly less than green_col\n            return np.all(hidden_ship_cells[:, 1] < green_col)\n    \n    # If we found no partially hidden ship, default to False\n    return False\n","name":"program_149","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship in G or H row?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows A\u2013H correspond to indices 0\u20137, so G\u21926, H\u21927\n    rows_to_check = [6, 7]\n    # For each of those rows, see if there's any position where\n    # true_board has a ship (>0) but partial_board is still hidden (-1).\n    for r in rows_to_check:\n        if np.any((true_board[r] > 0) & (partial_board[r] == -1)):\n            return True\n    return False\n","name":"program_150","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"good job. anything in the center?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine if there are any still\u2010hidden ship tiles in the 'center' of the board.\n    We define the center region generically as the middle half of the board in both\n    dimensions.  For an 8\u00d78 board, that becomes rows 2..5 and cols 2..5 (0\u2010based).\n    \"\"\"\n    # Compute the slice indices for the middle half\n    n_rows, n_cols = true_board.shape\n    row_start = n_rows \/\/ 4\n    row_end   = 3 * n_rows \/\/ 4\n    col_start = n_cols \/\/ 4\n    col_end   = 3 * n_cols \/\/ 4\n    \n    # Extract the center sub\u2010boards\n    center_true    = true_board[row_start:row_end, col_start:col_end]\n    center_partial = partial_board[row_start:row_end, col_start:col_end]\n    \n    # A ship tile is indicated by > 0 in true_board, and hidden tiles are -1 in partial_board.\n    # We ask: is there any location in that center block which (a) is a ship in true_board,\n    # and (b) remains hidden in partial_board?\n    unseen_ship = (center_true > 0) & (center_partial == -1)\n    return bool(np.any(unseen_ship))\n","name":"program_151","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"anything in f g h?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in rows F, G, or H.\n    Rows A\u2013H correspond to indices 0\u20137, so F, G, H are 5, 6, and 7.\n    \"\"\"\n    # Indices for rows F, G, H\n    rows = [5, 6, 7]\n    # A tile is an unrevealed ship tile if true_board > 0 (ship) and partial_board == -1 (hidden)\n    unrevealed_ships = (true_board[rows] > 0) & (partial_board[rows] == -1)\n    return bool(np.any(unrevealed_ships))\n","name":"program_152","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"anything else 7 8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to know if there are any *unrevealed* ship tiles\n    # in columns 7 or 8 (zero\u2010based indices 6 and 7).\n    # A tile is unrevealed if partial_board == -1, and it's a ship if true_board > 0.\n    \n    # Extract just the two columns of interest\n    cols = [6, 7]\n    true_cols = true_board[:, cols]\n    part_cols = partial_board[:, cols]\n    \n    # Check for any position where there's a ship (true_board > 0)\n    # and it is still hidden (partial_board == -1)\n    return bool(np.any((true_cols > 0) & (part_cols == -1)))\n","name":"program_153","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"touching red?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if any non\u2010red ship tile (value > 1) is adjacent\n    (including diagonally) to any red tile (value == 1) on the true_board.\n    \"\"\"\n    # Offsets for all 8 neighboring cells\n    neighbors = [(-1, -1), (-1, 0), (-1, 1),\n                 ( 0, -1),          ( 0, 1),\n                 ( 1, -1), ( 1, 0), ( 1, 1)]\n    \n    rows, cols = true_board.shape\n    # Find all coordinates of red ship tiles\n    red_positions = np.argwhere(true_board == 1)\n    \n    for (i, j) in red_positions:\n        for di, dj in neighbors:\n            ni, nj = i + di, j + dj\n            # Check bounds\n            if 0 <= ni < rows and 0 <= nj < cols:\n                val = true_board[ni, nj]\n                # If it's a ship that's not red, we've found a touching ship\n                if val > 1:\n                    return True\n    return False\n","name":"program_154","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all ship\u2010types on the true board (codes 1\u20134)\n    ship_types = np.unique(true_board)\n    ship_types = ship_types[ship_types > 0]\n\n    # Determine which ship(s) are not yet fully discovered\n    incomplete = []\n    for t in ship_types:\n        total_tiles = np.count_nonzero(true_board == t)\n        revealed_tiles = np.count_nonzero(partial_board == t)\n        if revealed_tiles < total_tiles:\n            incomplete.append(t)\n\n    # If exactly one ship remains incomplete, check its orientation\n    if len(incomplete) == 1:\n        t = incomplete[0]\n        coords = np.argwhere(true_board == t)\n        rows, cols = coords[:, 0], coords[:, 1]\n        # Vertical if all columns are the same\n        return bool(np.all(cols == cols[0]))\n    \n    # Fallback: if ambiguous or nothing left, answer False\n    return False\n","name":"program_155","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the incompletely revealed ship on the partial_board\n    is oriented vertically in the true_board.\n    We identify the ship ID (1\u20134) that has at least one revealed tile\n    and is not yet fully revealed, then check its full true_board positions.\n    If all of its true_board tiles lie in the same column, it's vertical.\n    \"\"\"\n    # Ship IDs range from 1 (Red) to 4 (Orange)\n    for ship_id in [1, 2, 3, 4]:\n        # Locations of this ship on the true board\n        true_locs = np.argwhere(true_board == ship_id)\n        # Locations of this ship already revealed on the partial board\n        seen_locs = np.argwhere(partial_board == ship_id)\n        # If we've seen part of it but not the entire ship, this is our target\n        if seen_locs.size > 0 and seen_locs.shape[0] < true_locs.shape[0]:\n            # Extract the column indices of the full ship\n            cols = true_locs[:, 1]\n            # If all columns are identical, it's vertical\n            return np.all(cols == cols[0])\n    # If no partially revealed ship is found, default to False\n    return False\n","name":"program_156","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"anything in f g h, 1 2 3?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows F, G, H correspond to indices 5, 6, 7\n    # Columns 1, 2, 3 correspond to indices 0, 1, 2\n    rows = [5, 6, 7]\n    cols = [0, 1, 2]\n\n    # Extract the sub\u2010region from both boards\n    true_sub = true_board[np.ix_(rows, cols)]\n    partial_sub = partial_board[np.ix_(rows, cols)]\n\n    # A hidden ship tile is one where true_board > 0 (a ship) and partial_board == -1 (hidden)\n    hidden_ship = (true_sub > 0) & (partial_sub == -1)\n\n    return bool(np.any(hidden_ship))\n","name":"program_157","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"last ship in upper left quarter?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is any unrevealed ship tile in the upper-left quarter\n    (rows A\u2013D \u2192 indices 0\u20133, columns 1\u20134 \u2192 indices 0\u20133), otherwise False.\n    \"\"\"\n    # extract the sub\u2010board corresponding to rows 0\u20133 and cols 0\u20133\n    sub_true = true_board[0:4, 0:4]\n    sub_partial = partial_board[0:4, 0:4]\n    \n    # a ship tile is any true_board cell > 0\n    # an unrevealed tile is any partial_board cell == -1\n    hidden_ship_mask = (sub_true > 0) & (sub_partial == -1)\n    \n    # if any such tile exists, answer is True (i.e. \"Yes\")\n    return bool(np.any(hidden_ship_mask))\n","name":"program_158","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it touching any other ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # all ship IDs on the board (exclude hidden:-1 and water:0)\n    ship_ids = set(np.unique(true_board)) - {0, -1}\n    # find which ship IDs have not yet been revealed at all\n    undiscovered = [s for s in ship_ids if not np.any(partial_board == s)]\n    # if there's not exactly one completely hidden ship, we cannot\n    # unambiguously answer \"the last ship\", so default to False\n    if len(undiscovered) != 1:\n        return False\n    ship = undiscovered[0]\n    # neighbor offsets for orthogonal adjacency\n    neighbors = [(-1,0),(1,0),(0,-1),(0,1)]\n    rows, cols = true_board.shape\n    # for every cell of that ship in the true board\n    for i,j in zip(*np.where(true_board == ship)):\n        # check each orthogonal neighbor\n        for di,dj in neighbors:\n            ni, nj = i+di, j+dj\n            if 0 <= ni < rows and 0 <= nj < cols:\n                neighbor_id = true_board[ni, nj]\n                # if that neighbor is a different ship (>0 and != ship)\n                if neighbor_id > 0 and neighbor_id != ship:\n                    return True\n    # no touching found\n    return False\n","name":"program_159","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"would you say its by the edge?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if any of the still-hidden ship tiles lie on the outer border\n    of the board (i.e. row 0, row 7, col 0 or col 7), False otherwise.\n    \"\"\"\n    # Identify all hidden ship tiles: positions where partial_board is hidden (-1)\n    # but true_board indicates a ship (>0).\n    hidden_ship_tiles = (partial_board == -1) & (true_board > 0)\n    \n    # If there are no hidden ship tiles, then obviously none are on the edge.\n    if not np.any(hidden_ship_tiles):\n        return False\n\n    # Get the row and column indices of those hidden ship tiles.\n    rows, cols = np.nonzero(hidden_ship_tiles)\n    max_row, max_col = true_board.shape[0] - 1, true_board.shape[1] - 1\n\n    # Check if any of these tiles is on the outer border.\n    on_top_edge    = rows == 0\n    on_bottom_edge = rows == max_row\n    on_left_edge   = cols == 0\n    on_right_edge  = cols == max_col\n\n    return np.any(on_top_edge | on_bottom_edge | on_left_edge | on_right_edge)\n","name":"program_160","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"anything a b, 7 8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows A, B correspond to indices 0 and 1\n    rows = [0, 1]\n    # Columns 7, 8 correspond to indices 6 and 7\n    cols = [6, 7]\n    # Extract the relevant sub\u2010arrays\n    sub_true = true_board[np.ix_(rows, cols)]\n    sub_partial = partial_board[np.ix_(rows, cols)]\n    # We're looking for any tile that is a ship in the true board (value > 0)\n    # but still hidden in the partial board (value == -1)\n    ship_unrevealed = (sub_true > 0) & (sub_partial == -1)\n    return bool(np.any(ship_unrevealed))\n","name":"program_161","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"red vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the Red ship (denoted by 1 in true_board) is oriented vertically,\n    False otherwise.\n    \"\"\"\n    # Find all the coordinates of the red ship on the true board\n    red_coords = np.argwhere(true_board == 1)\n    \n    # If there are fewer than 2 red\u2010ship tiles, we can't call it \"vertical\"\n    if red_coords.shape[0] < 2:\n        return False\n    \n    # red_coords is an array of [row, col] pairs. \n    # The ship is vertical if all column indices are the same.\n    cols = red_coords[:, 1]\n    return np.all(cols == cols[0])\n","name":"program_162","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it on a or h?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed ship tile in row A or row H,\n    i.e. in true_board we have a ship (>0) and in partial_board it's still hidden (-1).\n    \"\"\"\n    # Build a mask of all unrevealed ship tiles\n    unrevealed_ship = (true_board > 0) & (partial_board == -1)\n    # Rows A and H correspond to indices 0 and 7\n    return np.any(unrevealed_ship[[0, 7], :])\n","name":"program_163","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"lol that one was hard I was screaming at the screen gj bro. Is there a ship in quad A-C, 1-3?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any *unrevealed* ship tile within the sub\u2010grid\n    spanning rows A\u2013C and columns 1\u20133, otherwise False.\n    \"\"\"\n    # Rows A\u2013C correspond to indices 0,1,2; columns 1\u20133 correspond to indices 0,1,2\n    sub_true    = true_board[0:3, 0:3]\n    sub_partial = partial_board[0:3, 0:3]\n    \n    # A ship tile is >0 in true_board. A tile is unrevealed if == -1 in partial_board.\n    # We only count ship tiles that are still hidden to the Captain.\n    hidden_ship_tiles = (sub_true > 0) & (sub_partial == -1)\n    \n    return bool(np.any(hidden_ship_tiles))\n","name":"program_164","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the last ship in ABCD 5678?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in rows A\u2013D and\n    columns 5\u20138; otherwise returns False.\n    \"\"\"\n    # A\u2013D correspond to row indices 0\u20133, 5\u20138 correspond to col indices 4\u20137\n    # A tile is an unrevealed ship tile if true_board>0 and partial_board==-1.\n    unrevealed = (true_board > 0) & (partial_board == -1)\n    return bool(np.any(unrevealed[0:4, 4:8]))\n","name":"program_165","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it touching orange?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if any unrevealed ship tile is orthogonally adjacent\n    to any orange ship tile (value 4) on the true_board.\n    \"\"\"\n    rows, cols = true_board.shape\n    # Orthogonal directions: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    for r in range(rows):\n        for c in range(cols):\n            # Is this a hidden ship tile?\n            if true_board[r, c] > 0 and partial_board[r, c] == -1:\n                # Check its four neighbors\n                for dr, dc in directions:\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < rows and 0 <= nc < cols:\n                        if true_board[nr, nc] == 4:\n                            return True\n    return False\n","name":"program_166","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship D-F, 1-3?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert the queried rows D\u2013F to zero-based indices 3\u20135\n    row_start = ord('D') - ord('A')    # 3\n    row_end   = ord('F') - ord('A')    # 5\n    \n    # Convert the queried columns 1\u20133 to zero-based indices 0\u20132\n    col_start = 1 - 1  # 0\n    col_end   = 3 - 1  # 2\n\n    # Slice out the region D\u2013F, 1\u20133 on both boards\n    true_region    = true_board [row_start:row_end+1, col_start:col_end+1]\n    partial_region = partial_board[row_start:row_end+1, col_start:col_end+1]\n\n    # A ship is present and still hidden if true_region > 0 and partial_region == -1\n    hidden_ship_mask = (true_region > 0) & (partial_region == -1)\n    \n    return bool(hidden_ship_mask.any())\n","name":"program_167","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it touching any of the other ships?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the one ship that has not yet been touched on partial_board\n    is orthogonally adjacent to any other ship on the true_board.\n    \"\"\"\n\n    nrows, ncols = true_board.shape\n    # Find all ship\u2010IDs present on the true board (exclude water = 0)\n    ship_ids = [sid for sid in np.unique(true_board) if sid != 0]\n\n    # Identify the \"untouched\" ship: its every cell is still hidden (partial_board == -1)\n    untouched_id = None\n    for sid in ship_ids:\n        # coordinates of this ship on true_board\n        coords = np.argwhere(true_board == sid)\n        # check if all those coords are still hidden in partial_board\n        if all(partial_board[r, c] == -1 for r, c in coords):\n            untouched_id = sid\n            break\n\n    # If we didn't find any untouched ship, answer False by default\n    if untouched_id is None:\n        return False\n\n    # Offsets for orthogonal neighbors\n    neighbors = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    # Check each cell of the untouched ship\n    for (r, c) in np.argwhere(true_board == untouched_id):\n        for dr, dc in neighbors:\n            rr, cc = r + dr, c + dc\n            # skip out\u2010of\u2010bounds\n            if not (0 <= rr < nrows and 0 <= cc < ncols):\n                continue\n            # if neighbor is a ship and not part of the untouched one, they touch\n            if true_board[rr, cc] != 0 and true_board[rr, cc] != untouched_id:\n                return True\n\n    # No touching found\n    return False\n","name":"program_168","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship F-H, 6-8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows F-H correspond to indices 5,6,7 (0-based: A=0,\u2026,H=7)\n    # Columns 6-8 correspond to indices 5,6,7 (0-based: 1=0,\u2026,8=7)\n    region_true = true_board[5:8, 5:8]\n    region_partial = partial_board[5:8, 5:8]\n    \n    # A tile contains an unrevealed ship if it's >0 on the true board\n    # and still hidden (-1) on the partial board.\n    unrevealed_ship_tiles = (region_true > 0) & (region_partial == -1)\n    \n    return bool(unrevealed_ship_tiles.any())\n","name":"program_169","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there ships A-C, 6-8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # rows A\u2013C are indices 0,1,2; cols 6\u20138 are indices 5,6,7\n    sub_true = true_board[0:3, 5:8]\n    sub_partial = partial_board[0:3, 5:8]\n    # Look for any tile where there's a ship in true_board (>0)\n    # but it's still hidden in partial_board (== -1)\n    return np.any((sub_true > 0) & (sub_partial == -1))\n","name":"program_170","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any ships in whole column of 6?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Column \"6\" corresponds to index 5 in 0-based indexing\n    col_idx = 5\n    \n    # A tile is an unrevealed ship segment if:\n    #  1) true_board has a ship (value > 0) at that position\n    #  2) partial_board still marks it as hidden (-1)\n    ship_mask   = true_board[:, col_idx] > 0\n    hidden_mask = partial_board[:, col_idx] == -1\n    \n    # If any tile in column 6 satisfies both conditions, return True\n    return bool(np.any(ship_mask & hidden_mask))\n","name":"program_171","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Orange vert?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the orange ship (denoted by 4) is oriented vertically,\n    i.e., all its tiles share the same column index.\n    \"\"\"\n    # Find all (row, col) coordinates of the orange ship\n    orange_coords = np.argwhere(true_board == 4)\n    \n    # If there are fewer than 2 tiles found, it can't form a valid ship orientation\n    if orange_coords.shape[0] < 2:\n        return False\n    \n    # Extract the column indices of all orange tiles\n    cols = orange_coords[:, 1]\n    \n    # It's vertical if all column indices are the same\n    return np.all(cols == cols[0])\n","name":"program_172","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships touching the sides?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is at least one unrevealed ship\u2010tile\n    on any of the four outer edges of the board.\n    Otherwise return False.\n    \"\"\"\n    # Create a boolean mask of the same shape as the board,\n    # marking True for any cell on the outermost rows or columns.\n    border_mask = np.zeros_like(true_board, dtype=bool)\n    border_mask[0, :] = True\n    border_mask[-1, :] = True\n    border_mask[:, 0] = True\n    border_mask[:, -1] = True\n\n    # Identify ship cells in the true board (values > 0)\n    ship_mask = true_board > 0\n    # Identify still\u2010hidden cells in the partial board (-1)\n    hidden_mask = partial_board == -1\n\n    # Check if any cell is simultaneously on the border, is a ship,\n    # and is still hidden. If so, answer \"Yes\" (True).\n    return bool(np.any(border_mask & ship_mask & hidden_mask))\n","name":"program_173","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Do I keep going to the right of green B2?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine if there is an unrevealed green-ship tile immediately to the right\n    of any currently revealed green tile.\n\n    In this variant, green ships are marked with '2'. Hidden tiles are '-1'.\n    We scan the partial_board for any revealed green tile (value == 2).\n    For each such tile at (r, c), we check the tile to its right, (r, c+1),\n    and if it's still hidden in partial_board (== -1) but truly part of the\n    green ship in true_board (== 2), we return True. Otherwise False.\n    \"\"\"\n    # Find all revealed green-ship tiles\n    green_locs = np.argwhere(partial_board == 2)\n    \n    # Board dimensions\n    n_rows, n_cols = partial_board.shape\n    \n    # Check the tile immediately to the right of each revealed green tile\n    for r, c in green_locs:\n        right_col = c + 1\n        if right_col < n_cols:\n            if partial_board[r, right_col] == -1 and true_board[r, right_col] == 2:\n                return True\n    \n    return False\n","name":"program_174","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there ships in G or H at all?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there are any unrevealed ship tiles in rows G or H,\n    otherwise return False.\n    \n    We treat row A as index 0, B as 1, ..., G as 6, H as 7. A tile is considered\n    \"unrevealed ship\" if true_board > 0 (i.e., a ship is there) and partial_board\n    == -1 (i.e., it is still hidden to the Captain).\n    \"\"\"\n    # Extract rows G (index 6) and H (index 7)\n    true_sub = true_board[6:8, :]\n    partial_sub = partial_board[6:8, :]\n    \n    # Check for any tile where there's a ship in the true board but it's still hidden\n    unrevealed_ship_mask = (true_sub > 0) & (partial_sub == -1)\n    return np.any(unrevealed_ship_mask)\n","name":"program_175","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"nice! good job. uhhhh anything touching a side?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # build a mask covering the four edges\n    edge_mask = np.zeros_like(true_board, dtype=bool)\n    edge_mask[0, :] = True       # top edge\n    edge_mask[-1, :] = True      # bottom edge\n    edge_mask[:, 0] = True       # left edge\n    edge_mask[:, -1] = True      # right edge\n\n    # find cells that are ships (>0), still hidden (-1 in partial_board), and on an edge\n    hidden_ship_on_edge = (true_board > 0) & (partial_board == -1) & edge_mask\n\n    # return True if any such cell exists\n    return bool(np.any(hidden_ship_on_edge))\n","name":"program_176","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"anything in the center?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed ship tile in the central region\n    of the board, False otherwise.\n    \"\"\"\n    # Determine the size of the board\n    n_rows, n_cols = true_board.shape\n\n    # Identify center row indices\n    if n_rows % 2 == 0:\n        mid_row_indices = [n_rows \/\/ 2 - 1, n_rows \/\/ 2]\n    else:\n        mid_row_indices = [n_rows \/\/ 2]\n\n    # Identify center column indices\n    if n_cols % 2 == 0:\n        mid_col_indices = [n_cols \/\/ 2 - 1, n_cols \/\/ 2]\n    else:\n        mid_col_indices = [n_cols \/\/ 2]\n\n    # Slice out the central region\n    center_true = true_board[np.ix_(mid_row_indices, mid_col_indices)]\n    center_partial = partial_board[np.ix_(mid_row_indices, mid_col_indices)]\n\n    # A ship tile is any true_board cell > 0.\n    # An unrevealed tile in partial_board is marked by -1.\n    # We want to know if any such ship tile remains hidden in the center.\n    unrevealed_ship_mask = (center_true > 0) & (center_partial == -1)\n\n    return bool(np.any(unrevealed_ship_mask))\n","name":"program_177","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Locate any revealed ship tiles in the partial board\n    hit_mask = (partial_board != -1) & (true_board > 0)\n    # If no ship has been hit, we cannot say it's vertical\n    if not np.any(hit_mask):\n        return False\n\n    # Determine which ship was hit\n    ship_id = np.unique(true_board[hit_mask])[0]\n\n    # Find all the coordinates of that ship on the true board\n    coords = np.argwhere(true_board == ship_id)\n    # coords is an array of (row, col) pairs\n\n    # The ship is vertical if all its column indices are the same\n    unique_cols = np.unique(coords[:, 1])\n    return unique_cols.size == 1\n","name":"program_178","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"anything touching orange?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is any unrevealed ship tile that touches\n    (side-adjacent to) an orange ship tile (value 4), False otherwise.\n    \"\"\"\n    # Find all coordinates of orange tiles on the true board\n    orange_coords = np.argwhere(true_board == 4)\n    \n    # Directions for side\u2010adjacency (up, down, left, right)\n    neighbors = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    \n    rows, cols = true_board.shape\n    for r, c in orange_coords:\n        for dr, dc in neighbors:\n            nr, nc = r + dr, c + dc\n            # Check bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                # If that neighbor is still hidden on the partial board\n                # and it is actually a ship tile on the true board\n                if partial_board[nr, nc] == -1 and true_board[nr, nc] > 0:\n                    return True\n    return False\n","name":"program_179","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"g-h?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A mask of all unrevealed ship tiles\n    hidden_ships = (partial_board == -1) & (true_board > 0)\n    # Check rows G (index 6) or H (index 7)\n    return bool(hidden_ships[6, :].any() or hidden_ships[7, :].any())\n","name":"program_180","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"1-4?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We interpret \"1-4?\" as asking whether there are any unrevealed ship tiles\n    # in columns 1 through 4 (0-based indices 0 to 3).\n    # Find positions in those columns where the partial board is still hidden (-1)\n    # but the true board has a ship (>0).\n    hidden = (partial_board[:, 0:4] == -1)\n    ship   = (true_board[:,  0:4] >  0)\n    return bool(np.any(hidden & ship))\n","name":"program_181","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"touching edge?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all unrevealed tiles that actually contain ship segments\n    unrevealed_ship = (partial_board == -1) & (true_board > 0)\n\n    # Get their row and column indices\n    rows, cols = np.where(unrevealed_ship)\n\n    # Check if any of these lie on the border of the board\n    max_row, max_col = true_board.shape[0] - 1, true_board.shape[1] - 1\n    on_edge = (rows == 0) | (rows == max_row) | (cols == 0) | (cols == max_col)\n\n    return bool(np.any(on_edge))\n","name":"program_182","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"anything touching green?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there exists any hidden ship tile (true_board > 0 and partial_board == -1)\n    that is edge-adjacent (up\/down\/left\/right) to a green ship tile (true_board == 2).\n    Otherwise returns False.\n    \"\"\"\n    n_rows, n_cols = true_board.shape\n    # Offsets for the four orthogonal directions\n    neighbors = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    \n    # Find all green-ship coordinates\n    green_positions = np.argwhere(true_board == 2)\n    \n    for i, j in green_positions:\n        for di, dj in neighbors:\n            ni, nj = i + di, j + dj\n            # Check bounds\n            if 0 <= ni < n_rows and 0 <= nj < n_cols:\n                # If the spot is hidden in partial_board and actually contains a ship in true_board\n                if partial_board[ni, nj] == -1 and true_board[ni, nj] > 0:\n                    return True\n    return False\n","name":"program_183","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"row 6?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # The Captain asked about \"row 6\", which (with rows A\u2013H mapped to indices 0\u20137)\n    # corresponds to index 5 in zero\u2010based numpy indexing.\n    row_idx = 5\n\n    # We want to know if there are any ship tiles in that row\n    # that remain hidden (i.e., true_board > 0 but partial_board == -1).\n    hidden_ships = (true_board[row_idx] > 0) & (partial_board[row_idx] == -1)\n\n    # Return True if any such tiles exist, False otherwise.\n    return bool(np.any(hidden_ships))\n","name":"program_184","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines if the currently targeted ship (the one with exactly one revealed\n    hit in partial_board) is oriented vertically by checking the true_board.\n    Returns True if vertical, False otherwise.\n    \"\"\"\n    # Identify ship types 1\u20134 that have exactly one tile revealed so far.\n    candidate_ships = [\n        ship for ship in (1, 2, 3, 4)\n        if np.sum(partial_board == ship) == 1\n    ]\n    # If there's not exactly one such ship, we cannot infer orientation.\n    if len(candidate_ships) != 1:\n        return False\n\n    ship = candidate_ships[0]\n    # Locate the single revealed tile of that ship.\n    r, c = np.argwhere(partial_board == ship)[0]\n\n    # Check directly above and below for another tile of the same ship.\n    # If found, the ship is vertical.\n    if r - 1 >= 0 and true_board[r - 1, c] == ship:\n        return True\n    if r + 1 < true_board.shape[0] and true_board[r + 1, c] == ship:\n        return True\n\n    # Otherwise, it's not vertical.\n    return False\n","name":"program_185","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"a-d?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in rows A through D (indices 0 to 3), otherwise False.\n    \"\"\"\n    # Slice out rows A\u2013D\n    true_slice = true_board[0:4, :]\n    partial_slice = partial_board[0:4, :]\n    \n    # A tile is an unrevealed ship if true_board>0 and partial_board is hidden (-1)\n    unrevealed_ship = (true_slice > 0) & (partial_slice == -1)\n    \n    return bool(np.any(unrevealed_ship))\n","name":"program_186","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"We killin it bro lets do this! LETS DO THIS! lol. Alright A - C , 1 - 4?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Check if there are any unrevealed ship tiles in the rectangle\n    from rows A to C (indices 0\u20132) and columns 1 to 4 (indices 0\u20133).\n    \"\"\"\n    # Extract the sub\u2010rectangle for rows A\u2013C and cols 1\u20134\n    sub_true = true_board[0:3, 0:4]\n    sub_partial = partial_board[0:3, 0:4]\n\n    # An unrevealed ship tile is where true_board > 0 and partial_board == -1\n    unrevealed_ships = (sub_true > 0) & (sub_partial == -1)\n\n    # Return True if any such tile exists\n    return bool(np.any(unrevealed_ships))\n","name":"program_187","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"F - H, 1 - 4?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in the sub\u2010region\n    spanning rows F\u2013H and columns 1\u20134, otherwise False.\n    \"\"\"\n    # Rows F, G, H correspond to indices 5, 6, 7\n    # Columns 1\u20134 correspond to indices 0, 1, 2, 3\n    sub_true    = true_board[5:8, 0:4]\n    sub_partial = partial_board[5:8, 0:4]\n\n    # A ship tile is any cell in true_board > 0.\n    # It's unrevealed if partial_board at that cell is -1.\n    unrevealed_ships = (sub_true > 0) & (sub_partial == -1)\n    \n    return bool(np.any(unrevealed_ships))\n","name":"program_188","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship in C?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the zero\u2010based index for row 'C'\n    row_idx = ord('C') - ord('A')\n    \n    # Identify which cells in row C are still hidden\n    hidden_cells = (partial_board[row_idx] == -1)\n    \n    # Identify which cells in row C actually contain a ship on the true board\n    ship_cells = (true_board[row_idx] > 0)\n    \n    # If there's any cell that's both hidden and a ship, answer True\n    return bool(np.any(hidden_cells & ship_cells))\n","name":"program_189","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Verticle?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the (currently revealed) ship is oriented vertically.\n    We look at any revealed ship\u2010hit in partial_board, then check in true_board\n    if that ship ID appears directly above or below the hit. If so, it's vertical.\n    \"\"\"\n    # Find all revealed ship hits (partial_board > 0)\n    hit_rows, hit_cols = np.where(partial_board > 0)\n    if hit_rows.size == 0:\n        # No hits yet; default to False\n        return False\n\n    # Pick the first revealed hit\n    r, c = hit_rows[0], hit_cols[0]\n    ship_id = true_board[r, c]\n    n_rows, n_cols = true_board.shape\n\n    # Check above\n    if r - 1 >= 0 and true_board[r - 1, c] == ship_id:\n        return True\n    # Check below\n    if r + 1 < n_rows and true_board[r + 1, c] == ship_id:\n        return True\n\n    # If neither neighbor matches, it's not vertical\n    return False\n","name":"program_190","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is orange vert?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the orange ship (denoted by 4)\n    positions = np.argwhere(true_board == 4)\n    # Extract the row indices and column indices\n    rows, cols = positions[:, 0], positions[:, 1]\n    # If all columns are identical, the ship is vertical\n    return np.unique(cols).size == 1\n","name":"program_191","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships in B?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'B' to index 1 (A->0, B->1, \u2026, H->7)\n    row_idx = ord('B') - ord('A')\n    # A tile is an unrevealed ship if true_board>0 and partial_board==-1\n    unrevealed_in_B = (true_board[row_idx] > 0) & (partial_board[row_idx] == -1)\n    return bool(np.any(unrevealed_in_B))\n","name":"program_192","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships left in H?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row H corresponds to index 7 (0-based indexing).\n    # We want to know if there are any ship tiles (>0 in true_board)\n    # that are still hidden (== -1 in partial_board) in that row.\n    row = 7\n    # Create a mask of positions that are ship tiles and still hidden\n    unrevealed_ship_tiles = (true_board[row, :] > 0) & (partial_board[row, :] == -1)\n    # If any such tile exists, the answer is True (Yes), otherwise False (No).\n    return bool(np.any(unrevealed_ship_tiles))\n","name":"program_193","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is Green Vert?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the green ship (denoted by 2)\n    coords = np.argwhere(true_board == 2)\n    # If there's fewer than 2 tiles, we cannot determine orientation:\n    if coords.shape[0] < 2:\n        return False\n    # Extract the row indices and column indices\n    rows, cols = coords[:, 0], coords[:, 1]\n    # The ship is vertical if all columns are the same and it spans multiple rows\n    is_vertical = np.all(cols == cols[0]) and (rows.max() > rows.min())\n    return bool(is_vertical)\n","name":"program_194","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any ships in F?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'F' to zero-based index\n    row_idx = ord('F') - ord('A')\n    # Find all ship tiles in that row\n    ship_tiles = true_board[row_idx] > 0\n    # Of those, find which ones are still hidden in the partial view\n    hidden_tiles = partial_board[row_idx] == -1\n    # If there is any hidden ship tile in row F, return True; otherwise False\n    return bool(np.any(ship_tiles & hidden_tiles))\n","name":"program_195","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any ships in E 5 - 8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map the row letter 'E' to a 0\u2010based index (A\u21920, B\u21921, \u2026, H\u21927)\n    row_idx = ord('E') - ord('A')\n    # Columns 5 through 8 correspond to indices 4 through 7\n    col_slice = slice(4, 8)\n    \n    # Identify hidden cells in that region\n    hidden = (partial_board[row_idx, col_slice] == -1)\n    # Identify ship cells in the true board in that region\n    ships = (true_board[row_idx, col_slice] > 0)\n    \n    # If any cell is both hidden and actually contains part of a ship, answer is True\n    return bool(np.any(hidden & ships))\n","name":"program_196","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any ships in columns 1?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert the human-readable column \"1\" to zero-based index 0\n    col_idx = 0\n    \n    # A ship tile is any true_board value > 0.\n    # We only care about those that are still hidden in partial_board (value == -1).\n    hidden_ship_in_col = (true_board[:, col_idx] > 0) & (partial_board[:, col_idx] == -1)\n    \n    # If any are True, there's at least one unrevealed ship tile in column 1.\n    return bool(np.any(hidden_ship_in_col))\n","name":"program_197","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any ships touching sides?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A hidden ship cell is one where the captain still sees -1\n    # but the true board has a ship (> 0).\n    hidden_ship = (partial_board == -1) & (true_board > 0)\n\n    # Check the four borders for any hidden ship cell\n    top_border    = hidden_ship[0, :]\n    bottom_border = hidden_ship[-1, :]\n    left_border   = hidden_ship[:, 0]\n    right_border  = hidden_ship[:, -1]\n\n    return bool(\n        np.any(top_border) or\n        np.any(bottom_border) or\n        np.any(left_border) or\n        np.any(right_border)\n    )\n","name":"program_198","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is last ship anywhere to the right of green in 4 - 8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify all ship IDs present on the true board (exclude water = 0)\n    all_ships = set(np.unique(true_board)) - {0}\n    # Identify which ships have already been hit\/revealed on the partial board\n    revealed = set(np.unique(partial_board)) - {0, -1}\n    # The \"last\" ship is the one that never appears on the partial board\n    remaining = all_ships - revealed\n    # If there's not exactly one remaining ship, we cannot answer definitively\n    if len(remaining) != 1:\n        return False\n    last_ship_id = remaining.pop()\n\n    # Find the green ship's columns (green is coded as 2)\n    green_rows, green_cols = np.where(true_board == 2)\n    if green_cols.size == 0:\n        # No green found => cannot determine \"to the right\"\n        return False\n    max_green_col = np.max(green_cols)\n\n    # Define the 0-based index range for columns 4 through 8 (i.e. indices 3..7)\n    min_query_col = 3\n    max_query_col = 7\n\n    # Locate all cells of the last ship\n    last_rows, last_cols = np.where(true_board == last_ship_id)\n    # Check if any part lies both within cols 4..8 and strictly to the right of the green ship\n    for c in last_cols:\n        if (c >= min_query_col) and (c <= max_query_col) and (c > max_green_col):\n            return True\n\n    return False\n","name":"program_199","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the green ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the green ship (denoted by 2)\n    coords = np.argwhere(true_board == 2)\n    \n    # If there's no green ship, answer False by default\n    if coords.size == 0:\n        return False\n    \n    # Extract the row indices and column indices\n    rows, cols = coords[:, 0], coords[:, 1]\n    \n    # The ship is vertical if all column indices are the same\n    return np.unique(cols).size == 1\n","name":"program_200","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the orange ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the orange ship (value 4) on true_board is oriented vertically,\n    otherwise returns False (i.e., it's horizontal).\n    \"\"\"\n    # Find all coordinates of the orange ship on the true board\n    orange_coords = np.argwhere(true_board == 4)\n    \n    # If there's fewer than 2 tiles, orientation is ambiguous; treat as not vertical\n    if orange_coords.shape[0] < 2:\n        return False\n    \n    # Check if all column indices are the same\n    # argwhere returns rows as [row_index, col_index]\n    cols = orange_coords[:, 1]\n    \n    # If all column indices match, it's vertical\n    return np.all(cols == cols[0])\n","name":"program_201","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the purple ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the purple ship (encoded as 3)\n    positions = np.argwhere(true_board == 3)\n    \n    # If all row indices are the same, the ship is horizontal\n    row_indices = positions[:, 0]\n    return bool(np.all(row_indices == row_indices[0]))\n","name":"program_202","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the green ship in the upper half?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find the row indices of all tiles belonging to the green ship (denoted by 2)\n    green_positions = np.argwhere(true_board == 2)\n    \n    # Determine the halfway point of the board (8 rows \u2192 half is 4)\n    half = true_board.shape[0] \/\/ 2\n    \n    # The upper half consists of rows with index 0,1,2,3.\n    # If all green\u2010ship tiles lie in those rows, it's in the upper half.\n    return np.all(green_positions[:, 0] < half)\n","name":"program_203","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the green ship on the left half?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Answer whether the green ship (value 2) lies entirely in the left half\n    of the board. The \"left half\" is defined as columns 0..(n_cols\/\/2-1).\n    \"\"\"\n    # number of columns\n    n_cols = true_board.shape[1]\n    # midpoint of the board (integer division)\n    mid = n_cols \/\/ 2\n\n    # find all (row, col) positions of the green ship (marked with a 2)\n    green_rows, green_cols = np.where(true_board == 2)\n\n    # check if every column index of the green ship is strictly less than mid\n    return bool(np.all(green_cols < mid))\n","name":"program_204","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"does th green ship touch the center of its quadrant?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the green ship (value 2 in true_board) touches\n    the center of its 4\u00d74 quadrant (including occupying a center cell\n    or being adjacent by one square in any direction), False otherwise.\n    \"\"\"\n    # Dimensions\n    n_rows, n_cols = true_board.shape\n    \n    # Size of each quadrant\n    qh = n_rows \/\/ 2\n    qw = n_cols \/\/ 2\n\n    # Find all coordinates of the green ship (value 2)\n    green_coords = np.argwhere(true_board == 2)\n    if green_coords.size == 0:\n        # No green ship present\n        return False\n\n    # Determine which quadrant the green ship lies in by looking\n    # at the first tile of the ship\n    r0, c0 = green_coords[0]\n    r_start = 0    if r0 < qh else qh\n    c_start = 0    if c0 < qw else qw\n\n    # Compute the \"center\" cell(s) of that quadrant.\n    # For a 4\u00d74 quadrant the two central rows are qh\/\/2-1, qh\/\/2\n    # and the two central cols are qw\/\/2-1, qw\/\/2.\n    # (If the quadrant size were odd this would collapse to one index.)\n    row_offsets = [qh\/\/2 - 1, qh\/\/2] if qh % 2 == 0 else [qh\/\/2]\n    col_offsets = [qw\/\/2 - 1, qw\/\/2] if qw % 2 == 0 else [qw\/\/2]\n\n    centers = [\n        (r_start + dr, c_start + dc)\n        for dr in row_offsets\n        for dc in col_offsets\n    ]\n\n    # Check if any green tile touches (Chebyshev distance \u2264 1) any center cell\n    for (r, c) in green_coords:\n        for (cr, cc) in centers:\n            if max(abs(r - cr), abs(c - cc)) <= 1:\n                return True\n\n    return False\n","name":"program_205","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the greaan ship along an edge?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Locate all tiles of the green ship (encoded as 2)\n    green_mask = (true_board == 2)\n    rows, cols = np.where(green_mask)\n    \n    # If there is no green ship on the board, return False\n    if rows.size == 0:\n        return False\n    \n    # Board dimensions\n    max_row = true_board.shape[0] - 1\n    max_col = true_board.shape[1] - 1\n    \n    # Check if the green ship lies entirely along any one edge\n    on_top_edge    = np.all(rows == 0)\n    on_bottom_edge = np.all(rows == max_row)\n    on_left_edge   = np.all(cols == 0)\n    on_right_edge  = np.all(cols == max_col)\n    \n    return bool(on_top_edge or on_bottom_edge or on_left_edge or on_right_edge)\n","name":"program_206","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"does the green ship have three spots?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # In the encoding, the green ship is represented by the value 2.\n    # Count how many tiles in true_board are equal to 2.\n    green_length = int(np.sum(true_board == 2))\n    # Return True if its length is exactly 3, otherwise False.\n    return green_length == 3\n","name":"program_207","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"do any ships touch the center four squares?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if any ship occupies one of the four central squares\n    of an even-sized square board, False otherwise.\n    \"\"\"\n    # Determine the indices of the 2\u00d72 center block\n    n_rows, n_cols = true_board.shape\n    # For an 8\u00d78 board, this will give rows [3,4] and cols [3,4]\n    start_row = n_rows \/\/ 2 - 1\n    start_col = n_cols \/\/ 2 - 1\n    \n    # Extract the 2\u00d72 center block\n    center_block = true_board[start_row:start_row+2, start_col:start_col+2]\n    \n    # Check if any of these four squares contains a ship (> 0)\n    return bool(np.any(center_block > 0))\n","name":"program_208","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"do any ships touch the edges?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A ship \"touches the edge\" if any ship tile lies on the first or last row\n    # or on the first or last column, and that tile is still hidden.\n    hidden = (partial_board == -1)\n    ships = (true_board > 0)\n    \n    # Check top row\n    if np.any(ships[0, :] & hidden[0, :]):\n        return True\n    # Check bottom row\n    if np.any(ships[-1, :] & hidden[-1, :]):\n        return True\n    # Check left column\n    if np.any(ships[:, 0] & hidden[:, 0]):\n        return True\n    # Check right column\n    if np.any(ships[:, -1] & hidden[:, -1]):\n        return True\n    \n    return False\n","name":"program_209","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"do any ships touch eachother?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if any two distinct ships on true_board touch each other\n    (including diagonally), otherwise False.\n    \"\"\"\n    tb = true_board\n    rows, cols = tb.shape\n    \n    # Directions for all 8 neighbors\n    neigh_offsets = [(-1, -1), (-1, 0), (-1, 1),\n                     ( 0, -1),          ( 0, 1),\n                     ( 1, -1), ( 1, 0), ( 1, 1)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            ship_id = tb[i, j]\n            if ship_id > 0:\n                # Check all neighbors\n                for di, dj in neigh_offsets:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < rows and 0 <= nj < cols:\n                        neighbor_id = tb[ni, nj]\n                        # If there's another ship in an adjacent cell, they touch\n                        if neighbor_id > 0 and neighbor_id != ship_id:\n                            return True\n    return False\n","name":"program_210","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there more than two ships that touch eachother?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines whether more than two distinct ships touch at least one other ship.\n    A \"touch\" is defined as two ship tiles sharing an edge (no diagonals).\n    \"\"\"\n    n_rows, n_cols = true_board.shape\n    touching_ships = set()\n\n    # Directions for up, down, left, right\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    \n    for r in range(n_rows):\n        for c in range(n_cols):\n            ship_id = true_board[r, c]\n            if ship_id <= 0:\n                continue\n            # Check all four neighbors\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < n_rows and 0 <= nc < n_cols:\n                    neighbor_id = true_board[nr, nc]\n                    if neighbor_id > 0 and neighbor_id != ship_id:\n                        touching_ships.add(ship_id)\n                        touching_ships.add(neighbor_id)\n    # Return True if more than two distinct ships are involved in any touching\n    return len(touching_ships) > 2\n","name":"program_211","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there another ship touching the purple ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one non-purple ship tile\n    orthogonally adjacent to any purple ship tile, False otherwise.\n    \"\"\"\n    # Find all coordinates of the purple ship (value 3)\n    purple_positions = np.argwhere(true_board == 3)\n    \n    # Directions for orthogonal adjacency: up, down, left, right\n    neighbors = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    rows, cols = true_board.shape\n    \n    for (r, c) in purple_positions:\n        for dr, dc in neighbors:\n            nr, nc = r + dr, c + dc\n            # Check bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                val = true_board[nr, nc]\n                # If it's a ship tile (1,2,4) that isn't purple (3), they touch\n                if val > 0 and val != 3:\n                    return True\n    return False\n","name":"program_212","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there ships in the top half?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there are any unrevealed ship tiles in the top half of the board.\n    The top half is defined as the first n_rows\/\/2 rows (0 through half-1).\n    \"\"\"\n    n_rows = true_board.shape[0]\n    half = n_rows \/\/ 2\n    # Slice out the top half\n    top_true = true_board[:half, :]\n    top_partial = partial_board[:half, :]\n    # A ship tile is indicated by >0 in true_board and unrevealed is -1 in partial_board\n    unrevealed_in_top = (top_true > 0) & (top_partial == -1)\n    return bool(np.any(unrevealed_in_top))\n","name":"program_213","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the red ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the red ship (value == 1)\n    coords = np.argwhere(true_board == 1)\n    if coords.shape[0] <= 1:\n        # If there's 0 or 1 red\u2010ship cell, it can't be oriented vertically\n        return False\n\n    # Rows are in column 0, columns are in column 1 of coords\n    unique_rows = np.unique(coords[:, 0])\n    unique_cols = np.unique(coords[:, 1])\n\n    # A ship is vertical if all its columns are the same and it spans multiple rows\n    return (unique_cols.size == 1) and (unique_rows.size > 1)\n","name":"program_214","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the red ship on row G","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We interpret \"Is the red ship on row G?\" to mean:\n    # \"Are there any unrevealed red\u2010ship tiles in row G?\"\n    # Rows A\u2013H correspond to indices 0\u20137, so G is index 6.\n    row_idx = ord('G') - ord('A')  # 6\n\n    # A red ship tile is coded as 1 in true_board.\n    # A hidden tile is coded as -1 in partial_board.\n    # We return True if there exists any position in row G\n    # where true_board == 1 and partial_board == -1.\n    red_on_G_unrevealed = (true_board[row_idx, :] == 1) & (partial_board[row_idx, :] == -1)\n    return bool(np.any(red_on_G_unrevealed))\n","name":"program_215","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the green ship verticle","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if the green ship (marked with 2) is oriented vertically\n    (i.e., all its tiles share the same column), otherwise False.\n    \"\"\"\n    # find all coordinates of the green ship\n    coords = np.argwhere(true_board == 2)\n    if coords.size == 0:\n        # no green ship on the board (should not happen in a valid game)\n        return False\n\n    # extract the column indices of those coordinates\n    cols = coords[:, 1]\n    # if all column indices are identical, the ship is vertical\n    return bool(np.all(cols == cols[0]))\n","name":"program_216","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the purple ship on row 5","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Purple is coded as 3. Row \u201c5\u201d corresponds to index 4 (0-based).\n    return np.any(true_board[4, :] == 3)\n","name":"program_217","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is any colored ship within the nine block center","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is any unrevealed ship tile in the central 3\u00d73 block\n    of the board, False otherwise.\n    \"\"\"\n    nrows, ncols = true_board.shape\n    # Compute the 3\u00d73 center block for even-sized boards:\n    # e.g. for 8\u00d78, center rows are indices 3,4,5 and cols are 3,4,5.\n    mid_r, mid_c = nrows \/\/ 2, ncols \/\/ 2\n    r_slice = slice(mid_r - 1, mid_r + 2)\n    c_slice = slice(mid_c - 1, mid_c + 2)\n\n    center_true = true_board[r_slice, c_slice]\n    center_partial = partial_board[r_slice, c_slice]\n\n    # A colored ship tile is indicated by >0 in true_board,\n    # and unrevealed tiles are -1 in partial_board.\n    mask = (center_true > 0) & (center_partial == -1)\n    return bool(np.any(mask))\n","name":"program_218","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any ships in the 16 square center?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Define the 4\u00d74 center region: rows C\u2013F (indices 2\u20135), columns 3\u20136 (indices 2\u20135)\n    r_slice = slice(2, 6)\n    c_slice = slice(2, 6)\n\n    # Extract the corresponding sub\u2010boards\n    true_center = true_board[r_slice, c_slice]\n    partial_center = partial_board[r_slice, c_slice]\n\n    # A ship tile is indicated by a value > 0 in true_board.\n    # We only care about ships that remain hidden to the Captain,\n    # i.e. where partial_board == -1.\n    hidden_ship_tiles = (true_center > 0) & (partial_center == -1)\n\n    # If there's at least one such tile, answer \"Yes\"\n    return np.any(hidden_ship_tiles)\n","name":"program_219","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there ships around the edges?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile on the outer edge\n    of the board, otherwise False.\n    \"\"\"\n    # Create a mask for the border (top row, bottom row, left column, right column)\n    border_mask = np.zeros(true_board.shape, dtype=bool)\n    border_mask[0, :] = True\n    border_mask[-1, :] = True\n    border_mask[:, 0] = True\n    border_mask[:, -1] = True\n\n    # A tile is an unrevealed ship tile if:\n    #  - true_board > 0  (there is a ship)\n    #  - partial_board == -1  (it has not been revealed yet)\n    #  - border_mask == True (it lies on the edge)\n    unrevealed_edge_ships = (true_board > 0) & (partial_board == -1) & border_mask\n\n    # If any such tile exists, answer \"Yes\" (True), otherwise \"No\" (False).\n    return bool(np.any(unrevealed_edge_ships))\n","name":"program_220","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there ships along the edges other than the one in row A","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed ship tile on the board edges\n    excluding the top row (row A). Edges include the bottom row and the\n    two side columns.\n    \"\"\"\n    m, n = true_board.shape\n    \n    # Build coordinate grids\n    rows = np.arange(m)[:, None]   # shape (m,1)\n    cols = np.arange(n)[None, :]   # shape (1,n)\n    \n    # Mask for \"edges excluding top row\"\n    #   bottom row: rows == m-1\n    #   left column: cols == 0\n    #   right column: cols == n-1\n    #   exclude top row (rows != 0)\n    edge_except_top = (\n        ((rows == m - 1) | (cols == 0) | (cols == n - 1))\n        & (rows != 0)\n    )\n    \n    # Hidden cells in partial_board are marked -1\n    hidden = (partial_board == -1)\n    # Ship cells in true_board have values > 0\n    ship = (true_board > 0)\n    \n    # If any hidden ship cell lies on the selected edge, return True\n    return bool(np.any(edge_except_top & hidden & ship))\n","name":"program_221","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any ships in the corners?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed ship tile in a corner\n    of the board (A1, A8, H1, or H8 for an 8x8 board).\n    \"\"\"\n    n_rows, n_cols = true_board.shape\n    # Define the four corner coordinates\n    corners = [\n        (0, 0),                # Top-left (A1)\n        (0, n_cols - 1),       # Top-right (A8)\n        (n_rows - 1, 0),       # Bottom-left (H1)\n        (n_rows - 1, n_cols - 1)  # Bottom-right (H8)\n    ]\n    # Check each corner: is there a ship tile in true_board that is still hidden?\n    for r, c in corners:\n        if true_board[r, c] > 0 and partial_board[r, c] == -1:\n            return True\n    return False\n","name":"program_222","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any half of the grid with no ships, top bottom left or right half?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # mask of all still-hidden ship tiles\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n    \n    # define the four halves by slicing\n    top_half    = hidden_ships[0:4, :]   # rows A\u2013D\n    bottom_half = hidden_ships[4:8, :]   # rows E\u2013H\n    left_half   = hidden_ships[:, 0:4]   # cols 1\u20134\n    right_half  = hidden_ships[:, 4:8]   # cols 5\u20138\n    \n    # check if any half has zero hidden ship cells\n    for region in (top_half, bottom_half, left_half, right_half):\n        if not np.any(region):\n            return True\n    return False\n","name":"program_223","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there two ships in the top half at least?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine if there are at least two distinct ships with\n    at least one unrevealed tile in the top half of the board.\n    \"\"\"\n    # Number of rows\n    n_rows = true_board.shape[0]\n    # Define top half (rows 0 through n_rows\/\/2 - 1)\n    half = n_rows \/\/ 2\n\n    # Slice out the top half of both boards\n    top_true = true_board[:half, :]\n    top_partial = partial_board[:half, :]\n\n    # Build a mask for tiles that are\n    # 1) part of a ship in true_board (> 0)\n    # 2) still hidden in partial_board (== -1)\n    unrevealed_ship_mask = (top_true > 0) & (top_partial == -1)\n\n    # Extract the ship IDs in those masked positions\n    ships_in_top_half = np.unique(top_true[unrevealed_ship_mask])\n\n    # Count how many distinct ship IDs appear\n    return ships_in_top_half.size >= 2\n","name":"program_224","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any ships in rows 4 and or 5?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows 4 and 5 correspond to indices 3 and 4 (0-based)\n    rows = [3, 4]\n    # Mask for unrevealed ship tiles in those rows\n    unrevealed_ships = (true_board[rows, :] != 0) & (partial_board[rows, :] == -1)\n    return bool(np.any(unrevealed_ships))\n","name":"program_225","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are any ships touching eachother?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if any two distinct ships on true_board are adjacent\n    (including diagonally), False otherwise.\n    \"\"\"\n    nrows, ncols = true_board.shape\n    # Offsets for the 8 neighbors\n    neighs = [(-1,-1),(-1,0),(-1,1),\n              (0,-1),        (0,1),\n              (1,-1),(1,0),(1,1)]\n    for i in range(nrows):\n        for j in range(ncols):\n            ship_id = true_board[i, j]\n            # only consider actual ship tiles (>0)\n            if ship_id > 0:\n                for di, dj in neighs:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < nrows and 0 <= nj < ncols:\n                        neighbor_id = true_board[ni, nj]\n                        # if it's a different ship, they are touching\n                        if neighbor_id > 0 and neighbor_id != ship_id:\n                            return True\n    return False\n","name":"program_226","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the purple ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the purple ship (denoted by 3) is oriented vertically,\n    i.e., all of its tiles lie in the same column. Otherwise returns False.\n    \"\"\"\n    # find the row, col indices of all purple-ship tiles\n    rows, cols = np.where(true_board == 3)\n    \n    # if all columns are the same, it's vertical\n    return np.all(cols == cols[0])\n","name":"program_227","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the orange ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if the orange ship (value 4) is oriented vertically,\n    False otherwise.\n    \"\"\"\n    # Find all the (row, col) positions of the orange ship\n    positions = np.argwhere(true_board == 4)\n    \n    # If for all these positions the column index is the same,\n    # the ship is vertical.\n    if positions.size == 0:\n        # No orange ship found (shouldn't happen in a valid game)\n        return False\n    \n    # Extract just the column indices\n    cols = positions[:, 1]\n    \n    # If there's exactly one unique column, it's vertical\n    return np.unique(cols).size == 1\n","name":"program_228","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the green ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the green ship (denoted by 2)\n    coords = np.argwhere(true_board == 2)\n    if coords.size == 0:\n        # No green ship found (shouldn't happen in a valid game)\n        return False\n\n    # Extract the column indices of those coordinates\n    cols = coords[:, 1]\n    # If all column indices are the same, the ship is vertical\n    return np.all(cols == cols[0])\n","name":"program_229","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships within rows 3,4,5,6","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # rows 3,4,5,6 in 1\u2010based indexing => indices 2,3,4,5 in 0\u2010based\n    rows = np.arange(2, 6)\n    # A tile is an unrevealed ship if true_board>0 and partial_board==-1\n    mask = (true_board[rows, :] > 0) & (partial_board[rows, :] == -1)\n    return bool(np.any(mask))\n","name":"program_230","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any ships along the edges?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Create a mask for all edge positions (first\/last row or first\/last column)\n    edges_mask = np.zeros_like(true_board, dtype=bool)\n    edges_mask[0, :] = True\n    edges_mask[-1, :] = True\n    edges_mask[:, 0] = True\n    edges_mask[:, -1] = True\n\n    # Mask of hidden tiles in the partial board\n    hidden_mask = (partial_board == -1)\n\n    # Mask of ship tiles in the true board\n    ship_mask = (true_board > 0)\n\n    # We only care about ships on edge tiles that are still hidden\n    return np.any(edges_mask & hidden_mask & ship_mask)\n","name":"program_231","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any ships in the 16 square center?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship cell in the central 4\u00d74 square\n    (rows C\u2013F, columns 3\u20136), otherwise False.\n    \"\"\"\n    # Define the slice for the 4\u00d74 center: rows 2\u20135 (C\u2013F), columns 2\u20135 (3\u20136)\n    center_slice = (slice(2, 6), slice(2, 6))\n    \n    center_true = true_board[center_slice]\n    center_partial = partial_board[center_slice]\n    \n    # A ship cell is > 0 in true_board; unrevealed in partial_board is -1\n    hidden_ship_cells = (center_true > 0) & (center_partial == -1)\n    \n    return bool(np.any(hidden_ship_cells))\n","name":"program_232","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there more than one ships along the edges?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Create a mask for the edge cells\n    edges = np.zeros_like(true_board, dtype=bool)\n    edges[0, :] = True\n    edges[-1, :] = True\n    edges[:, 0] = True\n    edges[:, -1] = True\n\n    # Find unrevealed ship\u2010tiles on the edges\n    unrevealed_edge_ships = (true_board > 0) & (partial_board == -1) & edges\n\n    # Gather the distinct ship IDs in those tiles\n    ship_ids = np.unique(true_board[unrevealed_edge_ships])\n\n    # Discard 0 if it somehow appears\n    ship_ids = ship_ids[ship_ids > 0]\n\n    # Are there more than one distinct ships there?\n    return ship_ids.size > 1\n","name":"program_233","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there more than one ship touching the center 16 squares?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # true_board: full visibility (with 0=water, 1..4=ships)\n    # partial_board: not actually used for this particular question,\n    #                but accepted by signature.\n\n    n, m = true_board.shape\n    \n    # define the 4\u00d74 centre for even n, m\n    # (for 8\u00d78 this is rows 2..5 and cols 2..5 in 0-based indexing)\n    r0 = n\/\/2 - n\/\/4\n    r1 = n\/\/2 + n\/\/4\n    c0 = m\/\/2 - m\/\/4\n    c1 = m\/\/2 + m\/\/4\n\n    centre = np.zeros((n,m), dtype=bool)\n    centre[r0:r1, c0:c1] = True\n\n    # Offsets for all 8 directions\n    neighs = [(-1,  0), (1,  0), (0, -1), (0, 1),\n              (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    touching = set()\n    for i in range(n):\n        for j in range(m):\n            ship_id = true_board[i, j]\n            # skip water, hidden (neg) or centre\u2010inside cells\n            if ship_id <= 0 or centre[i, j]:\n                continue\n            # check if any neighbour is in the centre\n            for di, dj in neighs:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < n and 0 <= nj < m and centre[ni, nj]:\n                    touching.add(ship_id)\n                    break\n\n    # return True if strictly more than one distinct ship touches the centre\n    return len(touching) > 1\n","name":"program_234","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the green ship horizonta?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all (row, col) positions of the green ship (value==2)\n    green_positions = np.argwhere(true_board == 2)\n    # If there are no green\u2010ship tiles, we cannot say it's horizontal\n    if green_positions.size == 0:\n        return False\n    # Extract just the row indices\n    rows = green_positions[:, 0]\n    # If all rows are identical, it's horizontal\n    return np.all(rows == rows[0])\n","name":"program_235","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the purple ship horizonta;l","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the purple ship (denoted by 3)\n    coords = np.argwhere(true_board == 3)\n    if coords.size == 0:\n        # If for some reason there is no purple ship, default to False\n        return False\n\n    # Extract the row and column indices\n    rows = coords[:, 0]\n    cols = coords[:, 1]\n\n    # The ship is horizontal if all row indices are the same\n    return np.all(rows == rows[0])\n","name":"program_236","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the orange ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if the orange ship (value 4) is placed horizontally on true_board,\n    False otherwise.\n    \"\"\"\n    # Find all positions of the orange ship (marked with 4)\n    orange_positions = np.argwhere(true_board == 4)\n    \n    # If all row indices are the same, the ship is horizontal\n    rows = orange_positions[:, 0]\n    return np.all(rows == rows[0])\n","name":"program_237","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there more than on ship in the top half?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is more than one distinct ship (by ID) \n    with at least one unrevealed tile in the top half of the board.\n    \n    We define \"top half\" as the first N\/2 rows (for an N\u00d7N board).\n    A tile is \"unrevealed\" if partial_board == -1 but true_board > 0.\n    \"\"\"\n    # number of rows in the board\n    n_rows = true_board.shape[0]\n    # midpoint (top half rows are [0:mid])\n    mid = n_rows \/\/ 2\n\n    # mask of cells in the top half that contain a ship in the true_board\n    # and are still hidden in partial_board\n    top_half_mask = (true_board[:mid, :] > 0) & (partial_board[:mid, :] == -1)\n\n    # extract the ship\u2010IDs present in those masked cells\n    ships_in_top = np.unique(true_board[:mid, :][top_half_mask])\n\n    # answer is True if more than one distinct ship\u2010ID is found\n    return ships_in_top.size > 1\n","name":"program_238","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there more than one ship on the left half?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether there is more than one distinct ship with at least one\n    unrevealed tile in the left half of the board.\n    \"\"\"\n    # Define left\u2010half boundary (first 50% of columns)\n    n_cols = true_board.shape[1]\n    midpoint = n_cols \/\/ 2\n    \n    # 1) Find all unrevealed ship tiles\n    #    true_board > 0 selects ship tiles\n    #    partial_board == -1 selects hidden tiles\n    unrevealed = (true_board > 0) & (partial_board == -1)\n    \n    # 2) Restrict to the left half of the board\n    left_unrevealed = unrevealed[:, :midpoint]\n    \n    # 3) Extract the ship IDs of those tiles\n    ship_ids = np.unique(true_board[:, :midpoint][left_unrevealed])\n    \n    # 4) Count distinct ships; answer True if more than one remains hidden in left half\n    return ship_ids.size > 1\n","name":"program_239","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship in row A","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row A corresponds to index 0\n    row_idx = 0\n    \n    # A tile is an unrevealed ship tile if:\n    # 1) true_board has a ship (> 0) at that position\n    # 2) partial_board is still hidden (-1) at that position\n    unrevealed_ship_tiles = (true_board[row_idx] > 0) & (partial_board[row_idx] == -1)\n    \n    # If there is any unrevealed ship tile in row A, answer \"Yes\" (True), otherwise \"No\" (False)\n    return bool(np.any(unrevealed_ship_tiles))\n","name":"program_240","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship in row G","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert row letter 'G' to 0-based index: A->0, B->1, ..., G->6\n    row_idx = ord('G') - ord('A')\n    # Extract the true and partial data for row G\n    true_row    = true_board[row_idx, :]\n    partial_row = partial_board[row_idx, :]\n    # A ship is \u201cunrevealed\u201d if true_board>0 and partial_board==-1\n    unrevealed_ships = (true_row > 0) & (partial_row == -1)\n    return bool(np.any(unrevealed_ships))\n","name":"program_241","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship in row H","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed ship tile in row H (the 8th row),\n    otherwise False.\n    \"\"\"\n    # Row H corresponds to index 7 (0-based indexing)\n    row_index = 7\n\n    # A ship tile in true_board is any value > 0.\n    # An unrevealed tile in partial_board is marked as -1.\n    ship_tiles = true_board[row_index] > 0\n    hidden_tiles = partial_board[row_index] == -1\n\n    # Check if there's at least one cell that is both a ship tile and still hidden.\n    return bool((ship_tiles & hidden_tiles).any())\n","name":"program_242","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there another ship on C","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the row index for 'C'\n    row_idx = ord('C') - ord('A')\n    # A ship tile is any true_board cell > 0\n    ship_tiles = true_board[row_idx, :] > 0\n    # A hidden cell is any partial_board cell == -1\n    hidden_tiles = partial_board[row_idx, :] == -1\n    # Check if there is any ship tile in row C that remains hidden\n    return bool(np.any(ship_tiles & hidden_tiles))\n","name":"program_243","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it horozontal","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the currently \u201cin\u2010progress\u201d ship (one that has at least\n    one revealed segment and at least one hidden segment) is oriented\n    horizontally. Returns True if horizontal, False otherwise.\n    \"\"\"\n    # Find the ship ID that is partially revealed (some parts > 0 in partial_board)\n    # and still has unrevealed parts (-1 in partial_board).\n    target_id = None\n    for ship_id in np.unique(true_board):\n        if ship_id <= 0:\n            continue\n        mask = (true_board == ship_id)\n        has_revealed = np.any(np.logical_and(mask, partial_board > 0))\n        has_hidden   = np.any(np.logical_and(mask, partial_board == -1))\n        if has_revealed and has_hidden:\n            target_id = ship_id\n            break\n\n    # If we didn't find exactly one such ship, default to False\n    if target_id is None:\n        return False\n\n    # Collect all coordinates of that ship on the true board\n    coords = np.argwhere(true_board == target_id)\n    rows = coords[:, 0]\n    cols = coords[:, 1]\n\n    # Horizontal if all row indices are the same\n    return np.all(rows == rows[0])\n","name":"program_244","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it in row 1","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We interpret \"row 1\" as the first row (index 0 in the arrays).\n    row_idx = 0\n    # A ship tile is any true_board entry > 0\n    ship_tiles = true_board[row_idx] > 0\n    # A hidden tile is any partial_board entry == -1\n    hidden_tiles = partial_board[row_idx] == -1\n    # If there's any tile that is both a ship and still hidden, answer Yes (True)\n    return bool(np.any(ship_tiles & hidden_tiles))\n","name":"program_245","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship in row D","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one ship tile in row D (index 3)\n    that remains hidden on partial_board, otherwise False.\n    \"\"\"\n    # Row D corresponds to index 3 (0-indexed: A=0, B=1, C=2, D=3).\n    row_idx = 3\n\n    # A cell contains an unrevealed ship tile if:\n    #  - partial_board is -1 (hidden)\n    #  - true_board has a value > 0 (indicating ship)\n    hidden_ship_mask = (partial_board[row_idx] == -1) & (true_board[row_idx] > 0)\n\n    # If any such cell exists, return True; otherwise False\n    return bool(np.any(hidden_ship_mask))\n","name":"program_246","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it in row 3","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We interpret \"row 3\" as the third row (0-indexed row 2).\n    # We return True if there is any ship tile in that row\n    # which is still hidden (partial_board == -1).\n    row = 2\n    # Identify ship positions on the true board (> 0)\n    ship_positions = true_board[row, :] > 0\n    # Identify hidden positions on the partial board\n    hidden_positions = partial_board[row, :] == -1\n    # If any tile is both a ship and still hidden, answer is True\n    return bool(np.any(ship_positions & hidden_positions))\n","name":"program_247","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there another ship on E","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the row index for 'E' (0-based: A\u21920, B\u21921, \u2026, E\u21924)\n    row_idx = ord('E') - ord('A')\n    # A ship tile is any cell with a value > 0 in true_board.\n    # \"Another ship on E\" means an unrevealed ship tile on row E.\n    # So we check for cells in row E where true_board > 0 but partial_board is still hidden (-1).\n    has_unrevealed_ship = np.any((true_board[row_idx] > 0) & (partial_board[row_idx] == -1))\n    return bool(has_unrevealed_ship)\n","name":"program_248","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"row 5","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # row 5 \u2192 zero\u2010based index 4\n    r = 4\n    # hidden cells in the partial board\n    hidden = (partial_board[r] == -1)\n    # ship cells in the true board (values 1\u20134)\n    ship   = (true_board[r] > 0)\n    # if any position is both hidden and a ship, answer Yes\n    return bool(np.any(hidden & ship))\n","name":"program_249","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there another ship on F","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to know if there is any unrevealed ship tile on row 'F'.\n    # Compute the row index for 'F' (A=0, B=1, \u2026, F=5).\n    row_idx = ord('F') - ord('A')\n    \n    # A ship tile in true_board is any entry != 0.\n    ship_tiles = (true_board[row_idx] != 0)\n    # An unrevealed tile in partial_board is any entry == -1.\n    hidden_tiles = (partial_board[row_idx] == -1)\n    \n    # If there is any position that is both a ship and still hidden, return True.\n    return bool(np.any(ship_tiles & hidden_tiles))\n","name":"program_250","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any ships in row D?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the index for row 'D' (0-based: A=0, B=1, C=2, D=3)\n    row_idx = ord('D') - ord('A')\n    # Extract that row from both boards\n    true_row = true_board[row_idx]\n    partial_row = partial_board[row_idx]\n    # A ship tile is indicated by a value > 0 in true_board\n    # It is unrevealed if the partial_board has -1 at that position\n    unrevealed_ship_tiles = (true_row > 0) & (partial_row == -1)\n    # If any such tile exists, answer Yes (True), otherwise No (False)\n    return bool(np.any(unrevealed_ship_tiles))\n","name":"program_251","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the last ship on the top half of the map (A-D)?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all hidden ship\u2010tiles (tiles where the true board has a ship but the\n    # partial board is still hidden).\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n    # Which ship types still have hidden tiles?\n    remaining_ship_ids = np.unique(true_board[hidden_ships])\n    # If no ships remain hidden, answer is False (nothing left on top half).\n    if remaining_ship_ids.size == 0:\n        return False\n    # We assume \"the last ship\" means the one ship type with hidden tiles.\n    last_ship_id = remaining_ship_ids[0]\n    # Get all positions of that ship on the true board.\n    ship_positions = np.argwhere(true_board == last_ship_id)\n    # Check if all of its row indices are in 0..3 (i.e. rows A\u2013D).\n    # NumPy uses 0-based indexing, so rows A\u2013D correspond to indices 0\u20133.\n    return np.all(ship_positions[:, 0] <= 3)\n","name":"program_252","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any in row F?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to know if there are any *unrevealed* ship tiles in row F.\n    # Rows are indexed A=0, B=1, \u2026, F=5, \u2026, H=7.\n    row_idx = ord('F') - ord('A')\n    \n    # A ship tile in true_board is indicated by a value > 0.\n    # A hidden tile in partial_board is indicated by -1.\n    # We look for positions in row F where true_board > 0 AND partial_board == -1.\n    ships_remaining_in_F = (true_board[row_idx, :] > 0) & (partial_board[row_idx, :] == -1)\n    \n    return bool(np.any(ships_remaining_in_F))\n","name":"program_253","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any in row G?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'G' to its 0-based index (A\u21920, B\u21921, \u2026, H\u21927)\n    row_idx = ord('G') - ord('A')\n    # A tile is still hidden if partial_board == -1\n    hidden = partial_board[row_idx] == -1\n    # A tile is a ship if true_board > 0\n    ship = true_board[row_idx] > 0\n    # If there is any tile in row G that is both hidden and a ship, answer yes\n    return bool((hidden & ship).any())\n","name":"program_254","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any in column 1?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Column 1 corresponds to index 0 in a 0-based array.\n    col_idx = 0\n\n    # A tile contains an unrevealed ship segment if:\n    #   1) true_board has a ship (> 0) at that position\n    #   2) partial_board still marks it as hidden (-1)\n    hidden_ship_mask = (true_board[:, col_idx] > 0) & (partial_board[:, col_idx] == -1)\n\n    # If any such tile exists in column 1, answer \"Yes\", otherwise \"No\".\n    return bool(np.any(hidden_ship_mask))\n","name":"program_255","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any in column 2?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in column 2 (index 1), False otherwise.\n    \"\"\"\n    # Column index for \"column 2\" is 1 (zero\u2010based indexing)\n    col_idx = 1\n\n    # Find hidden cells in that column\n    hidden = partial_board[:, col_idx] == -1\n    # Find actual ship cells in that column\n    ship   = true_board[:, col_idx] > 0\n\n    # If any cell is both hidden and a ship, answer is True\n    return bool(np.any(hidden & ship))\n","name":"program_256","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the ship that has at least one hidden tile in column 2\n    (0-based index 1) is oriented vertically.\n    \"\"\"\n    # Column index for \"column 2\" in 0-based numpy indexing\n    col_idx = 1\n\n    # Find all rows in that column where there's a hidden ship tile\n    hidden_ship_rows = np.where((partial_board[:, col_idx] == -1) &\n                                (true_board[:,    col_idx]  > 0))[0]\n\n    # If no hidden ship parts in column 2, then question is moot \u2192 return False\n    if hidden_ship_rows.size == 0:\n        return False\n\n    # Pick the ship ID of one of those hidden tiles\n    ship_id = true_board[hidden_ship_rows[0], col_idx]\n\n    # Find all coordinates of that ship on the true board\n    coords = np.argwhere(true_board == ship_id)\n    # coords is an array of shape (ship_length, 2), each row is [row_index, col_index]\n\n    # If all of its column indices are the same, it's vertical\n    return np.unique(coords[:, 1]).size == 1\n","name":"program_257","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there ships in row A","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there are any still\u2010hidden ship tiles in row A (index 0),\n    otherwise return False.\n    \"\"\"\n    row_idx = 0  # Row A corresponds to index 0\n    # A tile is an unrevealed ship if:\n    #   partial_board == -1 (hidden)\n    #   AND true_board > 0 (a ship tile)\n    unrevealed_ships_in_A = (partial_board[row_idx] == -1) & (true_board[row_idx] > 0)\n    return bool(np.any(unrevealed_ships_in_A))\n","name":"program_258","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row G","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row G corresponds to index 6 (0-based indexing: A=0, B=1, ..., G=6)\n    true_row = true_board[6, :]\n    partial_row = partial_board[6, :]\n    \n    # A hidden ship tile is one where the true board has a ship (>0)\n    # and the partial board still shows it as hidden (-1).\n    hidden_ships = (true_row > 0) & (partial_row == -1)\n    \n    # If any hidden ship remains in row G, answer \"Yes\" (True), otherwise \"No\" (False).\n    return bool(np.any(hidden_ships))\n","name":"program_259","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Ships in Row B","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert row letter 'B' to zero\u2010based index\n    row_index = ord('B') - ord('A')\n    # A ship tile is >0 on the true_board, and unrevealed if partial_board == -1\n    mask = (true_board[row_index, :] > 0) & (partial_board[row_index, :] == -1)\n    return bool(np.any(mask))\n","name":"program_260","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row D?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'D' to index 3 (0-based: A\u21920, B\u21921, C\u21922, D\u21923, \u2026)\n    row_idx = ord('D') - ord('A')\n    \n    # A tile is an unrevealed ship if true_board > 0 but partial_board == -1\n    unrevealed_ships_in_row = (true_board[row_idx] > 0) & (partial_board[row_idx] == -1)\n    \n    # Return True if any such tile exists, otherwise False\n    return bool(np.any(unrevealed_ships_in_row))\n","name":"program_261","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"H?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the index for row 'H'\n    row_index = ord('H') - ord('A')\n    \n    # Extract that row from both boards\n    true_row = true_board[row_index]\n    partial_row = partial_board[row_index]\n    \n    # A ship is any positive number in true_board;\n    # a hidden tile in partial_board is marked as -1.\n    # We check if there exists any tile in row H that\n    # is a ship on the true board and still hidden.\n    hidden_ship_tiles = (true_row > 0) & (partial_row == -1)\n    \n    return bool(np.any(hidden_ship_tiles))\n","name":"program_262","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row F","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'F' to 0-based index\n    row_idx = ord('F') - ord('A')\n    # A ship tile is indicated by a value > 0 in true_board.\n    # A hidden tile is indicated by -1 in partial_board.\n    # We answer \"Yes\" if there exists at least one hidden ship tile in row F.\n    hidden_ships = (true_board[row_idx] > 0) & (partial_board[row_idx] == -1)\n    return np.any(hidden_ships)\n","name":"program_263","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"1-4?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Answer the question: \"Are there any ships in columns 1 through 4\n    that the captain has not yet uncovered?\"\n\n    We interpret columns 1\u20134 as numpy column indices 0\u20133. We check\n    for any tile in that sub\u2010region where:\n      - partial_board == -1 (still hidden)\n      - true_board > 0    (contains a ship)\n    If at least one such tile exists, we return True (Yes), otherwise False (No).\n    \"\"\"\n    # Identify hidden tiles in the captain's view\n    hidden = (partial_board == -1)\n    \n    # Restrict to columns 0\u20133 (captain's \"1\u20134\")\n    col_slice = slice(0, 4)\n    \n    # Check for any hidden ship tile in that region\n    ships_hidden_in_range = (true_board[:, col_slice] > 0) & hidden[:, col_slice]\n    \n    return bool(np.any(ships_hidden_in_range))\n","name":"program_264","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"1-5?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in columns 1 through 5 (inclusive), otherwise False.\n    \"\"\"\n    # Convert columns 1\u20135 to zero-based indices 0\u20134\n    cols = slice(0, 5)\n    \n    # hidden_mask is True where the captain still hasn't revealed the tile\n    hidden_mask = partial_board[:, cols] == -1\n    \n    # ship_mask is True where the true board has a ship (>0)\n    ship_mask = true_board[:, cols] > 0\n    \n    # If any position is both hidden and a ship, answer \"Yes\"\n    return bool(np.any(hidden_mask & ship_mask))\n","name":"program_265","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"H1-5?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there are any unrevealed ship tiles in row H (index 7)\n    among columns 1 through 5 (indices 0\u20134), otherwise False.\n    \"\"\"\n    row_index = ord('H') - ord('A')   # 7\n    cols = slice(0, 5)                # columns 1\u20135 \u2192 indices 0\u20134\n\n    # A tile is an unrevealed ship tile if true_board > 0 (ship)\n    # and partial_board == -1 (hidden)\n    segment_true = true_board[row_index, cols]\n    segment_partial = partial_board[row_index, cols]\n\n    # Check if any position is both ship in true_board and hidden in partial_board\n    unrevealed_ships = (segment_true > 0) & (segment_partial == -1)\n    return bool(np.any(unrevealed_ships))\n","name":"program_266","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row C?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in row C (index 2),\n    otherwise False.\n    \"\"\"\n    row_index = 2  # Row C corresponds to index 2\n    # A tile is an unrevealed ship tile if partial_board is -1 (hidden)\n    # and true_board > 0 (a ship)\n    unrevealed_ships_in_C = (partial_board[row_index] == -1) & (true_board[row_index] > 0)\n    return bool(np.any(unrevealed_ships_in_C))\n","name":"program_267","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"2-5?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in columns 2 through 5 (inclusive),\n    otherwise returns False.\n    \"\"\"\n    # Slice out columns 2-5 (0-based indices 1 through 4)\n    tb_slice = true_board[:, 1:5]\n    pb_slice = partial_board[:, 1:5]\n    \n    # A ship tile is indicated by a value > 0 in true_board.\n    # An unrevealed tile in partial_board is indicated by -1.\n    unrevealed_ship_mask = (tb_slice > 0) & (pb_slice == -1)\n    \n    # If any True in the mask, there is at least one unrevealed ship tile in columns 2-5.\n    return bool(np.any(unrevealed_ship_mask))\n","name":"program_268","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any ships in row A?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in row A (index 0),\n    otherwise returns False.\n    \"\"\"\n    row_idx = 0  # Row A\n    # A ship tile is true_board > 0.  We only care about those still hidden in partial_board (== -1).\n    unrevealed_ship_tiles = (true_board[row_idx, :] > 0) & (partial_board[row_idx, :] == -1)\n    return bool(np.any(unrevealed_ship_tiles))\n","name":"program_269","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row B?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We're checking row B, which is index 1 (0-based: A=0, B=1, ...)\n    row_idx = 1\n    # A ship tile is > 0 in true_board. A hidden tile is -1 in partial_board.\n    # We want to know if there's any ship tile in row B that remains hidden.\n    return np.any((true_board[row_idx] > 0) & (partial_board[row_idx] == -1))\n","name":"program_270","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row F?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We're checking row F, which is index 5 (0-based, since A=0, B=1, \u2026, F=5)\n    row_idx = ord('F') - ord('A')\n    # Identify which cells in the true board row are ships (1\u20134)\n    ship_cells = np.isin(true_board[row_idx], [1, 2, 3, 4])\n    # Identify which cells in the partial board row are still hidden (-1)\n    hidden_cells = (partial_board[row_idx] == -1)\n    # If any ship cell remains hidden in row F, answer is True; otherwise False\n    return bool(np.any(ship_cells & hidden_cells))\n","name":"program_271","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # look at each ship\u2010ID on the true board (1..4)\n    for ship_id in np.unique(true_board):\n        if ship_id == 0:\n            continue\n        # find all true coordinates of this ship\n        coords = np.argwhere(true_board == ship_id)\n        # skip degenerate ships of length 1 (if any)\n        if coords.shape[0] <= 1:\n            continue\n        # is the ship horizontal? i.e. all row\u2010indices the same\n        rows = coords[:, 0]\n        if np.all(rows == rows[0]):\n            # check if any of its cells remain hidden\n            hidden_mask = partial_board[coords[:, 0], coords[:, 1]] < 0\n            if hidden_mask.any():\n                return True\n    return False\n","name":"program_272","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row G?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'G' to index 6 (0-based: A=0, B=1, \u2026, G=6)\n    row_idx = ord('G') - ord('A')\n    # A tile is an unrevealed ship if true_board > 0 and partial_board == -1\n    unrevealed_ships = (true_board[row_idx] > 0) & (partial_board[row_idx] == -1)\n    return bool(np.any(unrevealed_ships))\n","name":"program_273","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Column 1-4?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Select columns 0\u20133 (which correspond to columns 1\u20134)\n    tb_slice = true_board[:, 0:4]\n    pb_slice = partial_board[:, 0:4]\n    # A ship tile is indicated by a value > 0 in true_board\n    # and is hidden in partial_board if its value == -1\n    hidden_ship = (tb_slice > 0) & (pb_slice == -1)\n    # If any such tile exists, answer 'Yes' (True), otherwise 'No' (False)\n    return bool(np.any(hidden_ship))\n","name":"program_274","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"H3?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # The Captain is asking about tile H3.\n    # Map 'H' to row index 7 (0-based) and column 3 to index 2.\n    row_idx = ord('H') - ord('A')  # 'H' -> 7\n    col_idx = 3 - 1                # 3 -> 2\n    # Return True if the true board has a ship (value > 0) at that position.\n    return true_board[row_idx, col_idx] > 0\n","name":"program_275","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any more ships in row B?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We're checking row B, which is index 1 (A=0, B=1, \u2026)\n    row_idx = 1\n    # A hidden ship tile is one where true_board > 0 (ship) but partial_board is still -1 (hidden).\n    hidden_ships = (true_board[row_idx, :] > 0) & (partial_board[row_idx, :] == -1)\n    # If any such tile exists, there are more ships in row B.\n    return bool(np.any(hidden_ships))\n","name":"program_276","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row C?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We're answering: \"Any ships in row C?\"\n    # Row C corresponds to index 2 (0-based: A=0, B=1, C=2).\n    row_idx = 2\n    # A hidden ship tile is one where partial_board is still -1\n    # but true_board has a ship (>0) at that position.\n    hidden_ship_tiles = (partial_board[row_idx] == -1) & (true_board[row_idx] > 0)\n    return bool(np.any(hidden_ship_tiles))\n","name":"program_277","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row D?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'D' to its 0-based index (A=0, B=1, C=2, D=3)\n    row_index = ord('D') - ord('A')\n    \n    # Extract that row from both boards\n    true_row = true_board[row_index]\n    partial_row = partial_board[row_index]\n    \n    # A tile contains an unrevealed ship if true_board > 0 and partial_board == -1\n    unrevealed_ships = (true_row > 0) & (partial_row == -1)\n    \n    # If any such tile exists, answer \"yes\" (True), otherwise \"no\" (False)\n    return bool(np.any(unrevealed_ships))\n","name":"program_278","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row E?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'E' to zero\u2010based index (A=0, B=1, \u2026, H=7)\n    row_index = ord('E') - ord('A')\n    # Extract the row from both boards\n    true_row = true_board[row_index]\n    partial_row = partial_board[row_index]\n    # A ship tile is any true_board cell > 0. Unrevealed means partial_board == -1.\n    unrevealed_ship_tiles = (true_row > 0) & (partial_row == -1)\n    # If there's at least one unrevealed ship tile in row E, answer Yes (True)\n    return bool(unrevealed_ship_tiles.any())\n","name":"program_279","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Nothing in Row G?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Check Row G (0-based index 6) for any hidden ship tiles.\n    row_idx = ord('G') - ord('A')\n    # A hidden tile in the captain's view is marked -1\n    hidden_mask = (partial_board[row_idx] == -1)\n    # A ship tile in the true board is > 0\n    ship_mask = (true_board[row_idx] > 0)\n    # If there is any position that's both hidden and a ship, then\n    # there is still a ship in Row G.\n    return not np.any(hidden_mask & ship_mask)\n","name":"program_280","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all cells that are still hidden in the partial board but\n    # actually contain a ship in the true board.\n    mask = (partial_board == -1) & (true_board > 0)\n    rows, cols = np.where(mask)\n\n    # If there are no hidden ship\u2010cells, then there's nothing horizontal to report.\n    if rows.size == 0:\n        return False\n\n    # Identify the row (or rows) that still have hidden ship\u2010cells.\n    # In our current context only one row will have hidden ships.\n    target_rows = np.unique(rows)\n    # For simplicity, take the first such row.\n    r = target_rows[0]\n\n    # For each hidden ship\u2010cell in that row, check if its ship extends\n    # horizontally (i.e., it has a like\u2010valued neighbor left or right).\n    ncols = true_board.shape[1]\n    for c in cols[rows == r]:\n        ship_id = true_board[r, c]\n        # check left\n        if c > 0 and true_board[r, c - 1] == ship_id:\n            return True\n        # check right\n        if c < ncols - 1 and true_board[r, c + 1] == ship_id:\n            return True\n\n    # If none of the hidden ship\u2010cells in that row connect horizontally,\n    # then the orientation must be vertical (or there are no ships).\n    return False\n","name":"program_281","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any more ships in row E?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row E corresponds to index 4 (A=0, B=1, C=2, D=3, E=4)\n    row_index = 4\n    # A ship tile is any true_board entry > 0.\n    # An unrevealed tile in partial_board is marked as -1.\n    unrevealed_ships_in_E = (true_board[row_index] > 0) & (partial_board[row_index] == -1)\n    return bool(np.any(unrevealed_ships_in_E))\n","name":"program_282","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"any in Row a","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row 'A' to index 0\n    row_idx = 0\n    \n    # A tile is an unrevealed ship tile if:\n    #  1) true_board has a ship (> 0)\n    #  2) partial_board is still hidden (-1)\n    unrevealed_ships_in_A = (true_board[row_idx, :] > 0) & (partial_board[row_idx, :] == -1)\n    \n    # If any such tile exists, answer Yes (True), otherwise No (False)\n    return bool(np.any(unrevealed_ships_in_A))\n","name":"program_283","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"1-5?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We're asked: \"1-5?\" \u2192 Are there any unrevealed ship tiles in columns 1 through 5?\n    # Columns 1\u20135 correspond to indices 0\u20134 in zero-based numpy arrays.\n    cols = slice(0, 5)\n    # Identify unrevealed tiles in that column range\n    hidden = partial_board[:, cols] == -1\n    # Identify actual ship tiles in that column range\n    ships = true_board[:, cols] > 0\n    # Return True if there's at least one hidden ship tile\n    return bool(np.any(hidden & ships))\n","name":"program_284","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"re there any other ships in row C","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'C' to its 0\u2010based index\n    row_idx = ord('C') - ord('A')\n    # A ship tile is any cell > 0 in true_board.\n    # A hidden tile is any cell == -1 in partial_board.\n    # We ask: is there at least one tile in row C that is a ship in true_board\n    # but still hidden in partial_board?\n    hidden_ship_tiles = (true_board[row_idx, :] > 0) & (partial_board[row_idx, :] == -1)\n    return bool(np.any(hidden_ship_tiles))\n","name":"program_285","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"6-8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Columns 6\u20138 correspond to indices 5, 6, and 7.\n    cols = slice(5, 8)\n    # Identify cells in those columns that are still hidden on the partial board\n    hidden = (partial_board[:, cols] == -1)\n    # Identify ship cells on the true board (values > 0)\n    ships = (true_board[:, cols] > 0)\n    # If there is any hidden ship cell in columns 6\u20138, answer is True\n    return np.any(hidden & ships)\n","name":"program_286","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"any others in row D","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify the index for row D (A=0, B=1, C=2, D=3)\n    row_idx = ord('D') - ord('A')\n    # A ship tile is any value > 0 in true_board.\n    # A hidden tile in partial_board is marked by -1.\n    # We check if there exists any hidden ship tile in row D.\n    hidden = (partial_board[row_idx] == -1)\n    ship   = (true_board[row_idx] > 0)\n    return bool(np.any(hidden & ship))\n","name":"program_287","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any in row e","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We're checking row E (row index 4 since A=0, B=1, \u2026, E=4).\n    row_index = ord('E') - ord('A')\n    # A tile is an unrevealed ship if true_board > 0 but partial_board is still hidden (-1).\n    unrevealed_in_row = (true_board[row_index] > 0) & (partial_board[row_index] == -1)\n    return np.any(unrevealed_in_row)\n","name":"program_288","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"1-5?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to know if there are any unrevealed ship tiles in row E, columns 1\u20135.\n    # Row E corresponds to index 4 (0-based), and columns 1\u20135 correspond to indices 0\u20134.\n    row_idx = ord('E') - ord('A')\n    cols = slice(0, 5)\n    \n    # A ship tile is true_board > 0; unrevealed is partial_board == -1.\n    ships_in_region = (true_board[row_idx, cols] > 0)\n    unrevealed_in_region = (partial_board[row_idx, cols] == -1)\n    \n    # If there is any position where both are true, answer \"Yes\".\n    return bool(np.any(ships_in_region & unrevealed_in_region))\n","name":"program_289","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"6-8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # The Captain just asked \"6-8?\" referring to row E (the last row queried).\n    # Row E is index 4 (0-based). Columns 6\u20138 correspond to indices 5,6,7.\n    row_idx = 4\n    cols = slice(5, 8)\n    # We want to know if there are any ship tiles in true_board[row_idx, cols]\n    # that are still hidden in partial_board (i.e. == -1).\n    is_ship = true_board[row_idx, cols] > 0\n    is_hidden = partial_board[row_idx, cols] == -1\n    return bool(np.any(is_ship & is_hidden))\n","name":"program_290","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any in row B","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the index for row 'B' (A\u21920, B\u21921, etc.)\n    row_index = ord('B') - ord('A')\n    # Extract that row from both boards\n    true_row = true_board[row_index, :]\n    partial_row = partial_board[row_index, :]\n    # Check if there is any ship tile (>0) in the true board\n    # that remains unrevealed (-1) in the partial board\n    return bool(np.any((true_row > 0) & (partial_row == -1)))\n","name":"program_291","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"1-5","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to know if any hidden ship\u2010tile remains in columns 1\u20135 (0\u20134 index).\n    # A hidden ship\u2010tile is one where true_board>0 (there is a ship)\n    # but partial_board==-1 (it\u2019s still unrevealed).\n    cols = slice(0, 5)              # columns 1\u20135\n    hidden_ship_mask = (true_board[:, cols] > 0) & (partial_board[:, cols] == -1)\n    return bool(np.any(hidden_ship_mask))\n","name":"program_292","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"6-8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row B is index 1 (0-based), columns 6\u20138 are indices 5\u20137\n    # We want to know if there is any ship tile in B6, B7, or B8\n    # that has not yet been revealed.\n    segment_true = true_board[1, 5:8]\n    segment_partial = partial_board[1, 5:8]\n    # A ship tile is indicated by a value > 0 in true_board,\n    # and it's still hidden if partial_board == -1\n    hidden_ship_tiles = (segment_true > 0) & (segment_partial == -1)\n    return bool(np.any(hidden_ship_tiles))\n","name":"program_293","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"any others in row E","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We're checking \"any others in row E\". Row 'E' is index 4 (0-based).\n    row = 4\n    # A ship tile is indicated by a value > 0 in true_board.\n    # An unrevealed tile is -1 in partial_board.\n    # We look for positions in row E where there's a ship in true_board\n    # but that tile is still hidden in partial_board.\n    hidden_ship_tiles = (true_board[row, :] > 0) & (partial_board[row, :] == -1)\n    return bool(np.any(hidden_ship_tiles))\n","name":"program_294","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any other ships in this row","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all rows where the captain has already scored at least one hit\n    hit_rows = np.where((partial_board > 0).any(axis=1))[0]\n    if hit_rows.size == 0:\n        # No hits yet, so \u201cthis row\u201d is undefined \u2192 answer No\n        return False\n\n    # Assume \u201cthis row\u201d is the one with the highest index (i.e. most recent)\n    row = hit_rows.max()\n\n    # Now check if in that row there is any tile which\n    #  - truly contains a ship (true_board > 0)\n    #  - is still hidden to the captain (partial_board == -1)\n    hidden_ship_mask = (true_board[row] > 0) & (partial_board[row] == -1)\n    return bool(hidden_ship_mask.any())\n","name":"program_295","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any ships in row A?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in row A,\n    otherwise returns False.\n    \"\"\"\n    # Row A corresponds to index 0\n    row_idx = 0\n\n    # A hidden tile is marked -1 in partial_board\n    hidden_mask = (partial_board[row_idx] == -1)\n    # A ship tile is any non-zero value in true_board\n    ship_mask = (true_board[row_idx] > 0)\n\n    # If there exists any column in row A that is both hidden and a ship, return True\n    return bool(np.any(hidden_mask & ship_mask))\n","name":"program_296","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any ships in row C?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We're answering: \"Any ships in row C?\"\n    # Row C corresponds to index 2 (A\u21920, B\u21921, C\u21922)\n    row_idx = ord('C') - ord('A')\n    # Identify which tiles in row C are still hidden\n    hidden_mask = (partial_board[row_idx] == -1)\n    # Identify which tiles in row C contain ship parts in the true board\n    ship_mask = (true_board[row_idx] > 0)\n    # If there is any tile that is both hidden and a ship part, answer is True\n    return bool(np.any(hidden_mask & ship_mask))\n","name":"program_297","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is at least one ship still hidden that is\n    oriented horizontally (i.e. all of its tiles lie in the same row).\n    \"\"\"\n    # Look at each ship type present on the true board\n    for ship_id in np.unique(true_board):\n        if ship_id <= 0:\n            # Skip water (0) and hidden markers (-1)\n            continue\n\n        # Find all the coordinates of this ship on the true board\n        coords = np.argwhere(true_board == ship_id)\n        # A ship must occupy at least 2 tiles\n        if coords.shape[0] < 2:\n            continue\n\n        # Check if those tiles all share the same row index\n        rows = coords[:, 0]\n        if not np.all(rows == rows[0]):\n            # Not a horizontal ship\n            continue\n\n        # Finally, check if this ship is still (at least partially) hidden\n        # i.e. any of its coordinates are still marked -1 in partial_board\n        for r, c in coords:\n            if partial_board[r, c] == -1:\n                # We found a horizontal ship that has at least one hidden tile\n                return True\n\n    # No horizontal, still-hidden ships found\n    return False\n","name":"program_298","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # 1) Find all ship\u2010IDs that have at least one revealed tile in partial_board\n    revealed_ids = np.unique(partial_board[partial_board > 0])\n    \n    # 2) Of those, keep only the ship(s) that are not yet fully found:\n    #    i.e. partial count < true count\n    candidates = []\n    for sid in revealed_ids:\n        total_tiles = np.count_nonzero(true_board == sid)\n        found_tiles = np.count_nonzero(partial_board == sid)\n        if found_tiles < total_tiles:\n            candidates.append(sid)\n    \n    # 3) If exactly one candidate remains, that's the ship we're asking about.\n    #    Otherwise we cannot be sure which ship\u2014return False by default.\n    if len(candidates) != 1:\n        return False\n    ship_id = candidates[0]\n    \n    # 4) Get all the coordinates of that ship on the true_board\n    coords = np.argwhere(true_board == ship_id)\n    rows = coords[:, 0]\n    cols = coords[:, 1]\n    \n    # 5) It's horizontal iff all of its row\u2010indices are the same\n    return np.all(rows == rows[0])\n","name":"program_299","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"C 1-3?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We're being asked about row C, columns 1 through 3.\n    # Convert row 'C' to a 0\u2010based index:\n    row_idx = ord('C') - ord('A')  # 'A'->0, 'B'->1, 'C'->2\n    \n    # Convert columns 1\u20133 to 0\u2010based indices:\n    col_start = 1 - 1\n    col_end = 3      # slicing in Python is exclusive on the upper bound\n    \n    # Extract the true and partial segments\n    true_segment = true_board[row_idx, col_start:col_end]\n    partial_segment = partial_board[row_idx, col_start:col_end]\n    \n    # A hidden ship tile is one where true_board>0 (a ship)\n    # but partial_board is still -1 (hidden).\n    hidden_ships = (true_segment > 0) & (partial_segment == -1)\n    \n    # If any such tile exists, the answer to \"C 1-3?\" is Yes (True), otherwise No.\n    return np.any(hidden_ships)\n","name":"program_300","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any more ships in row A?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We interpret row A as index 0\n    row_index = 0\n    # In the true board, ship tiles are > 0\n    # In the partial board, hidden tiles are marked -1\n    # We look for any tile in row A that is both a ship in true_board and still hidden in partial_board\n    hidden_ships = (true_board[row_index] > 0) & (partial_board[row_index] == -1)\n    return bool(np.any(hidden_ships))\n","name":"program_301","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row B?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Check row B (index 1) for any ship tiles (>0) that are still hidden (-1) in partial_board\n    row_index = ord('B') - ord('A')\n    ships_in_row_b = (true_board[row_index] > 0)\n    hidden_in_row_b = (partial_board[row_index] == -1)\n    # If there is at least one hidden ship tile in row B, answer \"Yes\"\n    return bool(np.any(ships_in_row_b & hidden_in_row_b))\n","name":"program_302","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # ship IDs are positive integers in true_board (1,2,3,4\u2026).\n    # we\u2019ll loop over each ship ID, check if any tile is still hidden,\n    # and if so determine its orientation.\n    \n    # collect the set of ship\u2010IDs present\n    ship_ids = set(np.unique(true_board)) - {0, -1}\n    \n    for sid in ship_ids:\n        # get all positions of this ship\n        positions = np.argwhere(true_board == sid)\n        # check if any of this ship's tiles is still hidden in the partial\n        still_hidden = any(partial_board[tuple(pos)] == -1 for pos in positions)\n        if not still_hidden:\n            # this ship is fully revealed or sunk; skip it\n            continue\n        \n        # if the ship is size 1 it's neither horizontal nor vertical (but that won't happen here)\n        if len(positions) > 1:\n            # sort by row then col\n            rows = positions[:,0]\n            cols = positions[:,1]\n            # if all rows are the same \u2192 horizontal\n            if np.all(rows == rows[0]):\n                return True\n            # if all cols the same \u2192 vertical\n            # otherwise something irregular (won\u2019t occur in valid Battleship)\n    # no remaining ship is horizontal\n    return False\n","name":"program_303","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any ships in row F?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter F to index 5 (A->0, B->1, ..., H->7)\n    row_idx = ord('F') - ord('A')\n    # A ship tile is > 0 in true_board. A hidden tile is -1 in partial_board.\n    # We check if there is any position in row F that is both a ship in true_board\n    # and still hidden in partial_board.\n    hidden_ship_cells = (true_board[row_idx] > 0) & (partial_board[row_idx] == -1)\n    return bool(np.any(hidden_ship_cells))\n","name":"program_304","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any ships in column 8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to know if there are any *unrevealed* ship tiles in column 8.\n    # In numpy indexing that's column index 7 (0-based).\n    col = 7\n    # A ship tile is any true_board entry > 0.\n    # An unrevealed tile is any partial_board entry == -1.\n    # Combine these two conditions to find hidden ship parts in column 8.\n    hidden_ship_in_col8 = (true_board[:, col] > 0) & (partial_board[:, col] == -1)\n    return bool(np.any(hidden_ship_in_col8))\n","name":"program_305","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are one of the ships in a corner spot?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True iff there is at least one *unrevealed* ship tile\n    in any of the four corner cells of the board.\n    \"\"\"\n    nrows, ncols = true_board.shape\n    # Define the four corner coordinates\n    corners = [\n        (0, 0),\n        (0, ncols - 1),\n        (nrows - 1, 0),\n        (nrows - 1, ncols - 1)\n    ]\n    # Check each corner: is it a ship in true_board and still hidden in partial_board?\n    for r, c in corners:\n        if true_board[r, c] > 0 and partial_board[r, c] == -1:\n            return True\n    return False\n","name":"program_306","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship in the center of the board? D4\/5 or E4\/5","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Define the center coordinates D4, D5, E4, E5 in zero\u2010based indexing\n    center_rows = [3, 4]  # D, E\n    center_cols = [3, 4]  #  4, 5\n\n    # Check if any of those tiles contains an unrevealed ship\n    for r in center_rows:\n        for c in center_cols:\n            if true_board[r, c] > 0 and partial_board[r, c] == -1:\n                return True\n    return False\n","name":"program_307","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the orange ship horizontal","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the orange ship (denoted by 4)\n    coords = np.argwhere(true_board == 4)\n    # If there are no orange ship tiles, we can't say it's horizontal\n    if coords.size == 0:\n        return False\n    # Extract the unique row indices and unique column indices\n    unique_rows = np.unique(coords[:, 0])\n    unique_cols = np.unique(coords[:, 1])\n    # If all tiles share the same row, it's horizontal\n    return len(unique_rows) == 1\n","name":"program_308","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship between F and G?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in rows F or G (i.e. between rows F and G), otherwise False.\n    Rows are zero-indexed A\u21920, B\u21921, ..., H\u21927 so F\u21925 and G\u21926.\n    \"\"\"\n    # indices for rows F and G\n    rows = [5, 6]\n    # A ship tile in true_board is > 0; a hidden tile in partial_board is == -1\n    # We look for any position in those rows that is a ship on true_board\n    # but still hidden on partial_board.\n    mask = (true_board[rows, :] > 0) & (partial_board[rows, :] == -1)\n    return bool(np.any(mask))\n","name":"program_309","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the purple ship vertical","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the purple ship (denoted by 3)\n    coords = np.argwhere(true_board == 3)\n    \n    # If for some reason the ship isn't fully placed or only one tile, we cannot say it's vertical\n    if coords.shape[0] < 2:\n        return False\n\n    # Extract the column indices of those tiles\n    cols = coords[:, 1]\n    \n    # The ship is vertical if all column indices are the same\n    return np.all(cols == cols[0])\n","name":"program_310","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the purple ship surrounded by water","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the purple ship (denoted by 3) is completely surrounded\n    by water (0) on all adjacent tiles (including diagonals), and False otherwise.\n    \"\"\"\n    ship_id = 3\n    n_rows, n_cols = true_board.shape\n    \n    # Find all coordinates of the purple ship\n    ship_cells = np.argwhere(true_board == ship_id)\n    \n    # Check every neighboring cell around each ship cell\n    for r, c in ship_cells:\n        for dr in (-1, 0, 1):\n            for dc in (-1, 0, 1):\n                if dr == 0 and dc == 0:\n                    continue  # skip the ship cell itself\n                nr, nc = r + dr, c + dc\n                # only consider in\u2010bounds neighbors\n                if 0 <= nr < n_rows and 0 <= nc < n_cols:\n                    neighbor_val = true_board[nr, nc]\n                    # if it's another ship (and not part of the purple ship),\n                    # then purple is not fully surrounded by water\n                    if neighbor_val != 0 and neighbor_val != ship_id:\n                        return False\n    # No non-water neighbors found\n    return True\n","name":"program_311","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship between 2 and 4 above the green ship","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the row indices of the green ship (value 2).\n    ship_rows, ship_cols = np.nonzero(true_board == 2)\n    # Determine the topmost row of the green ship.\n    top_of_green = ship_rows.min()\n    \n    # Columns \u201cbetween 2 and 4\u201d in 1-based labeling correspond to indices 1 through 3 (inclusive).\n    col_start = 1\n    col_end = 3\n    \n    # Consider all tiles strictly above the green ship (rows less than top_of_green)\n    # and in columns 1..3.\n    above_region = np.zeros_like(true_board, dtype=bool)\n    above_region[0:top_of_green, col_start:col_end+1] = True\n    \n    # We only care about ship tiles (true_board > 0) that remain hidden (partial_board == -1).\n    hidden_ships_above = above_region & (true_board > 0) & (partial_board == -1)\n    \n    # If any hidden ship tile is in that region, answer is True.\n    return bool(hidden_ships_above.any())\n","name":"program_312","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there A ship in row a?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in row A (index 0).\n    \"\"\"\n    # Row A corresponds to index 0\n    row_index = 0\n    \n    # Extract the true row and the partial row\n    true_row = true_board[row_index, :]\n    partial_row = partial_board[row_index, :]\n    \n    # An unrevealed ship tile is where true_board > 0 and partial_board == -1\n    unrevealed_ship_mask = (true_row > 0) & (partial_row == -1)\n    \n    # If any such tile exists, return True\n    return bool(np.any(unrevealed_ship_mask))\n","name":"program_313","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship in row H?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine if there is any unrevealed ship tile in row H.\n    # Row H corresponds to index 7 (0-based, A=0, B=1, \u2026, H=7).\n    row_index = ord('H') - ord('A')\n    \n    # A tile is an unrevealed ship tile if:\n    #   true_board has a value > 0 (ship) AND partial_board is still -1 (hidden)\n    unrevealed_ship_in_H = (true_board[row_index, :] > 0) & (partial_board[row_index, :] == -1)\n    \n    return bool(np.any(unrevealed_ship_in_H))\n","name":"program_314","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the Purple Ship Vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the purple ship (denoted by 3) is placed vertically.\n    A ship is vertical if all of its tiles share the same column index.\n    \"\"\"\n    # Find the coordinates of every tile that belongs to the purple ship\n    coords = np.argwhere(true_board == 3)\n    \n    # Extract the column indices of those coordinates\n    _, cols = coords.T\n    \n    # If all column indices are identical, the ship is vertical\n    return np.all(cols == cols[0])\n","name":"program_315","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it under the red or purple columns?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We interpret \"under the red or purple columns\" to mean:\n    #   Is there any hidden (partial_board == -1) ship tile (true_board > 0)\n    #   in row H (index 7) whose column index matches any column\n    #   where the Captain has already revealed a Red (1) or Purple (3) tile?\n    #\n    # Step 1: Find all columns where partial_board has a revealed Red or Purple.\n    rp_mask = (partial_board == 1) | (partial_board == 3)  # True wherever we saw a 1 or 3\n    rp_cols = np.where(rp_mask.any(axis=0))[0]              # column indices of those reveals\n\n    # Step 2: Build a mask for row H (row index 7):\n    row_h = 7\n    hidden_mask    = (partial_board[row_h] == -1)  # still hidden\n    ship_mask      = (true_board[row_h]    >  0)  # actually contains a ship segment\n    rp_column_mask = np.zeros(partial_board.shape[1], dtype=bool)\n    rp_column_mask[rp_cols] = True                 # mark red\/purple columns\n\n    # Step 3: Check if any tile in row H meets all three conditions.\n    candidate = hidden_mask & ship_mask & rp_column_mask\n    return bool(np.any(candidate))\n","name":"program_316","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"I there a ship in row B?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We are asked: \"Is there a ship in row B?\"\n    # Row B is the second row in zero\u2010based indexing:\n    row_index = 1\n\n    # A ship tile is any true_board entry > 0.\n    ship_tiles = true_board[row_index] > 0\n\n    # An unrevealed tile is any partial_board entry == -1.\n    hidden_tiles = partial_board[row_index] == -1\n\n    # If there exists at least one tile in row B that is both a ship\n    # and still hidden, answer True; otherwise False.\n    return bool(np.any(ship_tiles & hidden_tiles))\n","name":"program_317","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row C?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row C is index 2 (0-based: A=0, B=1, C=2)\n    row_idx = 2\n    # A tile counts as an unrevealed ship if it's > 0 on the true board\n    # but still -1 (hidden) on the partial board\n    unrevealed_ship_tiles = (true_board[row_idx] > 0) & (partial_board[row_idx] == -1)\n    return bool(np.any(unrevealed_ship_tiles))\n","name":"program_318","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"row G?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letters A\u2013H to indices 0\u20137; G corresponds to index 6\n    row_idx = 6\n    # A ship tile is any entry > 0 in true_board.\n    # An unrevealed tile in partial_board is indicated by -1.\n    # We want to know if there's any tile in row G that is a ship in true_board\n    # but still hidden in partial_board.\n    mask_ship = true_board[row_idx] > 0\n    mask_hidden = partial_board[row_idx] == -1\n    # If there's any position where both masks are True, there's an unrevealed ship tile.\n    return bool(np.any(mask_ship & mask_hidden))\n","name":"program_319","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row F?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row F is index 5 (A=0, B=1, ..., F=5)\n    row_idx = 5\n    # A hidden ship tile is one where the true board has a ship (>0)\n    # but the partial board still shows it as hidden (-1).\n    hidden_ships_in_F = (true_board[row_idx, :] > 0) & (partial_board[row_idx, :] == -1)\n    return bool(np.any(hidden_ships_in_F))\n","name":"program_320","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row E?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row E is the 5th row, index 4\n    row_idx = 4\n    # A ship remains in row E if there is any tile where:\n    # - The true board has a ship (>0)\n    # - The partial board is still hidden (-1)\n    unrevealed_ship = (true_board[row_idx, :] > 0) & (partial_board[row_idx, :] == -1)\n    return bool(np.any(unrevealed_ship))\n","name":"program_321","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row D?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the row index for 'D' (A\u21920, B\u21921, C\u21922, D\u21923)\n    row_idx = ord('D') - ord('A')\n    # Extract that row from both boards\n    true_row = true_board[row_idx]\n    partial_row = partial_board[row_idx]\n    # A ship tile is present if true_row > 0, and it's unrevealed if partial_row == -1\n    unrevealed_ship_tiles = (true_row > 0) & (partial_row == -1)\n    # Return True if there's at least one unrevealed ship tile in row D\n    return bool(unrevealed_ship_tiles.any())\n","name":"program_322","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship in the outer rows and columns?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Create a mask for the outermost rows and columns\n    outer_mask = np.zeros_like(true_board, dtype=bool)\n    outer_mask[0, :]  = True  # Row A\n    outer_mask[-1, :] = True  # Row H\n    outer_mask[:, 0]  = True  # Column 1\n    outer_mask[:, -1] = True  # Column 8\n\n    # Identify unrevealed tiles\n    unrevealed = (partial_board == -1)\n    # Identify ship tiles\n    ships = (true_board > 0)\n\n    # Check if any ship tile is both in the outer border and still unrevealed\n    return bool(np.any(outer_mask & unrevealed & ships))\n","name":"program_323","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there one in H row?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row H corresponds to index 7 (0-based indexing for an 8x8 board)\n    row_index = 7\n    \n    # A ship is present and unrevealed if true_board > 0 but partial_board is still -1\n    unrevealed_ship_tiles = (true_board[row_index] > 0) & (partial_board[row_index] == -1)\n    \n    # If any such tile exists, answer \"Yes\"\n    return np.any(unrevealed_ship_tiles)\n","name":"program_324","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the purple ship in the green rows","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if every tile of the purple ship (value 3 in true_board)\n    lies in a row that contains at least one green ship tile (value 2 in true_board).\n    \"\"\"\n    # Find all row indices that contain any green ship tiles\n    green_rows = np.where(np.any(true_board == 2, axis=1))[0]\n    \n    # Find all row indices where purple ship tiles are located\n    purple_rows = np.where(true_board == 3)[0]\n    \n    # Check that every purple row is among the green rows\n    return set(purple_rows).issubset(set(green_rows))\n","name":"program_325","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"B or C","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # The Captain is asking whether the purple ship (value 3) \n    # has any unrevealed tile in row B or row C.\n    # Row B is index 1, row C is index 2 (0-based).\n    \n    # Build a mask of unrevealed purple tiles\n    purple_unrevealed = (true_board == 3) & (partial_board == -1)\n    \n    # Check rows B (1) and C (2)\n    rows_to_check = [1, 2]\n    \n    # If any unrevealed purple tile lies in row B or C, answer yes\n    return np.any(purple_unrevealed[rows_to_check, :])\n","name":"program_326","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship in the red columns?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # find all column indices where the captain has a red\u2010ship hit (value==1)\n    red_cols = np.where(np.any(partial_board == 1, axis=0))[0]\n    # for each such column, check if there is any hidden ship tile remaining\n    for c in red_cols:\n        # true_board>0 are all ship tiles; partial_board==-1 are still hidden\n        if np.any((true_board[:, c] > 0) & (partial_board[:, c] == -1)):\n            return True\n    return False\n","name":"program_327","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the green horizontal","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the green ship (value 2)\n    green_locs = np.argwhere(true_board == 2)\n    \n    # Extract the row indices of those coordinates\n    rows = green_locs[:, 0]\n    \n    # If all row indices are the same, the ship is horizontal\n    return np.all(rows == rows[0])\n","name":"program_328","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row A?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Check row A (index 0) for any ship tiles (>0) that are still hidden (-1) in partial_board\n    row_index = 0  # Row A\n    # Create a boolean mask: True where there's a ship in true_board and that spot is still hidden in partial_board\n    hidden_ship_mask = (true_board[row_index, :] > 0) & (partial_board[row_index, :] == -1)\n    # If any True in the mask, there is at least one unrevealed ship tile in row A\n    return bool(np.any(hidden_ship_mask))\n","name":"program_329","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row H?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the row index for 'H' (A->0, B->1, ..., H->7)\n    row_idx = ord('H') - ord('A')\n    \n    # Extract the true values and partial (revealed\/hidden) status for that row\n    true_row = true_board[row_idx, :]\n    partial_row = partial_board[row_idx, :]\n    \n    # An unrevealed ship tile is one where partial_board == -1 and true_board > 0\n    unrevealed_ship_tiles = np.logical_and(partial_row == -1, true_row > 0)\n    \n    # If any such tile exists, the answer is True (Yes), otherwise False (No)\n    return bool(unrevealed_ship_tiles.any())\n","name":"program_330","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row B?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # The question is asking about Row B, which is index 1 (0-based indexing).\n    row_index = 1\n    \n    # A cell is an unrevealed ship tile if:\n    #  - true_board[row_index, col] > 0  (there is a ship)\n    #  - partial_board[row_index, col] == -1  (it is still hidden)\n    unrevealed_ship_tiles = (true_board[row_index] > 0) & (partial_board[row_index] == -1)\n    \n    # If there is at least one such tile, the answer is True (\"Yes\"), otherwise False (\"No\").\n    return bool(np.any(unrevealed_ship_tiles))\n","name":"program_331","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row G?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We're being asked: \"Row G?\"\n    # In zero\u2010based indexing, row A=0, B=1, \u2026, G=6.\n    row_idx = 6\n    # Find any tiles in row G that are still hidden (partial_board == -1)\n    # and actually contain ship pieces in true_board (>0).\n    unseen_ships = (partial_board[row_idx] == -1) & (true_board[row_idx] > 0)\n    return bool(np.any(unseen_ships))\n","name":"program_332","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Past Column 5 and row B?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Captain's question: \"Past Column 5 and Row B?\"\n    i.e. are there any *unrevealed* ship tiles in the sub\u2010region\n    with rows > B (row index 1) and columns > 5 (col index 4)?\n    \"\"\"\n    # Row B is index 1 (A=0, B=1), Column 5 is index 4\n    r0 = 1  # B\n    c0 = 4  # 5\n    \n    # Slice out the \"past Column 5 and past Row B\" quadrant\n    sub_true    = true_board[r0+1:, c0+1:]\n    sub_partial = partial_board[r0+1:, c0+1:]\n    \n    # A tile is an unrevealed ship tile if true_board>0 and partial_board==-1\n    unrevealed_ships = (sub_true > 0) & (sub_partial == -1)\n    \n    # If any such tile exists, answer is True ('Yes'), else False ('No')\n    return np.any(unrevealed_ships)\n","name":"program_333","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row F","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'F' to its 0-based index (A\u21920, B\u21921, \u2026, H\u21927)\n    row_idx = ord('F') - ord('A')\n    # Extract the true and partial rows\n    true_row = true_board[row_idx]\n    partial_row = partial_board[row_idx]\n    # A hidden tile in partial_board is -1; a ship tile in true_board is > 0.\n    # If there exists any column where the tile is still hidden and actually contains a ship,\n    # we answer \"Yes\" (True), otherwise \"No\" (False).\n    hidden_ship_mask = (partial_row == -1) & (true_row > 0)\n    return bool(np.any(hidden_ship_mask))\n","name":"program_334","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the column >=5?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # we are asked \"Is the column \u2265 5?\" about the one row\n    # the Captain just confirmed (Row F), so we must find\n    # the unique row that is still fully hidden but does contain a ship.\n    hidden = (partial_board == -1)\n    rows_fully_hidden = np.where(np.all(hidden, axis=1))[0]\n    # among fully\u2010hidden rows pick the one that actually has a ship\n    candidate_rows = [r for r in rows_fully_hidden if np.any(true_board[r] != 0)]\n    if candidate_rows:\n        row = candidate_rows[0]\n        # now check if any of that row's unrevealed ship\u2010cells sit at col index \u2265 4\n        ncols = true_board.shape[1]\n        cols = np.arange(ncols)\n        # build a mask for this row: ship & hidden & col>=4\n        mask = (true_board[row] != 0) & (hidden[row]) & (cols >= 4)\n        return bool(np.any(mask))\n    else:\n        # fallback: if for some reason no single row stands out, \n        # just answer if any hidden ship\u2010cell on the entire board is in col>=5\n        ncols = true_board.shape[1]\n        cols = np.arange(ncols)\n        col_mask = cols >= 4\n        # broadcast col_mask over rows\n        col_mask2 = np.tile(col_mask, (true_board.shape[0], 1))\n        mask = (true_board != 0) & (hidden) & (col_mask2)\n        return bool(np.any(mask))\n","name":"program_335","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row C?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row C corresponds to index 2 (0-based indexing: A\u21920, B\u21921, C\u21922)\n    row_idx = 2\n    # A hidden ship tile is one where true_board > 0 but partial_board is still -1\n    hidden_ship_tiles = (true_board[row_idx] > 0) & (partial_board[row_idx] == -1)\n    # If any such tile exists, answer \"Yes\"\n    return bool(np.any(hidden_ship_tiles))\n","name":"program_336","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row C And column >= 5?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to know if there is any unrevealed ship tile in row C (index 2)\n    # and in columns 5\u20138 (indices 4\u20137).\n    row_idx = 2\n    # A ship tile in true_board is > 0; a hidden tile in partial_board is -1.\n    region_has_ship = (true_board[row_idx, 4:] > 0)\n    region_is_hidden = (partial_board[row_idx, 4:] == -1)\n    # If there's any position that is both a ship and hidden, answer True.\n    return bool(np.any(region_has_ship & region_is_hidden))\n","name":"program_337","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"row e?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Compute zero\u2010based index for row 'E'\n    row_e = ord('E') - ord('A')\n    \n    # A ship cell is any value > 0 in true_board.\n    # We look for ship cells that are still hidden in partial_board (marked -1).\n    hidden_ships_in_row = (true_board[row_e] > 0) & (partial_board[row_e] == -1)\n    \n    # If any are True, then there is at least one hidden ship cell in row E.\n    return bool(np.any(hidden_ships_in_row))\n","name":"program_338","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"in 6 7 or 8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Captain just asked: \"In columns 6, 7 or 8?\" \n    (Context: we already established we're looking at row E.)\n    Columns are 1-indexed in the game; NumPy arrays are 0-indexed.\n    So columns 6, 7, 8 correspond to indices 5, 6, 7.\n    Row E corresponds to index 4.\n    We return True if there's any ship tile in true_board at (E,6\u20138)\n    that is still hidden in partial_board (i.e. partial_board == -1).\n    \"\"\"\n    row_e = 4                  # 'E' \u2192 4 in 0-based indexing\n    cols_6_to_8 = slice(5, 8)  # indices 5,6,7\n\n    true_segment = true_board[row_e, cols_6_to_8]\n    partial_segment = partial_board[row_e, cols_6_to_8]\n\n    # A tile is an unrevealed ship if true_board>0 and partial_board==-1\n    unrevealed_ships = (true_segment > 0) & (partial_segment == -1)\n    return bool(np.any(unrevealed_ships))\n","name":"program_339","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # 1) find which ship\u2010IDs have been hit at least once\n    hits = partial_board > 0\n    hit_ids = np.unique(partial_board[hits])\n    \n    # 2) among those, find the one that is not yet fully revealed (i.e. not sunk)\n    for ship_id in hit_ids:\n        total_tiles = np.count_nonzero(true_board == ship_id)\n        revealed_tiles = np.count_nonzero(partial_board == ship_id)\n        if revealed_tiles < total_tiles:\n            # this is the \u201ccurrent\u201d ship the Captain is poking at\n            # grab its true coordinates:\n            coords = np.argwhere(true_board == ship_id)\n            # coords is an array of [row, col] pairs.\n            # if all cols are the same \u2192 vertical\n            return np.unique(coords[:, 1]).size == 1\n    \n    # if we didn't find any partially\u2010hit ship, default to False\n    return False\n","name":"program_340","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any more on Row c or d?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there are any unrevealed ship tiles on row C or D,\n    otherwise False.\n    \"\"\"\n    # A, B, C, D correspond to row indices 0, 1, 2, 3\n    rows_cd = slice(2, 4)  # selects rows C and D\n    # A tile is an unrevealed ship segment if:\n    #   true_board > 0  (it's part of a ship)\n    # and partial_board == -1 (still hidden to the Captain)\n    unrevealed = (true_board > 0) & (partial_board == -1)\n    # Check any in rows C or D\n    return bool(np.any(unrevealed[rows_cd, :]))\n","name":"program_341","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship in A?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is at least one unrevealed ship tile in row A,\n    i.e. row index 0, False otherwise.\n    \"\"\"\n    row_idx = 0  # Row A corresponds to index 0\n    # Hidden tiles on the partial board are marked -1\n    hidden = partial_board[row_idx] == -1\n    # In the true board, ship tiles are any value > 0\n    ship_tiles = true_board[row_idx] > 0\n    # If any position is both hidden and actually a ship, return True\n    return bool(np.any(hidden & ship_tiles))\n","name":"program_342","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"above 4?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # The question \"above 4?\" asks whether there are any unrevealed ship tiles\n    # in rows above row 4 (D).  Rows are 1-indexed: A=1, B=2, C=3, D=4.\n    # Convert to 0-based index:\n    target_row = 4 - 1  # row \"4\" \u2192 index 3\n    # If there are no rows above that, answer is False\n    if target_row <= 0:\n        return False\n    # Take all rows strictly above that index: rows 0 through target_row-1\n    tr = true_board[:target_row, :]\n    pr = partial_board[:target_row, :]\n    # An unrevealed ship tile is one where true_board>0 but partial_board==-1\n    return bool(np.any((tr > 0) & (pr == -1)))\n","name":"program_343","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there still a ship under the orange columns?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find which columns have already revealed orange ship tiles (value 4)\n    orange_cols = np.unique(np.where(partial_board == 4)[1])\n    \n    # In those columns, check if there remain any hidden ship tiles\n    for c in orange_cols:\n        # A tile is a hidden ship tile if:\n        #  - partial_board is -1 (hidden)\n        #  - true_board > 0 (some ship occupies it)\n        hidden_ship_mask = (partial_board[:, c] == -1) & (true_board[:, c] > 0)\n        if np.any(hidden_ship_mask):\n            return True\n    \n    return False\n","name":"program_344","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship in the red rows","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify the rows that contain any revealed red\u2010ship tile (value == 1)\n    red_row_mask = np.any(partial_board == 1, axis=1)\n    # For each of those rows, check if there is any hidden tile (partial == -1)\n    # that on the true board is part of a ship (true > 0)\n    for row_idx in np.flatnonzero(red_row_mask):\n        hidden_sites = (partial_board[row_idx] == -1)\n        if np.any(true_board[row_idx, hidden_sites] > 0):\n            return True\n    return False\n","name":"program_345","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship under the orange columns","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find which columns contain the orange ship (value 4)\n    orange_cols = np.unique(np.where(true_board == 4)[1])\n    # In those columns, look for any ship tile (>0) that is still hidden (-1 in partial_board)\n    sub_true = true_board[:, orange_cols]\n    sub_partial = partial_board[:, orange_cols]\n    hidden_ship_tiles = (sub_true > 0) & (sub_partial == -1)\n    return bool(np.any(hidden_ship_tiles))\n","name":"program_346","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"between B and D?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # map row letters to indices\n    rows = ['A','B','C','D','E','F','G','H']\n    start = rows.index('B')\n    end   = rows.index('D')\n    # strictly between B and D means C only\n    between = range(min(start, end) + 1, max(start, end))\n    \n    # for each such row, check if there's any ship tile (>0) that is still hidden (-1)\n    for r in between:\n        # true_board[r, :] > 0 marks all ship squares\n        # partial_board[r, :] == -1 marks all unrevealed squares\n        if np.any((true_board[r, :] > 0) & (partial_board[r, :] == -1)):\n            return True\n    return False\n","name":"program_347","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row A?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row A corresponds to index 0\n    row_idx = 0\n\n    # A ship tile is any value > 0 in true_board.\n    # It's unrevealed if partial_board is still -1 there.\n    unrevealed_ship_tiles = (true_board[row_idx] > 0) & (partial_board[row_idx] == -1)\n\n    # If any such tile exists, answer 'Yes' (True), otherwise 'No' (False).\n    return bool(np.any(unrevealed_ship_tiles))\n","name":"program_348","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":">=5?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all positions of still-hidden ship tiles\n    # (partial_board == -1) & (true_board > 0)\n    hidden_ship = (partial_board == -1) & (true_board > 0)\n\n    # Get the column indices of those positions\n    # np.where returns (row_indices, col_indices)\n    _, col_idx = np.where(hidden_ship)\n\n    # Columns are 0-based; we want columns 5\u20138 which are indices 4\u20137\n    return np.any(col_idx >= 4)\n","name":"program_349","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find any revealed hit on the partial board (value > 0)\n    hit_positions = np.argwhere(partial_board > 0)\n    if hit_positions.size == 0:\n        # No hit revealed yet; by convention answer \"No\"\n        return False\n\n    # Take the ship ID at the first revealed hit\n    r, c = hit_positions[0]\n    ship_id = partial_board[r, c]\n\n    # Find all the true positions of that ship on the full board\n    true_positions = np.argwhere(true_board == ship_id)\n    # Columns of those positions\n    cols = true_positions[:, 1]\n\n    # The ship is vertical if all its true positions share the same column\n    return bool(np.all(cols == cols[0]))\n","name":"program_350","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it in row e or lower?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A hidden tile is marked -1 in partial_board\n    hidden = (partial_board == -1)\n    # A ship tile is marked >0 in true_board\n    ship   = (true_board > 0)\n    # Combine to find hidden ship tiles\n    hidden_ship = hidden & ship\n    # Rows E or lower correspond to row indices 4,5,6,7 (0-based A=0,...,H=7)\n    return hidden_ship[4:, :].any()\n","name":"program_351","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"row g or h?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed ship tile in row G or H\n    (i.e., rows with indices 6 or 7), otherwise False.\n    \"\"\"\n    # Rows G and H correspond to indices 6 and 7\n    rows_to_check = [6, 7]\n\n    # A tile is an unrevealed ship if true_board > 0 (ship) and partial_board == -1 (hidden)\n    unrevealed_ships = (true_board[rows_to_check, :] > 0) & (partial_board[rows_to_check, :] == -1)\n\n    return bool(np.any(unrevealed_ships))\n","name":"program_352","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"e?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row E corresponds to index 4 (A=0, B=1, C=2, D=3, E=4)\n    row_idx = 4\n    # Identify tiles in row E that are still hidden on the partial board\n    hidden = (partial_board[row_idx] == -1)\n    # Identify where the true board has ship parts (>0)\n    ships  = (true_board[row_idx] > 0)\n    # If there's any position that is both hidden and a ship, answer \"Yes\"\n    return bool(np.any(hidden & ships))\n","name":"program_353","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any below the purple ships?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one *hidden* ship tile directly below\n    any purple ship tile (value == 3) on the true_board, otherwise False.\n    \"\"\"\n    rows, cols = true_board.shape\n    \n    for i in range(rows - 1):           # no need to check the last row\n        for j in range(cols):\n            # find a purple tile\n            if true_board[i, j] == 3:\n                # look at the tile directly below\n                below_i = i + 1\n                # if it is a ship tile in the true board and still hidden\n                if true_board[below_i, j] > 0 and partial_board[below_i, j] == -1:\n                    return True\n    return False\n","name":"program_354","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"below any of the red or orange columns?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed ship part below any column\n    that already contains a revealed red (1) or orange (4) tile.\n    \"\"\"\n    # Identify columns that have at least one revealed red or orange tile\n    red_orange_mask = np.isin(partial_board, [1, 4])\n    cols_with_red_orange = np.where(red_orange_mask.any(axis=0))[0]\n    \n    # For each such column, look below the lowest revealed red\/orange tile\n    for j in cols_with_red_orange:\n        # rows in which red\/orange is revealed in column j\n        revealed_rows = np.where(red_orange_mask[:, j])[0]\n        if revealed_rows.size == 0:\n            continue\n        lowest_reveal = revealed_rows.max()\n        \n        # slice of the column below that row\n        below_true    = true_board[lowest_reveal+1:, j]\n        below_partial = partial_board[lowest_reveal+1:, j]\n        \n        # check for any hidden ship part (true_board>0 & partial_board==-1)\n        if np.any((below_true > 0) & (below_partial == -1)):\n            return True\n    \n    return False\n","name":"program_355","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"and Below row e?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there are any undiscovered ship tiles in rows below row E (i.e., rows F, G, H),\n    otherwise returns False.\n    \"\"\"\n    # Row E corresponds to index 4 ('A'\u21920, 'B'\u21921, ..., 'E'\u21924).\n    # We want rows with index > 4.\n    rows_below_e = slice(5, true_board.shape[0])  # rows 5, 6, 7\n    \n    # A ship tile is any value > 0 in true_board.\n    # We only care about those that are still hidden to the captain (partial_board == -1).\n    ships_below = (true_board[rows_below_e] > 0) & (partial_board[rows_below_e] == -1)\n    \n    # If any such tile exists, answer is True; otherwise False.\n    return bool(np.any(ships_below))\n","name":"program_356","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine if the currently partially revealed (but not yet sunk) ship is oriented horizontally.\n    We identify which ship code has been hit but not fully uncovered, then check its full positions\n    on the true board to see if all its tiles lie in the same row.\n    \"\"\"\n    # Possible ship codes\n    ship_codes = [1, 2, 3, 4]\n\n    # Find the \"in\u2010progress\" ship: one with some hits in partial_board but not fully revealed\n    target_code = None\n    for code in ship_codes:\n        hits_revealed = np.count_nonzero(partial_board == code)\n        total_tiles = np.count_nonzero(true_board == code)\n        # If we've hit it at least once but haven't found all its tiles, it's our target\n        if 0 < hits_revealed < total_tiles:\n            target_code = code\n            break\n\n    # If there's no in\u2010progress ship, we cannot answer; default to False\n    if target_code is None:\n        return False\n\n    # Get all positions of that ship on the true board\n    rows, cols = np.where(true_board == target_code)\n\n    # It's horizontal if all the row indices are the same\n    return np.all(rows == rows[0])\n","name":"program_357","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any more in those rows?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A ship\u2010square is any cell > 0.  Hidden is -1, water is 0.\n    # Find all rows where the captain has seen at least one ship.\n    rows_with_seen = np.any(partial_board > 0, axis=1)\n    \n    # For each such row, compare total ships in the true board vs. ships already revealed.\n    for r in np.where(rows_with_seen)[0]:\n        total_in_true = np.count_nonzero(true_board[r] > 0)\n        revealed = np.count_nonzero(partial_board[r] > 0)\n        if total_in_true > revealed:\n            return True\n    return False\n","name":"program_358","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the orange ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the orange ship (denoted by 4)\n    coords = np.argwhere(true_board == 4)\n    if coords.size == 0:\n        # No orange ship on the board\n        return False\n    # Extract row indices and column indices\n    rows, cols = coords[:, 0], coords[:, 1]\n    # If all columns are the same, it's vertical\n    return np.all(cols == cols[0])\n","name":"program_359","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the longest ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the longest ship on the true_board is oriented vertically,\n    False otherwise.\n    \"\"\"\n    # Identify all ship IDs (exclude water = 0 and hidden = -1)\n    ship_ids = [sid for sid in np.unique(true_board) if sid > 0]\n\n    max_length = 0\n    is_vertical = False\n\n    for sid in ship_ids:\n        # Find all coordinates of this ship\n        coords = np.argwhere(true_board == sid)\n        length = coords.shape[0]\n        if length > max_length:\n            max_length = length\n            rows, cols = coords[:, 0], coords[:, 1]\n            # Vertical if rows vary and cols are constant\n            is_vertical = (rows.max() > rows.min() and cols.max() == cols.min())\n\n    return is_vertical\n","name":"program_360","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the top square of the orange ship in A?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all row indices where the orange ship (coded as 4) is located\n    orange_rows, _ = np.where(true_board == 4)\n    \n    # If there are no orange squares, answer is False\n    if orange_rows.size == 0:\n        return False\n    \n    # The \"top\" square is the one with the smallest row index\n    top_row = orange_rows.min()\n    \n    # Row A corresponds to index 0\n    return top_row == 0\n","name":"program_361","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the bottom square in D?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the orange ship (denoted by 4)\n    orange_coords = np.argwhere(true_board == 4)\n    if orange_coords.size == 0:\n        # No orange ship found (shouldn't happen in a valid game)\n        return False\n\n    # The ship is vertical, so the \"bottom\" square has the maximum row index\n    bottom_row_index = orange_coords[:, 0].max()\n\n    # Rows A-H correspond to indices 0-7; 'D' is index 3\n    return bottom_row_index == 3\n","name":"program_362","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship in Row D?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the index for row 'D'\n    row_idx = ord('D') - ord('A')\n    # A ship tile is > 0 in true_board. We only care about those not yet revealed (partial_board == -1).\n    unrevealed_ship_in_row = (true_board[row_idx, :] > 0) & (partial_board[row_idx, :] == -1)\n    return bool(np.any(unrevealed_ship_in_row))\n","name":"program_363","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the orange ship in column 7?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if any square of the orange ship (value 4) lies in column 7 (1\u2010based),\n    i.e. index 6 (0\u2010based), otherwise False.\n    \"\"\"\n    # Value 4 denotes the orange ship\n    ORANGE = 4\n    # Convert the 1-based column (7) to 0-based index (6)\n    target_col = 6\n    # Find all positions of the orange ship\n    orange_cells = np.argwhere(true_board == ORANGE)\n    # Check if any of those cells has column index == target_col\n    return np.any(orange_cells[:, 1] == target_col)\n","name":"program_364","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Column 8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Column 8 corresponds to index 7\n    col = 7\n    # A ship tile in true_board is > 0, and it must still be hidden in partial_board (== -1)\n    hidden_ship_in_col8 = (true_board[:, col] > 0) & (partial_board[:, col] == -1)\n    return bool(np.any(hidden_ship_in_col8))\n","name":"program_365","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship in Row C?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in row C (index 2),\n    otherwise returns False.\n    \"\"\"\n    # Identify unrevealed positions\n    unrevealed = (partial_board == -1)\n    # Identify ship positions\n    ships = (true_board > 0)\n    # Check for any tile in row C that is both a ship and still unrevealed\n    return bool(np.any(unrevealed[2, :] & ships[2, :]))\n","name":"program_366","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Since the questions don't cost anything confirming the final tile is C8","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert \"C8\" into zero-based indices: row C -> 2, column 8 -> 7\n    row = ord('C') - ord('A')\n    col = 8 - 1\n    # Confirm that the tile is still hidden and that it contains a ship (>0)\n    return (partial_board[row, col] == -1) and (true_board[row, col] > 0)\n","name":"program_367","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the green ship longer than 2 squares?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Count all tiles labeled '2' (the green ship) in the true board\n    green_length = np.count_nonzero(true_board == 2)\n    # Return True if that count is greater than 2\n    return green_length > 2\n","name":"program_368","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the other 2 square ship located in the top half? (A-D)","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine if the one remaining (i.e., not fully revealed) 2-square ship lies entirely\n    in the top half of the board (rows A\u2013D, which correspond to indices 0\u20133).\n    \"\"\"\n    # Identify which ship IDs in the true_board have exactly 2 squares\n    two_square_ids = []\n    for ship_id in [1, 2, 3, 4]:\n        if np.sum(true_board == ship_id) == 2:\n            two_square_ids.append(ship_id)\n\n    # Among those, find the one that is not already fully revealed in partial_board\n    for ship_id in two_square_ids:\n        revealed_squares = np.sum(partial_board == ship_id)\n        if revealed_squares < 2:\n            # This is the \"other\" 2-square ship\n            rows, cols = np.where(true_board == ship_id)\n            # Check if all its row indices are in 0\u20133 (A\u2013D)\n            return np.all(rows <= 3)\n\n    # If for some reason no 2-square ship is left unrevealed, answer False\n    return False\n","name":"program_369","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the longest ship in G?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the length of each ship (IDs are 1=Red, 2=Green, 3=Purple, 4=Orange)\n    ship_ids = [1, 2, 3, 4]\n    lengths = {sid: int(np.sum(true_board == sid)) for sid in ship_ids}\n    \n    # Find the maximum length\n    max_length = max(lengths.values())\n    \n    # Identify which ship(s) have that maximum length\n    longest_ships = [sid for sid, length in lengths.items() if length == max_length]\n    \n    # Row G corresponds to index 6 (A=0, B=1, ..., G=6)\n    row_g_index = ord('G') - ord('A')\n    \n    # Check if any tile of any longest ship lies in row G\n    for sid in longest_ships:\n        if np.any(true_board[row_g_index, :] == sid):\n            return True\n    return False\n","name":"program_370","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there more red squares left (yes) or right (no) of the red squares I've found?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find the columns of all red squares (code 1) already revealed on the partial board\n    revealed_positions = np.argwhere(partial_board == 1)\n    if revealed_positions.size == 0:\n        # If the Captain hasn't found any red squares yet, we cannot say there\n        # are strictly more on one side, so default to False (i.e. \"no\")\n        return False\n\n    # Determine the leftmost and rightmost columns of the discovered red squares\n    discovered_cols = revealed_positions[:, 1]\n    min_col, max_col = discovered_cols.min(), discovered_cols.max()\n\n    # Identify hidden red squares on the true board (true_board == 1)\n    # that have not yet been revealed (partial_board != 1).\n    hidden_red = (true_board == 1) & (partial_board != 1)\n    hidden_positions = np.argwhere(hidden_red)\n\n    # If there are no hidden red squares, then there are none left on either side.\n    if hidden_positions.size == 0:\n        return False\n\n    # Count how many of those hidden red squares lie strictly to the left\n    # of the leftmost discovered column, and how many lie strictly to the right\n    hidden_cols = hidden_positions[:, 1]\n    left_count = np.sum(hidden_cols < min_col)\n    right_count = np.sum(hidden_cols > max_col)\n\n    # Return True if there are more hidden red squares to the left,\n    # otherwise False (meaning \"no\", there are not more on the left).\n    return left_count > right_count\n","name":"program_371","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is at least one square of the orange ship in 5-8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if at least one square of the orange ship (value 4)\n    lies in columns 5 through 8 (i.e. zero\u2010based indices 4 through 7).\n    \"\"\"\n    # Find the column indices of all orange\u2010ship squares\n    _, orange_cols = np.where(true_board == 4)\n    # Check if any of those columns is in the range 4..7 (which correspond to 5..8)\n    return bool(np.any(orange_cols >= 4))\n","name":"program_372","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the longest ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the longest ship on the board is placed horizontally.\n    We scan true_board for each ship code > 0, measure its length and orientation,\n    then check among the ships with maximal length if any is horizontal.\n    \"\"\"\n    # Collect (length, is_horizontal) for each ship\n    ship_stats = []\n    for ship_id in np.unique(true_board):\n        if ship_id <= 0:\n            continue\n        # Get all coordinates of this ship\n        coords = np.argwhere(true_board == ship_id)  # shape: (length, 2)\n        length = coords.shape[0]\n        # If all row indices are equal, it's horizontal; otherwise vertical\n        is_horizontal = np.all(coords[:, 0] == coords[0, 0])\n        ship_stats.append((length, is_horizontal))\n    \n    # Find the maximum ship length\n    max_len = max(length for length, _ in ship_stats)\n    \n    # Check if any ship of that max length is horizontal\n    for length, is_h in ship_stats:\n        if length == max_len and is_h:\n            return True\n    return False\n","name":"program_373","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there any more ships in row G?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row G corresponds to index 6 (0-based indexing: A=0, B=1, \u2026, G=6)\n    row_idx = 6\n\n    # Find positions in row G that are still hidden on the partial board\n    hidden_positions = (partial_board[row_idx] == -1)\n\n    # Among those hidden positions, check if true_board has any ship (> 0)\n    unrevealed_ships = (true_board[row_idx] > 0) & hidden_positions\n\n    # If there is at least one such tile, answer is True; otherwise False\n    return bool(np.any(unrevealed_ships))\n","name":"program_374","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there any ships in row A?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in row A (index 0),\n    otherwise False.\n    \"\"\"\n    # Row A corresponds to index 0\n    row_true = true_board[0, :]\n    row_partial = partial_board[0, :]\n    # A ship tile is indicated by >0 in true_board,\n    # an unrevealed tile is indicated by -1 in partial_board.\n    unrevealed_ship = (row_true > 0) & (row_partial == -1)\n    return bool(np.any(unrevealed_ship))\n","name":"program_375","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there any more ships in row F?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We're checking row F, which is the 6th row (0-indexed as 5)\n    row_idx = ord('F') - ord('A')\n    # A ship is any cell > 0 in the true board\n    ship_cells = true_board[row_idx] > 0\n    # A hidden cell is marked as -1 in the partial board\n    hidden_cells = partial_board[row_idx] == -1\n    # If there's any cell that is both a ship and still hidden, return True\n    return bool(np.any(ship_cells & hidden_cells))\n","name":"program_376","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there any more ships in Row A?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row A corresponds to index 0 in the numpy array\n    row_idx = 0\n\n    # Identify which tiles in row A are still hidden on the partial board\n    hidden_in_row = partial_board[row_idx] == -1\n\n    # Identify which tiles in row A on the true board contain part of a ship (> 0)\n    ship_in_row = true_board[row_idx] > 0\n\n    # If there is any position that is both hidden and actually a ship, answer is True\n    return bool(np.any(hidden_in_row & ship_in_row))\n","name":"program_377","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there any more ships in row C?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in row C.\n    \"\"\"\n    # Map row letter 'C' to 0-based index\n    row_idx = ord('C') - ord('A')\n    # Find positions in row C that are still hidden on the partial board\n    hidden_mask = (partial_board[row_idx] == -1)\n    # Among those hidden positions, check if any actually contain a ship on the true board\n    ship_mask = (true_board[row_idx] > 0)\n    # If there's any column where both are True, there's an unrevealed ship tile\n    return bool(np.any(hidden_mask & ship_mask))\n","name":"program_378","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there any ships in row E?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row E corresponds to index 4 (0-based, with A=0, B=1, ..., H=7)\n    row_index = 4\n    \n    # A ship tile is indicated by a value > 0 in true_board.\n    # Hidden tiles on partial_board are marked as -1.\n    # We check if there is any position in row E where:\n    #   true_board has a ship (>0) AND partial_board is still hidden (-1).\n    unrevealed_ship_in_row_e = np.any(\n        (true_board[row_index, :] > 0) & (partial_board[row_index, :] == -1)\n    )\n    \n    return bool(unrevealed_ship_in_row_e)\n","name":"program_379","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the purple ship more then 2 squares?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the purple ship (encoded as 3 in true_board) occupies more than 2 tiles.\n    \"\"\"\n    # Count all cells in true_board equal to 3 (purple ship)\n    purple_count = np.count_nonzero(true_board == 3)\n    return purple_count > 2\n","name":"program_380","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there more colored squares in the top half (yes) or bottom half (no)?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there are more ship squares in the top half of the board\n    than in the bottom half, otherwise False.\n    \"\"\"\n    # Number of rows in the board\n    n_rows = true_board.shape[0]\n    # Split index (top half is rows [0 : half), bottom half is [half : n_rows))\n    half = n_rows \/\/ 2\n\n    # Count non-zero entries (ship tiles) in each half\n    top_count = np.count_nonzero(true_board[:half] != 0)\n    bottom_count = np.count_nonzero(true_board[half:] != 0)\n\n    return top_count > bottom_count\n","name":"program_381","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship in column 6?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We're interested in column 6, which is index 5 (0-based).\n    col_idx = 5\n    \n    # A ship cell is any positive entry in true_board.\n    is_ship = true_board[:, col_idx] > 0\n    \n    # An unrevealed cell in partial_board is marked as -1.\n    is_unrevealed = partial_board[:, col_idx] == -1\n    \n    # If there's any ship cell in column 6 that is still hidden, answer Yes.\n    return bool(np.any(is_ship & is_unrevealed))\n","name":"program_382","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"In column 7?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to know if there is any *unrevealed* ship tile in column 7 (1-based),\n    # which is index 6 in 0-based numpy arrays.\n    col = 6\n    # A ship tile in true_board is any entry > 0.\n    # A hidden tile in partial_board is indicated by -1.\n    # We check if there exists at least one position in column 6\n    # where true_board has a ship and partial_board is still hidden.\n    mask_ship = true_board[:, col] > 0\n    mask_hidden = partial_board[:, col] == -1\n    return bool(np.any(mask_ship & mask_hidden))\n","name":"program_383","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the top square of the ship in column 6 at C6 or higher?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to look at column 6 (0-based index 5) of the true board\n    col = 5\n\n    # Mask of all ship\u2010cells in that column\n    ship_cells = np.where(true_board[:, col] > 0)[0]  # row indices of ship parts\n    \n    # If there are no ships in that column, answer is False\n    if ship_cells.size == 0:\n        return False\n\n    # Split into contiguous vertical segments\n    # e.g. if ship_cells = [3,4,5,6, 3] for two ships you might get [[3,4,5,6],[3]]\n    breaks = np.where(np.diff(ship_cells) > 1)[0] + 1\n    segments = np.split(ship_cells, breaks)\n\n    # If there's more than one segment, pick the longest one\n    lengths = [len(seg) for seg in segments]\n    longest = segments[np.argmax(lengths)]\n\n    # The \"top\" square is the smallest row index in that segment\n    top_row = int(longest.min())\n\n    # Row C corresponds to index 2; we ask if top_row \u2264 2\n    return top_row <= 2\n","name":"program_384","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the red ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the red ship (denoted by 1)\n    coords = np.argwhere(true_board == 1)\n    # Extract their column indices\n    cols = coords[:, 1]\n    # If all red\u2010ship tiles share the same column, it's vertical\n    return np.unique(cols).size == 1\n","name":"program_385","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the last square D3?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Step 1: find all ship\u2010IDs on the board\n    ship_ids = [sid for sid in np.unique(true_board) if sid > 0]\n    \n    # Step 2: for each ship, compare how many squares are revealed vs. total\n    incomplete = []\n    for sid in ship_ids:\n        total = np.count_nonzero(true_board == sid)\n        revealed = np.count_nonzero(partial_board == sid)\n        # we only care about ships that are partly revealed but not yet complete\n        if 0 < revealed < total:\n            incomplete.append(sid)\n    \n    # If there's exactly one such ship, that's the one the Captain is asking about.\n    if len(incomplete) != 1:\n        # no clear \u201clast\u2010square\u201d candidate or ambiguous\n        return False\n    \n    target_id = incomplete[0]\n    \n    # Step 3: parse D3 \u2192 row index 3, col index 2 (0\u2010based)\n    row = ord('D') - ord('A')\n    col = 3 - 1\n    \n    # Step 4: answer whether that spot in the true board belongs to the target ship\n    return (true_board[row, col] == target_id)\n","name":"program_386","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the 4 square ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all positive ship\u2010IDs and their counts\n    ship_ids, counts = np.unique(true_board[true_board > 0], return_counts=True)\n    \n    # Identify which ship has exactly 4 squares\n    # (there should be exactly one such ship in a valid setup)\n    four_sq_ship = ship_ids[counts == 4]\n    if four_sq_ship.size != 1:\n        # If there's not exactly one 4\u2010square ship, we cannot answer unambiguously\n        raise ValueError(\"Board does not contain exactly one 4\u2010square ship.\")\n    ship_id = four_sq_ship[0]\n    \n    # Get the (row, col) coordinates of that ship\n    coords = np.argwhere(true_board == ship_id)\n    # coords is an N\u00d72 array: each row is [r, c]\n    \n    # If all column indices are equal, it's vertical\n    cols = coords[:, 1]\n    return bool(np.all(cols == cols[0]))\n","name":"program_387","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the 5 square ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify the ship\u2010code that occupies exactly 5 squares on the true board\n    ship_codes = [code for code in np.unique(true_board) if code > 0]\n    for code in ship_codes:\n        if np.count_nonzero(true_board == code) == 5:\n            # Get the (row, col) indices of that ship\n            positions = np.argwhere(true_board == code)\n            # A ship is vertical if all of its column indices are the same\n            return len(np.unique(positions[:, 1])) == 1\n    # If there is no 5\u2010square ship found (shouldn't happen in a valid game), answer False\n    return False\n","name":"program_388","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is either in column 1-4?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to check the two remaining ships (the ones of length 4 and length 5)\n    # and answer whether either of them occupies any column in 1\u20134 (0\u20133 in zero\u2010based indexing).\n    \n    # 1) Gather the coordinates of each ship by its ID (1,2,3,4).\n    ship_coords = {}\n    for ship_id in np.unique(true_board):\n        if ship_id <= 0:\n            continue\n        coords = np.argwhere(true_board == ship_id)\n        ship_coords[ship_id] = coords\n\n    # 2) Look for a ship of length 4 and one of length 5,\n    #    then check if any of their tiles lie in columns 0\u20133.\n    for target_length in (4, 5):\n        for coords in ship_coords.values():\n            if coords.shape[0] == target_length:\n                # coords[:,1] is the column index for all cells of this ship\n                if (coords[:, 1] < 4).any():\n                    return True\n                # once we've found and tested the correct\u2010sized ship, break out\n                break\n\n    return False\n","name":"program_389","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there any ships in row h?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row 'H' \u2192 index 7 (0-based)\n    row_idx = ord('H') - ord('A')\n    # A ship tile is any value >0 in true_board\n    ship_mask = true_board[row_idx] > 0\n    # Hidden tiles are those still marked -1 in partial_board\n    hidden_mask = partial_board[row_idx] == -1\n    # If any position in row H is both a ship and still hidden, answer YES\n    return bool(np.any(ship_mask & hidden_mask))\n","name":"program_390","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there any ship in row A?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row A corresponds to index 0\n    row_idx = 0\n    # A ship tile is > 0 in true_board.\n    # An unrevealed tile is marked as -1 in partial_board.\n    unrevealed_ships_in_row = (true_board[row_idx] > 0) & (partial_board[row_idx] == -1)\n    return bool(np.any(unrevealed_ships_in_row))\n","name":"program_391","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there any ships in row F?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the row index for 'F' (0-based: A=0, B=1, ..., F=5)\n    row_index = ord('F') - ord('A')\n    \n    # A tile is an unrevealed ship tile if:\n    #  - the true board has a ship (> 0)\n    #  - the partial board still shows it as hidden (-1)\n    unrevealed_ship_tiles = (true_board[row_index, :] > 0) & (partial_board[row_index, :] == -1)\n    \n    # If any such tile exists, answer is True (yes), otherwise False (no)\n    return np.any(unrevealed_ship_tiles)\n","name":"program_392","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the 3 square ship on the bottom half?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the index of the middle row (0-based). For an 8\u00d78 board, rows 0\u20133 are top half, 4\u20137 bottom half.\n    half = true_board.shape[0] \/\/ 2\n    \n    # Find which ship has exactly 3 tiles by counting occurrences of each ship ID.\n    for ship_id in np.unique(true_board):\n        if ship_id <= 0:\n            continue\n        count = np.sum(true_board == ship_id)\n        if count == 3:\n            # Get the row indices of that ship's tiles\n            rows, _ = np.where(true_board == ship_id)\n            # Check if all those rows lie in the bottom half\n            return bool(np.all(rows >= half))\n    \n    # If no 3-tile ship was found, answer No by default\n    return False\n","name":"program_393","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is at least one of the 4-square ships vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine if at least one of the ships of length 4 on true_board is placed vertically.\n    \"\"\"\n    # Find all unique ship identifiers (ignore 0 = water, -1 if any hidden markers)\n    ship_ids = [sid for sid in np.unique(true_board) if sid > 0]\n\n    for sid in ship_ids:\n        # Extract coordinates of this ship\n        coords = np.argwhere(true_board == sid)\n        length = coords.shape[0]\n        # Only interested in ships of length 4\n        if length == 4:\n            # coords[:,0] are row indices, coords[:,1] are column indices\n            rows = coords[:, 0]\n            cols = coords[:, 1]\n            # Vertical if all columns equal but rows differ\n            if np.all(cols == cols[0]) and len(np.unique(rows)) == 4:\n                return True\n\n    return False\n","name":"program_394","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are either of the remaining ships vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if at least one of the ships that is not yet fully revealed\n    is placed vertically on the true_board, otherwise False.\n    \"\"\"\n    # Look at each ship ID on the true board\n    for ship_id in np.unique(true_board):\n        if ship_id <= 0:\n            # skip water\/hiddens\n            continue\n        \n        # Find all the coordinates occupied by this ship on the true board\n        coords = np.argwhere(true_board == ship_id)  # shape (n_tiles, 2)\n        \n        # If it's a single\u2010tile ship, it cannot be vertical in the usual sense\n        if coords.shape[0] < 2:\n            continue\n        \n        # Check if this ship still has any hidden tiles on the partial board\n        # i.e. tiles where true_board == ship_id but partial_board == -1\n        still_hidden = (true_board == ship_id) & (partial_board == -1)\n        if not np.any(still_hidden):\n            # fully revealed, skip\n            continue\n        \n        # Determine orientation: if all columns are the same, it's vertical\n        cols = coords[:, 1]\n        if np.all(cols == cols[0]):\n            return True\n    \n    # No remaining (partially hidden) ship is vertical\n    return False\n","name":"program_395","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is at least one of the 4-square ships in the top half?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if at least one of the ships of length 4 on true_board\n    lies entirely within the top half of the board (rows 0..n_rows\/\/2-1).\n    \"\"\"\n    n_rows = true_board.shape[0]\n    half = n_rows \/\/ 2\n\n    # find all distinct positive ship labels\n    for ship_id in np.unique(true_board):\n        if ship_id <= 0:\n            continue\n        \n        # get all the coordinates occupied by this ship\n        coords = np.argwhere(true_board == ship_id)\n        \n        # check if this ship has exactly 4 tiles\n        if coords.shape[0] == 4:\n            # check if all of its tiles lie in the top half\n            if np.all(coords[:, 0] < half):\n                return True\n\n    return False\n","name":"program_396","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the vertical one in columns 1-4?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to know if any of the *remaining* vertical ships\n    # lies entirely in columns 1\u20134 (1-indexed), i.e. columns 0\u20133 in 0-indexing.\n    \n    # Collect all ship IDs that are not fully revealed yet.\n    remaining = []\n    for ship_id in np.unique(true_board):\n        if ship_id <= 0:\n            continue\n        # Coordinates of this ship on the true board\n        coords = np.argwhere(true_board == ship_id)\n        # Check if all of those coords are already uncovered in partial_board\n        # (i.e. partial_board at those coords == ship_id)\n        all_revealed = True\n        for r, c in coords:\n            if partial_board[r, c] != ship_id:\n                all_revealed = False\n                break\n        if not all_revealed:\n            remaining.append(ship_id)\n    \n    # Now check each remaining ship for vertical orientation,\n    # and if so, whether it lies entirely in cols 0\u20133.\n    for ship_id in remaining:\n        coords = np.argwhere(true_board == ship_id)\n        cols = coords[:, 1]\n        # vertical if all cols are equal and length > 1\n        if coords.shape[0] > 1 and np.all(cols == cols[0]):\n            # check if that column is in 0\u20133\n            if cols[0] <= 3:\n                return True\n    \n    return False\n","name":"program_397","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it in A-B (yes) or C-D (no)?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the 4\u2010square ship that lies in the top half of the board\n    (rows A\u2013D) is located in rows A\u2013B (return True) or in rows C\u2013D (return False).\n    \n    We identify all ships of length 4, pick the one contained entirely in rows A\u2013D,\n    then check whether all of its row indices are in A\u2013B.\n    \"\"\"\n    # Loop over ship IDs (1\u20134) present on the board\n    for ship_id in np.unique(true_board):\n        if ship_id <= 0:\n            continue  # skip water and hidden\n        # Get the coordinates of this ship\n        coords = np.argwhere(true_board == ship_id)\n        # Check if it is length 4 and oriented (straight line)\n        if coords.shape[0] == 4:\n            rows = coords[:, 0]\n            cols = coords[:, 1]\n            if (np.all(rows == rows[0]) or np.all(cols == cols[0])):\n                # It's a 4\u2010square ship; now check if it's in the top half A\u2013D\n                if rows.max() <= 3:\n                    # Now answer whether it's in A\u2013B (rows 0\u20131)\n                    return bool(rows.max() <= 1)\n    # Fallback (should not happen in valid game state):\n    return False\n","name":"program_398","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it in A?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Answer to the question \"Is it in A?\"\n    We interpret this as: \"Is there any unrevealed ship tile in row A?\"\n    Row A corresponds to index 0 of the numpy array.\n    \"\"\"\n    # Select row A (index 0) from both boards\n    true_row_A    = true_board[0, :]\n    partial_row_A = partial_board[0, :]\n\n    # A ship tile is any cell where true_board > 0.\n    # An unrevealed tile is any cell where partial_board == -1.\n    # We ask: is there at least one position in row A that\n    # is a ship (true_board > 0) and still hidden (partial_board == -1)?\n    hidden_ship_in_A = (true_row_A > 0) & (partial_row_A == -1)\n\n    return bool(np.any(hidden_ship_in_A))\n","name":"program_399","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it in 7?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the as\u2010yet unrevealed vertical ship (the one\n    already narrowed down to columns 7\u20108) lies in column 7.\n    \"\"\"\n    # A mask of all still\u2010hidden ship squares\n    hidden_ship = (true_board > 0) & (partial_board == -1)\n    # Which ship\u2010IDs still have unrevealed squares?\n    remaining_ids = np.unique(true_board[hidden_ship])\n    \n    for ship_id in remaining_ids:\n        # All coordinates of this ship in the full board\n        coords = np.argwhere(true_board == ship_id)\n        if coords.size == 0:\n            continue\n        \n        # We only care about ships that are still partly hidden\n        if not np.any(hidden_ship & (true_board == ship_id)):\n            continue\n        \n        # Check orientation: vertical ships occupy a single column\n        cols = coords[:, 1]\n        if np.all(cols == cols[0]):\n            # This is a vertical ship.  What is its column?\n            col_index = int(cols[0])        # 0\u2010based index\n            col_number = col_index + 1      # 1\u2010based column\n            # Return True if that column is 7, False otherwise\n            return (col_number == 7)\n    \n    # If we find no remaining vertical ship, answer \"No\"\n    return False\n","name":"program_400","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the final ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the one remaining (not-fully-revealed) ship is placed\n    horizontally on the board.\n\n    Returns True if the remaining ship is horizontal, False otherwise.\n    \"\"\"\n    # Identify all ship IDs present on the true board (positive integers).\n    ship_ids = np.unique(true_board)\n    ship_ids = ship_ids[ship_ids > 0]\n\n    for sid in ship_ids:\n        # Coordinates of this ship on the true board.\n        ship_coords = np.argwhere(true_board == sid)\n\n        # Check how many of its squares are still hidden in partial_board.\n        hidden_squares = np.sum((true_board == sid) & (partial_board == -1))\n        if hidden_squares > 0:\n            # This is the \u201cfinal\u201d ship (still has unrevealed parts).\n            # Determine orientation by looking at its full set of coordinates.\n            rows, cols = ship_coords[:, 0], ship_coords[:, 1]\n            # If all row indices are identical, it's horizontal.\n            return bool(np.all(rows == rows[0]))\n\n    # If no ship is partially hidden, default to False.\n    return False\n","name":"program_401","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the other 4-square ship in the bottom half?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # 1) Find all ship\u2010labels that occupy exactly 4 cells.\n    #    We ignore water (0) and hidden (-1) since true_board has only 0\u20134.\n    labels, counts = np.unique(true_board[true_board > 0], return_counts=True)\n    four_sq_labels = labels[counts == 4]\n\n    # 2) Of those length\u20104 ships, determine which one has any cell already\n    #    revealed in partial_board.  We assume a revealed ship cell in partial_board\n    #    will equal its true label; hidden cells are -1.\n    found = None\n    for lab in four_sq_labels:\n        mask = (true_board == lab)\n        # if any of those positions in partial_board match the label,\n        # the Captain has found (revealed) part of that ship\n        if np.any(partial_board[mask] == lab):\n            found = lab\n            break\n\n    # 3) The \u201cother\u201d 4\u2010square ship is the one in four_sq_labels that isn\u2019t `found`.\n    other_labels = [lab for lab in four_sq_labels if lab != found]\n    if not other_labels:\n        # no other 4\u2010square ship found (shouldn\u2019t happen in a proper game)\n        return False\n\n    other_label = other_labels[0]\n    other_coords = np.argwhere(true_board == other_label)\n    \n    # 4) Check whether that ship lies entirely in the bottom half.\n    #    Board has 8 rows (0\u20137).  Bottom half means rows 4,5,6,7.\n    bottom_start = true_board.shape[0] \/\/ 2   # 8\/\/2 == 4\n    return np.all(other_coords[:, 0] >= bottom_start)\n","name":"program_402","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it in columns 1-4?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify all ship IDs present on the true board (exclude water = 0)\n    ship_ids = set(np.unique(true_board)) - {0}\n    \n    # Find which ships are not yet fully revealed\n    remaining = []\n    for sid in ship_ids:\n        # mask of where that ship is on the true board\n        ship_mask = (true_board == sid)\n        # check if any of those squares are still hidden in the partial board\n        if np.any(ship_mask & (partial_board == -1)):\n            remaining.append(sid)\n    \n    # If exactly one ship remains, test whether it lies entirely in columns 1\u20134\n    if len(remaining) == 1:\n        sid = remaining[0]\n        # get the column indices (0-based) of that ship on the true board\n        cols = np.where(true_board == sid)[1]\n        # columns 1\u20134 correspond to indices 0\u20133\n        return cols.min() >= 0 and cols.max() <= 3\n    \n    # If there isn't exactly one remaining ship, default to False\n    return False\n","name":"program_403","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it in E-F (yes) or G-H (no)?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the as\u2010yet unrevealed 4\u2010square ship lies entirely in rows E\u2010F.\n    Rows are 0-indexed 0..7 corresponding to A..H.\n    \"\"\"\n    # Look for ship\u2010IDs that occupy exactly 4 tiles on the true board\n    for ship_id in np.unique(true_board):\n        if ship_id <= 0:\n            continue  # skip water or hidden markers\n        \n        # Find all positions of this ship_id\n        pos = np.argwhere(true_board == ship_id)\n        # If it's a 4\u2010length ship...\n        if pos.shape[0] == 4:\n            # Check if it's fully revealed in partial_board\n            # A fully revealed ship will have partial_board == ship_id at all its spots\n            # We want the *other* 4\u2010length ship, i.e. the one not fully revealed yet.\n            revealed = partial_board[pos[:,0], pos[:,1]] == ship_id\n            if not np.all(revealed):\n                # Check if all its row\u2010indices lie in E or F (indices 4 or 5)\n                rows = pos[:,0]\n                in_EF = np.all((rows == 4) | (rows == 5))\n                return bool(in_EF)\n    # If we didn't find an unrevealed 4\u2010length ship, answer conservatively 'no'\n    return False\n","name":"program_404","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it in columns 5-6 (yes) or column 7 (no)","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Answer to the question: Is the final (unrevealed) ship located\n    in columns 5\u20136 (yes) or in column 7 (no)?\n\n    We identify all hidden ship\u2010tiles by looking for positions where\n    true_board>0 (a ship) and partial_board==-1 (still hidden).\n    Then we check whether any of these hidden tiles lie in columns 5 or 6.\n    If so, we return True ('yes'); otherwise False ('no').\n    \"\"\"\n    # Boolean mask of hidden ship tiles\n    hidden_ship = (true_board > 0) & (partial_board == -1)\n    # columns 5 and 6 correspond to indices 4 and 5\n    # If any hidden ship tile lies in those columns, answer is yes\n    return bool(np.any(hidden_ship[:, 4:6]))\n","name":"program_405","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it in G?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Step 1: find all ship\u2010IDs (positive numbers) on the true board\n    ship_ids = np.unique(true_board)\n    ship_ids = ship_ids[ship_ids > 0]\n\n    # Step 2: among them, select those whose length is exactly 4\n    length4 = []\n    for sid in ship_ids:\n        if np.count_nonzero(true_board == sid) == 4:\n            length4.append(sid)\n\n    # Step 3: of the 4\u2010length ships, find the one not yet revealed at all\n    # (i.e. none of its cells in partial_board have been uncovered)\n    unrevealed = []\n    for sid in length4:\n        r, c = np.where(true_board == sid)\n        # check partial_board at those coords\n        if not np.any(partial_board[r, c] != -1):\n            unrevealed.append(sid)\n\n    # There should be exactly one such \"other\" 4\u2010square ship\n    target_id = unrevealed[0]\n\n    # Step 4: get its row\u2010indices and see if any lie in row G (index 6)\n    r_target, _ = np.where(true_board == target_id)\n    # Return True if any segment is in row G\n    return np.any(r_target == 6)\n","name":"program_406","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is in in column 5?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify all ship tiles that are still hidden\n    hidden_ship_tiles = (true_board > 0) & (partial_board == -1)\n    # Check if any of those hidden ship tiles lie in column 5 (index 4)\n    return bool(np.any(hidden_ship_tiles[:, 4]))\n","name":"program_407","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the last ship on the top half?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify all unrevealed ship\u2010tiles (tiles that are >0 on true_board but still -1 on partial_board)\n    unrevealed_mask = (true_board > 0) & (partial_board == -1)\n    \n    # Determine which ship IDs are still unrevealed\n    remaining_ship_ids = np.unique(true_board[unrevealed_mask])\n    # If there isn't exactly one ship left, we can't answer \"the last ship\" question\n    if remaining_ship_ids.size != 1:\n        return False\n    \n    last_ship_id = remaining_ship_ids[0]\n    \n    # Get the row indices of all unrevealed tiles of that last ship\n    ship_rows, _ = np.where((true_board == last_ship_id) & (partial_board == -1))\n    \n    # Define the top half cutoff (for 8 rows, indices 0,1,2,3 are the top half)\n    halfway = true_board.shape[0] \/\/ 2\n    \n    # Return True if all unrevealed parts of the ship lie in the top half\n    return bool(np.all(ship_rows < halfway))\n","name":"program_408","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there more ships in the first column?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We're checking the first column (column index 0).\n    # A \"more ship\" means any hidden tile in that column that is actually a ship segment.\n    col_idx = 0\n    \n    # Identify which cells in the first column are still hidden on the partial board\n    hidden_in_column = (partial_board[:, col_idx] == -1)\n    \n    # Of those hidden cells, see if any correspond to a ship on the true board\n    ships_hidden = (true_board[:, col_idx] > 0) & hidden_in_column\n    \n    # If any such hidden ship segments exist, return True; otherwise False\n    return np.any(ships_hidden)\n","name":"program_409","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is any part on an odd number column","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there exists any ship tile (true_board > 0)\n    that is still hidden (partial_board == -1) and lies in an odd-numbered\n    column (1-based indexing: columns 1,3,5,7).\n    \"\"\"\n    # Build a mask of hidden ship\u2010tiles\n    ship_and_hidden = (true_board > 0) & (partial_board == -1)\n    \n    # Build a mask for odd\u2010numbered columns (1-based).  j%2==0 <=> j+1 is odd.\n    odd_col_mask = np.arange(true_board.shape[1]) % 2 == 0\n    \n    # Check if any hidden ship\u2010tile appears in an odd column\n    return bool(np.any(ship_and_hidden[:, odd_col_mask]))\n","name":"program_410","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship at D2","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert the coordinate D2 to zero-based indices\n    row = ord('D') - ord('A')   # 'D' -> 3\n    col = 2 - 1                 # 2  -> 1\n    \n    # Check if the true board at (row, col) contains a ship (> 0)\n    return true_board[row, col] > 0\n","name":"program_411","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it in the bottom half?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in the bottom half of the board (i.e., in the last rows).\n    \"\"\"\n    # Identify tiles that are ship parts in true_board but still hidden in partial_board\n    unrevealed_ships = (true_board > 0) & (partial_board == -1)\n\n    # Compute the halfway point of the board\n    n_rows = true_board.shape[0]\n    half = n_rows \/\/ 2  # bottom half is rows [half, n_rows)\n\n    # Check if any unrevealed ship tiles lie in the bottom half\n    return bool(np.any(unrevealed_ships[half:, :]))\n","name":"program_412","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship at C4?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert the coordinate \"C4\" into zero-based indices\n    row_idx = ord('C') - ord('A')   # 'A'->0, 'B'->1, 'C'->2, ...\n    col_idx = 4 - 1                 # Column 4 -> index 3\n\n    # We only answer \"Yes\" if that tile is still hidden in partial_board\n    # and actually contains a ship in true_board (value > 0).\n    is_hidden    = partial_board[row_idx, col_idx] == -1\n    is_ship_tile = true_board[row_idx, col_idx] > 0\n\n    return is_hidden and is_ship_tile\n","name":"program_413","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the ship at A3 horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We're answering: \"Is the ship at A3 horizontal?\"\n    # Convert A3 into zero\u2010based indices: row A -> 0, column 3 -> 2\n    row_idx = ord('A') - ord('A')    # 0\n    col_idx = 3 - 1                  # 2\n\n    # Identify which ship is at A3\n    ship_id = true_board[row_idx, col_idx]\n    if ship_id == 0:\n        # No ship at A3 at all\n        return False\n\n    n_rows, n_cols = true_board.shape\n\n    # Check immediate horizontal neighbors for the same ship_id\n    for dc in (-1, 1):\n        nc = col_idx + dc\n        if 0 <= nc < n_cols and true_board[row_idx, nc] == ship_id:\n            return True\n\n    # If no horizontal neighbor matched, it's not horizontal\n    return False\n","name":"program_414","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship at E5?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert the coordinate \"E5\" into zero-based indices\n    # Row 'A' -> 0, 'B' -> 1, ..., 'E' -> 4\n    # Column '1' -> 0, ..., '5' -> 4\n    row_idx = 4\n    col_idx = 4\n\n    # If that tile has already been revealed in partial_board, there can't\n    # be an unrevealed ship there.\n    if partial_board[row_idx, col_idx] != -1:\n        return False\n\n    # In true_board, any non-zero value at that location indicates a ship\n    return true_board[row_idx, col_idx] != 0\n","name":"program_415","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship at B1?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Captain asked about B1, which is row index 1, column index 0\n    row_idx = 1  # B\n    col_idx = 0  # 1\n\n    # A ship is present at B1 if:\n    # 1) That tile is still hidden on the partial board\n    # 2) The true board has a ship identifier (> 0) at that position\n    return (partial_board[row_idx, col_idx] == -1) and (true_board[row_idx, col_idx] > 0)\n","name":"program_416","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships in the upper right quadrant","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the midpoint to split into quadrants\n    n_rows, n_cols = true_board.shape\n    mid_row = n_rows \/\/ 2\n    mid_col = n_cols \/\/ 2\n\n    # Upper right quadrant is rows [0:mid_row], cols [mid_col:]\n    true_quadrant = true_board[:mid_row, mid_col:]\n    partial_quadrant = partial_board[:mid_row, mid_col:]\n\n    # A \u201cYes\u201d if there exists any ship tile (>0) in the quadrant that is still hidden (-1 in partial)\n    hidden_ship_mask = (true_quadrant > 0) & (partial_quadrant == -1)\n    return bool(np.any(hidden_ship_mask))\n","name":"program_417","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships in the bottom right quadrant","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one *hidden* ship tile in the\n    bottom-right quadrant of the board, otherwise False.\n    We split the 8\u00d78 board (or any even-sized board) in half in both\n    dimensions, then look at the subarray of rows 4\u20137 and cols 4\u20137\n    (0-based indexing). We check for tiles where true_board>0\n    (a ship) and partial_board==-1 (still hidden).\n    \"\"\"\n    nrows, ncols = true_board.shape\n    # split indices at half\n    half_row = nrows \/\/ 2\n    half_col = ncols \/\/ 2\n\n    # extract bottom-right quadrant\n    tr = true_board[half_row:, half_col:]\n    pr = partial_board[half_row:, half_col:]\n\n    # check for any hidden ship tile\n    return bool(np.any((tr > 0) & (pr == -1)))\n","name":"program_418","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships in the first column?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed ship tile in the first column (column index 0),\n    otherwise returns False.\n    \"\"\"\n    # Extract the true and partial values for column 0\n    true_col0 = true_board[:, 0]\n    partial_col0 = partial_board[:, 0]\n\n    # A ship tile is indicated by a value > 0 in true_board; an unrevealed tile is -1 in partial_board\n    unrevealed_ship_in_col0 = (true_col0 > 0) & (partial_col0 == -1)\n\n    # If any entry in that boolean mask is True, there is at least one hidden ship tile\n    return bool(np.any(unrevealed_ship_in_col0))\n","name":"program_419","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the last ship also on the left","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine which ship\u2010types have already been revealed on the partial board\n    # (exclude -1 for hidden and 0 for water)\n    revealed_types = set(np.unique(partial_board)) - {0, -1}\n    \n    # All ship types are 1 through 4\n    all_ship_types = {1, 2, 3, 4}\n    \n    # The \"last ship\" type is the one not yet revealed\n    missing_types = all_ship_types - revealed_types\n    if not missing_types:\n        # No missing ships or ambiguous \u2013 default to False\n        return False\n    last_ship_type = missing_types.pop()\n    \n    # Find all coordinates of that ship on the true board\n    coords = np.argwhere(true_board == last_ship_type)\n    if coords.size == 0:\n        # No such ship found\n        return False\n    \n    # Define \"left\" as the left half of the board\n    ncols = partial_board.shape[1]\n    left_threshold = ncols \/\/ 2  # e.g. for 8 columns, columns 0\u20133 are \"left\"\n    \n    # Check if every part of the last ship lies in the left half\n    # coords[:,1] gives the column indices (0-based)\n    return np.all(coords[:, 1] < left_threshold)\n","name":"program_420","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there any ship in the B column across","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # 'B column across' means row B (second row, index 1)\n    row_idx = 1\n    # A ship tile is unrevealed if true_board>0 and partial_board==-1\n    unrevealed_in_B = (true_board[row_idx, :] > 0) & (partial_board[row_idx, :] == -1)\n    return np.any(unrevealed_in_B)\n","name":"program_421","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there any ship in the bottom right?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed ship tile in the bottom\u2010right quadrant\n    of the board (i.e. the lower half of the rows and right half of the columns),\n    otherwise False.\n    \"\"\"\n    n_rows, n_cols = true_board.shape\n\n    # Determine the start indices for the bottom\u2010right quadrant\n    r_start = n_rows \/\/ 2\n    c_start = n_cols \/\/ 2\n\n    # Slice out the bottom\u2010right quadrant from both boards\n    tr = true_board[r_start:, c_start:]\n    pr = partial_board[r_start:, c_start:]\n\n    # A ship tile is > 0 in true_board and unrevealed if partial_board == -1\n    unrevealed_ship = (tr > 0) & (pr == -1)\n\n    return np.any(unrevealed_ship)\n","name":"program_422","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"what about C","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row C corresponds to index 2 (0-based: A=0, B=1, C=2)\n    row_idx = 2\n    # A ship tile is indicated by a positive value in true_board,\n    # and unrevealed tiles are -1 in partial_board.\n    unrevealed_ship_in_C = (true_board[row_idx, :] > 0) & (partial_board[row_idx, :] == -1)\n    return np.any(unrevealed_ship_in_C)\n","name":"program_423","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there any part of a ship in the 8 column down","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any *unrevealed* ship segment in column 8 (index 7),\n    otherwise returns False.\n    \"\"\"\n    # Column \u201c8\u201d corresponds to index 7 in a zero-indexed numpy array\n    col_idx = 7\n\n    # A mask of where the true board has a ship (> 0) in column 8\n    ship_in_col = true_board[:, col_idx] > 0\n\n    # A mask of where the captain has not yet revealed that tile (partial == -1)\n    hidden_in_col = partial_board[:, col_idx] == -1\n\n    # If there's any position in column 8 that is both a ship and still hidden, answer Yes\n    return bool(np.any(ship_in_col & hidden_in_col))\n","name":"program_424","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it on the left side of the C column","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the zero\u2010based index of row \u201cC\u201d and column \u201cC\u201d\n    row_C = ord('C') - ord('A')      # 2\n    col_C = ord('C') - ord('A')      # also 2\n\n    # Mask all still\u2010hidden ship cells\n    hidden_ship = (true_board > 0) & (partial_board == -1)\n\n    # Look only in row C, columns strictly less than the C\u2010column index\n    left_of_C = hidden_ship[row_C, :col_C]\n\n    # If any such cell exists, answer \u201cYes\u201d\n    return bool(np.any(left_of_C))\n","name":"program_425","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship in the G column across","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We interpret \"G across\" as row G (row index 6, since A=0, B=1, \u2026, G=6)\n    row_idx = ord('G') - ord('A')\n    # A ship tile is where true_board > 0\n    ship_tiles = true_board[row_idx] > 0\n    # An unrevealed tile on the partial board is marked -1\n    hidden_tiles = partial_board[row_idx] == -1\n    # If there's any position in row G that both contains a ship and is still hidden, answer is True\n    return bool(np.any(ship_tiles & hidden_tiles))\n","name":"program_426","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the last ship in the upper left","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify all ship IDs on the board (exclude water = 0)\n    ship_ids = set(np.unique(true_board)) - {0}\n\n    # Determine which ships still have hidden parts\n    remaining = []\n    for s in ship_ids:\n        total_tiles = np.count_nonzero(true_board == s)\n        revealed_tiles = np.count_nonzero(partial_board == s)\n        if revealed_tiles < total_tiles:\n            remaining.append(s)\n\n    # If no ships remain hidden, answer is False\n    if not remaining:\n        return False\n\n    # Build a mask of all hidden tiles belonging to the remaining ship(s)\n    hidden_mask = np.zeros_like(true_board, dtype=bool)\n    for s in remaining:\n        hidden_mask |= (true_board == s) & (partial_board == -1)\n\n    # Define the \"upper left\" quadrant (rows 0\u20133, cols 0\u20133 for an 8\u00d78 board)\n    n_rows, n_cols = true_board.shape\n    mid_row, mid_col = n_rows \/\/ 2, n_cols \/\/ 2\n\n    # Check if any hidden tile of the last ship(s) lies in the upper-left quadrant\n    rows, cols = np.where(hidden_mask)\n    return np.any((rows < mid_row) & (cols < mid_col))\n","name":"program_427","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is A1 a ship","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A1 corresponds to row 0, column 0 in the arrays\n    return true_board[0, 0] > 0\n","name":"program_428","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"what about A2","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert the coordinate \"A2\" to zero-based indices: row 0, column 1\n    row_idx = ord('A') - ord('A')\n    col_idx = 2 - 1  # column \"2\" -> index 1\n    \n    # If the true board at (0,1) is nonzero, there's a ship there\n    return true_board[row_idx, col_idx] != 0\n","name":"program_429","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"A3?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # The Captain asked about A3.\n    # Rows A\u2013H map to indices 0\u20137, columns 1\u20138 map to indices 0\u20137.\n    row_idx = ord('A') - ord('A')  # A \u2192 0\n    col_idx = 3 - 1                # 3 \u2192 index 2\n    # A tile contains part of a ship if its true_board value is > 0\n    return true_board[row_idx, col_idx] > 0\n","name":"program_430","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship in the top half of the screen","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine how many rows constitute the \"top half\"\n    half = true_board.shape[0] \/\/ 2\n\n    # Slice out the top half of both boards\n    top_true   = true_board[:half, :]\n    top_known  = partial_board[:half, :]\n\n    # Find tiles in the top half that are ships (value > 0) and still hidden (-1 in partial)\n    hidden_ships = (top_true > 0) & (top_known == -1)\n\n    # If any such tile exists, answer \"Yes\"\n    return bool(np.any(hidden_ships))\n","name":"program_431","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it on the left top half?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the midpoint of rows and columns\n    n_rows, n_cols = true_board.shape\n    mid_row = n_rows \/\/ 2    # top half is rows [0 .. mid_row-1]\n    mid_col = n_cols \/\/ 2    # left half is cols [0 .. mid_col-1]\n\n    # Slice out the top-left quadrant\n    tl_true = true_board[:mid_row, :mid_col]\n    tl_partial = partial_board[:mid_row, :mid_col]\n\n    # Check for any ship tile (>0) that is still hidden (-1) in that quadrant\n    hidden_ship_mask = (tl_true > 0) & (tl_partial == -1)\n    return bool(np.any(hidden_ship_mask))\n","name":"program_432","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there any ship in column 1 down","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Column 1 corresponds to index 0 in the arrays\n    col_idx = 0\n    \n    # Identify where the true board has ship tiles in column 1\n    ship_tiles = true_board[:, col_idx] > 0\n    \n    # Identify which of those tiles are still hidden on the partial board\n    hidden_tiles = partial_board[:, col_idx] == -1\n    \n    # If there's any position that is both a ship and still hidden, answer \"Yes\"\n    return bool(np.any(ship_tiles & hidden_tiles))\n","name":"program_433","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships in D or E across?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows D and E correspond to indices 3 and 4 (0-based).\n    rows_to_check = [3, 4]\n    \n    # A hidden ship tile is one where the true board is nonzero\n    # but the partial board still shows -1 (hidden).\n    for r in rows_to_check:\n        for c in range(true_board.shape[1]):\n            if true_board[r, c] != 0 and partial_board[r, c] == -1:\n                return True\n    return False\n","name":"program_434","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there any ship on row D","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines whether there are any unrevealed ship tiles on row D.\n    Rows are indexed 0 (A) through 7 (H), so row D is index 3.\n    We look for positions where the true board has a ship (>0)\n    but the partial board is still hidden (-1).\n    \"\"\"\n    row_idx = 3  # D is the fourth row, index 3\n    # Mask of ship locations in the true board on row D\n    ships_on_row = true_board[row_idx] > 0\n    # Mask of hidden tiles in the partial board on row D\n    hidden_on_row = partial_board[row_idx] == -1\n    # If any position is both a ship in true_board and hidden in partial_board,\n    # then there is still an unrevealed ship tile on row D.\n    return bool(np.any(ships_on_row & hidden_on_row))\n","name":"program_435","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there any ships in the top right","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in the top-right quadrant (rows 0\u20133, cols 4\u20137) of the board.\n    \"\"\"\n    # split the 8\u00d78 board in half\n    mid_row = true_board.shape[0] \/\/ 2   # 4\n    mid_col = true_board.shape[1] \/\/ 2   # 4\n\n    # extract top-right quadrant\n    tr_true    = true_board[:mid_row, mid_col:]\n    tr_partial = partial_board[:mid_row, mid_col:]\n\n    # an unrevealed ship tile is one where true_board>0 but partial_board is still -1\n    return np.any((tr_true > 0) & (tr_partial == -1))\n","name":"program_436","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there any ship in the bottom right","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed ship tile in the bottom-right quadrant\n    of the board (rows E-H and columns 5-8), otherwise False.\n    \"\"\"\n    # Determine the halfway point for rows and columns\n    n_rows, n_cols = true_board.shape\n    row_half = n_rows \/\/ 2\n    col_half = n_cols \/\/ 2\n\n    # Extract the bottom-right quadrant\n    true_br = true_board[row_half:, col_half:]\n    partial_br = partial_board[row_half:, col_half:]\n\n    # A ship tile is a value > 0 in true_board\n    # An unrevealed tile in partial_board is marked as -1\n    hidden_ship_mask = (true_br > 0) & (partial_br == -1)\n\n    # If any hidden ship tile exists in that region, return True\n    return bool(hidden_ship_mask.any())\n","name":"program_437","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there any ship on column 8 across","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in column 8 (index 7),\n    otherwise returns False.\n    \"\"\"\n    col_idx = 7\n    # Tiles in column 8 that are still hidden\n    hidden_tiles = (partial_board[:, col_idx] == -1)\n    # Tiles in column 8 that actually contain a ship\n    ship_tiles = (true_board[:, col_idx] > 0)\n    # If any tile is both hidden and a ship, answer \"Yes\"\n    return bool(np.any(hidden_tiles & ship_tiles))\n","name":"program_438","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships in column 7 down","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert \"column 7\" to zero\u2010based index 6\n    col_index = 6\n\n    # We're interested in unrevealed ship tiles in that column.\n    # A tile is a ship tile if true_board > 0, and it's still hidden if partial_board == -1.\n    hidden_ship_in_col = (true_board[:, col_index] > 0) & (partial_board[:, col_index] == -1)\n\n    # If any such tile exists, answer is True, otherwise False.\n    return bool(np.any(hidden_ship_in_col))\n","name":"program_439","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship in the top right?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # row 0 is the \"top\" row, and -1 index selects the rightmost column\n    r, c = 0, -1\n    # only answer based on an unrevealed tile\n    if partial_board[r, c] != -1:\n        # already revealed, so answer is simply whether it's a ship\n        return true_board[r, c] != 0\n    # if it's unrevealed, say yes iff there's actually a ship there\n    return true_board[r, c] != 0\n","name":"program_440","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there another ship on line G across","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We're checking row G (the 7th row, index 6)\n    row_index = ord('G') - ord('A')\n    # A ship tile is one where true_board > 0. It is still hidden if partial_board == -1.\n    hidden_ships = (true_board[row_index] > 0) & (partial_board[row_index] == -1)\n    return bool(np.any(hidden_ships))\n","name":"program_441","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship on column E across?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row \"E\" is the 5th row (0-based index 4)\n    row_e_idx = ord('E') - ord('A')\n    # Extract that row from both boards\n    true_row = true_board[row_e_idx, :]\n    partial_row = partial_board[row_e_idx, :]\n    # A still-hidden ship tile is one where true_board > 0 and partial_board == -1\n    still_hidden_ship = (true_row > 0) & (partial_row == -1)\n    return bool(np.any(still_hidden_ship))\n","name":"program_442","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship on the bottom right side?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in\n    the bottom-right quadrant (rows E-H and columns E-H) of the board.\n    \"\"\"\n    # Define the bottom-right quadrant: rows 4-7 (E-H), columns 4-7 (E-H)\n    br_true = true_board[4:, 4:]\n    br_partial = partial_board[4:, 4:]\n    \n    # An unrevealed ship tile is one where true_board > 0 and partial_board == -1\n    unrevealed = (br_true > 0) & (br_partial == -1)\n    \n    return bool(np.any(unrevealed))\n","name":"program_443","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship on line D or C across?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to know if there is any hidden ship tile on row C or row D.\n    # Rows are labeled A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7.\n    target_rows = [2, 3]  # C, D\n\n    # A tile is an unrevealed ship tile if:\n    #   true_board > 0 (there is a ship)\n    #   partial_board == -1 (it is still hidden)\n    unrevealed_ship = (true_board > 0) & (partial_board == -1)\n\n    # Check if any such tile exists in row C or row D\n    return np.any(unrevealed_ship[target_rows, :])\n","name":"program_444","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there another ship in the bottom left side?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in the bottom\u2010left quadrant of the board (rows E\u2013H, columns A\u2013D\n    for an 8\u00d78 board), False otherwise.\n    \"\"\"\n    # Determine board dimensions\n    rows, cols = true_board.shape\n\n    # Define \"bottom half\" rows and \"left half\" columns\n    bottom_start = rows \/\/ 2       # for 8 rows, this is index 4 (row E)\n    left_end    = cols \/\/ 2       # for 8 cols, this is index 4 (col E), so 0\u20133 are A\u2013D\n\n    # Extract the bottom\u2010left region from both boards\n    true_region    = true_board   [bottom_start:rows, 0:left_end]\n    partial_region = partial_board[bottom_start:rows, 0:left_end]\n\n    # A ship tile is indicated by >0 in true_board.\n    # An unrevealed tile is indicated by -1 in partial_board.\n    # We look for any position where true_region>0 and partial_region==-1.\n    unrevealed_ship_mask = (true_region > 0) & (partial_region == -1)\n\n    # If any such tile exists, return True; otherwise False.\n    return bool(np.any(unrevealed_ship_mask))\n","name":"program_445","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship in the top half","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in the top half of the board (rows A\u2013D), otherwise False.\n    \"\"\"\n    # Determine the row index that splits the board in half\n    mid_row = true_board.shape[0] \/\/ 2\n    \n    # Slice out the top half of both boards\n    true_top = true_board[:mid_row, :]\n    partial_top = partial_board[:mid_row, :]\n    \n    # A ship tile is indicated by > 0 in true_board\n    # An unrevealed tile is indicated by -1 in partial_board\n    unrevealed_ship_tiles = (true_top > 0) & (partial_top == -1)\n    \n    # If any such tile exists, return True\n    return bool(np.any(unrevealed_ship_tiles))\n","name":"program_446","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the longest ship in the top half","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify all ship IDs (positive integers)\n    ship_ids = np.unique(true_board)\n    ship_ids = ship_ids[ship_ids > 0]\n\n    # Compute length of each ship\n    lengths = {ship_id: np.count_nonzero(true_board == ship_id)\n               for ship_id in ship_ids}\n\n    # Find the maximum length\n    max_len = max(lengths.values())\n\n    # Collect all ship IDs that have the maximum length\n    longest_ships = [sid for sid, l in lengths.items() if l == max_len]\n\n    # Define the top half boundary (rows 0 through n\/2 - 1)\n    half = true_board.shape[0] \/\/ 2\n\n    # Check if any of the longest ships lies entirely in the top half\n    for sid in longest_ships:\n        coords = np.argwhere(true_board == sid)\n        if np.all(coords[:, 0] < half):\n            return True\n\n    return False\n","name":"program_447","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship on column 1 down","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the number of rows and compute the halfway point\n    n_rows = true_board.shape[0]\n    half = n_rows \/\/ 2  # bottom half starts at this index\n\n    # We're interested in column 1 (\"column 1 down\" means the first column in the bottom half)\n    col_index = 0\n\n    # Extract the slice of both boards for the bottom half of column 1\n    true_slice = true_board[half:, col_index]\n    partial_slice = partial_board[half:, col_index]\n\n    # A ship tile is indicated by true_board > 0.\n    # A hidden tile is indicated by partial_board == -1.\n    # We check if there is any tile in that slice which is both a ship and still hidden.\n    hidden_ship_mask = (true_slice > 0) & (partial_slice == -1)\n    return bool(np.any(hidden_ship_mask))\n","name":"program_448","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship on an even numbered column","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine which columns are even-numbered (columns are 1-indexed)\n    n_cols = partial_board.shape[1]\n    even_cols = ((np.arange(n_cols) + 1) % 2 == 0)\n    \n    # Find positions that are still hidden and actually contain a ship\n    hidden_ship = (partial_board == -1) & (true_board > 0)\n    \n    # Restrict to even-numbered columns and check if any such ship remains hidden\n    return bool(hidden_ship[:, even_cols].any())\n","name":"program_449","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship on the right side","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in the right half\n    of the board (columns 5 through 8), otherwise False.\n    \"\"\"\n    # Create a mask of ship tiles in the true board\n    ship_mask = true_board > 0\n    # Create a mask of tiles that are still hidden on the captain's partial board\n    hidden_mask = partial_board == -1\n\n    # Combine to find unrevealed ship tiles\n    unrevealed_ships = ship_mask & hidden_mask\n\n    # Determine which columns count as the \"right side\"\n    n_cols = true_board.shape[1]\n    right_half = np.arange(n_cols) >= (n_cols \/\/ 2)  # e.g., for 8 cols, columns 4,5,6,7\n\n    # Broadcast the right_half mask across rows and check if any unrevealed ship is there\n    right_unrevealed = unrevealed_ships & right_half[np.newaxis, :]\n    return bool(np.any(right_unrevealed))\n","name":"program_450","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it on the top half of the screen?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine how many rows constitute the \"top half\"\n    n_rows = true_board.shape[0]\n    half = n_rows \/\/ 2\n    \n    # Look only at the top half of the board\n    top_true = true_board[:half, :]\n    top_partial = partial_board[:half, :]\n    \n    # An unrevealed ship tile is one where partial_board == -1 and true_board > 0\n    unrevealed_ship_in_top = (top_partial == -1) & (top_true > 0)\n    \n    # If any such tile exists, answer is True, otherwise False\n    return bool(np.any(unrevealed_ship_in_top))\n","name":"program_451","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it in rows a or c?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to know if there is any unrevealed ship tile\n    # in row A (index 0) or row C (index 2).\n    rows_to_check = [0, 2]\n    # Create masks for ship presence and hidden tiles\n    ship_mask = true_board > 0\n    hidden_mask = partial_board == -1\n    # Combine masks and restrict to the rows of interest\n    combined = ship_mask & hidden_mask\n    return bool(combined[rows_to_check, :].any())\n","name":"program_452","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship in the bottom right","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine board dimensions\n    n_rows, n_cols = true_board.shape\n\n    # Define the \u201cbottom half\u201d (rows indexed from n_rows\/\/2 .. end)\n    # and the \u201cright half\u201d (cols indexed from n_cols\/\/2 .. end)\n    r_mid = n_rows \/\/ 2\n    c_mid = n_cols \/\/ 2\n\n    # Build a mask of the bottom\u2010right quadrant\n    bottom_right = np.zeros_like(true_board, dtype=bool)\n    bottom_right[r_mid:, c_mid:] = True\n\n    # Ship\u2010tiles that are still hidden on the captain\u2019s board\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n\n    # If any hidden ship\u2010tile lies in our bottom\u2010right quadrant, answer yes\n    return bool(np.any(hidden_ships & bottom_right))\n","name":"program_453","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship on the top half of the screen?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in the top half of the board,\n    i.e., rows 0 through (n\/\/2 - 1). Otherwise returns False.\n    \"\"\"\n    # Number of rows\n    n_rows = true_board.shape[0]\n    # Define the split point for the top half\n    half = n_rows \/\/ 2\n    \n    # Mask of ship positions in the true board (values > 0)\n    ship_mask = true_board > 0\n    # Mask of unrevealed tiles in the partial board (value == -1)\n    hidden_mask = partial_board == -1\n    \n    # Combine masks, but only in the top half of the rows\n    top_half_ships_hidden = np.logical_and(\n        ship_mask[:half, :],\n        hidden_mask[:half, :]\n    )\n    \n    # If any True in that combined mask, there's an unrevealed ship tile in the top half\n    return bool(np.any(top_half_ships_hidden))\n","name":"program_454","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship on the top right?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether there is any unrevealed ship tile in the top\u2010right quadrant\n    of the board (rows A\u2013D, columns E\u2013H). Returns True for \"Yes\" and False for \"No\".\n    \"\"\"\n    # Slice out rows A\u2013D (indices 0\u20133) and columns E\u2013H (indices 4\u20137)\n    true_quad = true_board[0:4, 4:8]\n    partial_quad = partial_board[0:4, 4:8]\n    \n    # A ship tile is indicated in true_board by a positive integer (>0).\n    # An unrevealed cell is indicated in partial_board by -1.\n    unrevealed_ship = (true_quad > 0) & (partial_quad == -1)\n    \n    return bool(np.any(unrevealed_ship))\n","name":"program_455","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there one on column A across?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row 'A' to index 0\n    row_index = 0\n    # Check for any unrevealed ship tiles in row A\n    # true_board > 0 identifies all ship tiles\n    # partial_board == -1 identifies hidden tiles\n    hidden_ships_in_row = (true_board[row_index] > 0) & (partial_board[row_index] == -1)\n    return bool(np.any(hidden_ships_in_row))\n","name":"program_456","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it on the right side?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile on the right\n    half of the board (columns >= half), otherwise False.\n    \"\"\"\n    # determine the column index where the right half starts\n    n_cols = true_board.shape[1]\n    half = n_cols \/\/ 2\n\n    # slice out the right half of both boards\n    tb_right = true_board[:, half:]\n    pb_right = partial_board[:, half:]\n\n    # an unrevealed ship tile is one where true_board>0 but partial_board==-1\n    unrevealed_ships = (tb_right > 0) & (pb_right == -1)\n    return bool(unrevealed_ships.any())\n","name":"program_457","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there ships in the upper left quadrant?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there are any unrevealed ship tiles in the upper-left quadrant\n    (rows A\u2013D, columns 1\u20134), otherwise False.\n    \"\"\"\n    # Define the slice for rows A\u2013D (indices 0\u20133) and columns 1\u20134 (indices 0\u20133)\n    tl_true = true_board[0:4, 0:4]\n    tl_partial = partial_board[0:4, 0:4]\n\n    # An unrevealed ship tile is where true_board > 0 (ship) and partial_board == -1 (hidden)\n    unrevealed_ship_mask = (tl_true > 0) & (tl_partial == -1)\n    return np.any(unrevealed_ship_mask)\n","name":"program_458","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is A4 going to hit a ship?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map the coordinate 'A4' to zero\u2010based indices:\n    row_idx = ord('A') - ord('A')  # 'A' \u2192 0\n    col_idx = 4 - 1                # '4' \u2192 3\n\n    # A move \"hits\" if the tile is currently hidden in partial_board\n    # and true_board has a ship (value > 0) at that location.\n    is_hidden = (partial_board[row_idx, col_idx] == -1)\n    is_ship    = (true_board[row_idx,    col_idx] >  0)\n\n    return is_hidden and is_ship\n","name":"program_459","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship in row D?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'D' to zero\u2010based index\n    row_idx = ord('D') - ord('A')\n    # Extract that row from both boards\n    true_row = true_board[row_idx, :]\n    partial_row = partial_board[row_idx, :]\n    # A tile is an unrevealed ship if true_board>0 and partial_board is still hidden (-1)\n    unrevealed = (true_row > 0) & (partial_row == -1)\n    # If any such tile exists, answer \"yes\"\n    return bool(unrevealed.any())\n","name":"program_460","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"should I hit in row F (yes) or row D (No)","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows are indexed 0=A, 1=B, ..., 5=F, 3=D\n    row_F = 5\n    \n    # A hit in row F is worthwhile only if there are still unrevealed ship tiles in that row.\n    # We look for positions where true_board has a ship (>0) but partial_board is still hidden (-1).\n    unrevealed_in_F = np.logical_and(true_board[row_F, :] > 0,\n                                     partial_board[row_F, :] == -1)\n    \n    # If there's at least one unrevealed ship tile in row F, answer \"yes\" (True), otherwise \"no\" (False).\n    return bool(unrevealed_in_F.any())\n","name":"program_461","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the ship Horizontal (yes) or Vertical (no)?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines if the (partially revealed) ship is oriented horizontally (True) or vertically (False).\n    We identify the ship ID that has been revealed on the partial_board, locate all its tiles\n    on the true_board, and check if those tiles share the same row (horizontal) or column (vertical).\n    \"\"\"\n    # Find which ship IDs have been revealed so far (values 1\u20134) and how many hits each has.\n    revealed = partial_board[partial_board > 0]\n    if revealed.size == 0:\n        # No ships revealed yet; default to False (vertical)\n        return False\n\n    ids, counts = np.unique(revealed, return_counts=True)\n\n    # If exactly one ship is in play, pick it.\n    if ids.size == 1:\n        ship_id = ids[0]\n    else:\n        # Prefer the ship with exactly one revealed tile (the one we just hit).\n        one_hit = ids[counts == 1]\n        if one_hit.size == 1:\n            ship_id = one_hit[0]\n        else:\n            # Otherwise, if any ship has multiple hits, use that.\n            multi_hit = ids[counts > 1]\n            ship_id = multi_hit[0] if multi_hit.size > 0 else ids[0]\n\n    # Get all the coordinates of that ship on the true_board\n    ship_rows, ship_cols = np.where(true_board == ship_id)\n\n    # Horizontal if all row indices are the same\n    return np.all(ship_rows == ship_rows[0])\n","name":"program_462","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify which ship is currently partially revealed (hits > 0 but not yet fully sunk)\n    target_ship = None\n    for ship_id in [1, 2, 3, 4]:\n        total_segments = np.count_nonzero(true_board == ship_id)\n        hit_segments = np.count_nonzero(partial_board == ship_id)\n        if 0 < hit_segments < total_segments:\n            target_ship = ship_id\n            break\n\n    # If no partially revealed ship is found, default to False\n    if target_ship is None:\n        return False\n\n    # Get the coordinates of all segments of that ship on the true board\n    coords = np.argwhere(true_board == target_ship)\n    # Rows are the first column of coords, columns are the second column\n    unique_rows = np.unique(coords[:, 0])\n    unique_cols = np.unique(coords[:, 1])\n\n    # The ship is vertical if all its segments share the same column\n    return len(unique_cols) == 1\n","name":"program_463","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship that lands in row G?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letters A\u2013H to indices 0\u20137\n    row_index = ord('G') - ord('A')\n    # A ship \"lands\" in row G if there is at least one tile in row G\n    # that truly contains a ship (>0) and is still unrevealed (-1) in the partial board.\n    unrevealed_ship_tiles = (true_board[row_index] > 0) & (partial_board[row_index] == -1)\n    return bool(np.any(unrevealed_ship_tiles))\n","name":"program_464","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the (partially revealed) ship is horizontal,\n    False if vertical.\n    \"\"\"\n\n    # 1) Find all ship IDs (1\u20134) that have at least one hit in partial_board\n    #    but are not yet completely revealed (partial_count < true_count).\n    candidate_ship = None\n    for ship_id in range(1, 5):\n        total = np.count_nonzero(true_board == ship_id)\n        seen  = np.count_nonzero(partial_board == ship_id)\n        if 0 < seen < total:\n            candidate_ship = ship_id\n            break\n\n    if candidate_ship is None:\n        # No partially revealed ship found \u2013 fall back to False\n        return False\n\n    # 2) Get the full list of coordinates of that ship on the true_board\n    coords = np.argwhere(true_board == candidate_ship)\n    # coords is an array of shape (ship_length, 2), rows are (r, c)\n\n    # 3) If all row-indices are the same \u2192 horizontal\n    rows = coords[:, 0]\n    if np.all(rows == rows[0]):\n        return True\n\n    # 4) If all column-indices are the same \u2192 vertical\n    cols = coords[:, 1]\n    if np.all(cols == cols[0]):\n        return False\n\n    # 5) Degenerate \/ malformed board: default to False\n    return False\n","name":"program_465","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the last ship vertical on the board?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the last remaining (not yet fully revealed) ship is vertical.\n\n    A ship is \u201cremaining\u201d if there is at least one tile of that ship on true_board\n    which is still hidden (partial_board == -1).  Once we identify that ship\u2019s value,\n    we look at all of its true_board positions.  If all of those positions lie in\n    the same column, the ship is vertical; otherwise it is horizontal.\n    \"\"\"\n    # find all ship\u2010identifiers on the board\n    ship_ids = np.unique(true_board[(true_board > 0)])\n    \n    for ship in ship_ids:\n        # mask of all cells belonging to this ship in the true (full) board\n        ship_mask = (true_board == ship)\n        \n        # check if at least one of this ship's tiles remains hidden\n        if np.any(partial_board[ship_mask] == -1):\n            # get coordinates of all tiles of this ship\n            rows, cols = np.where(ship_mask)\n            # vertical if all columns are the same\n            return (np.unique(cols).size == 1)\n    \n    # if no ships remain hidden, default to False\n    return False\n","name":"program_466","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it to the right (yes) or the left (no) of the green ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the last unrevealed ship lies to the right of the green ship,\n    False if it lies to the left.\n    \"\"\"\n    # Identify all ship IDs on the true board (positive integers)\n    ship_ids = set(np.unique(true_board[true_board > 0]))\n    # Identify which ship IDs have any tile already revealed\n    revealed_ids = set(np.unique(true_board[(true_board > 0) & (partial_board != -1)]))\n    # The \"last ship\" ID is the one present in true_board but never revealed on partial_board\n    remaining_ids = ship_ids - revealed_ids\n    # We expect exactly one remaining ship\n    if len(remaining_ids) != 1:\n        raise ValueError(\"Expected exactly one unrevealed ship, found: %r\" % remaining_ids)\n    last_ship_id = remaining_ids.pop()\n\n    # Get all column indices for the green ship (ID=2) and the last ship\n    green_cols = np.argwhere(true_board == 2)[:, 1]\n    last_cols = np.argwhere(true_board == last_ship_id)[:, 1]\n\n    # Compute their mean column indices\n    green_center = green_cols.mean()\n    last_center = last_cols.mean()\n\n    # Return True if the last ship is to the right of the green ship\n    return last_center > green_center\n","name":"program_467","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship under number 1","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in column 1 (index 0),\n    otherwise False.\n    \"\"\"\n    # column \"1\" corresponds to index 0\n    col_idx = 0\n    \n    # A ship tile on true_board is > 0, a hidden tile on partial_board is -1.\n    # We look for positions in column 0 where true_board has a ship (>0)\n    # but partial_board still has it hidden (-1).\n    hidden_ship_cells = (true_board[:, col_idx] > 0) & (partial_board[:, col_idx] == -1)\n    \n    return bool(np.any(hidden_ship_cells))\n","name":"program_468","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship in the top right","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in the top\u2010right quadrant of the board, False otherwise.\n    \n    We define \"top right\" generically as:\n      rows 0..(n_rows\/\/2 - 1) and cols (n_cols\/\/2)..(n_cols - 1)\n    \"\"\"\n    n_rows, n_cols = true_board.shape\n    \n    # Determine the boundaries of the \"top right\" quadrant\n    mid_row = n_rows \/\/ 2\n    mid_col = n_cols \/\/ 2\n    \n    # Slice out the top right quadrant\n    true_q  = true_board[:mid_row, mid_col:]\n    part_q  = partial_board[:mid_row, mid_col:]\n    \n    # A ship tile in true_board is > 0; a hidden tile in partial_board is -1\n    ships_unrevealed = (true_q > 0) & (part_q == -1)\n    \n    # If there's any such tile, answer \"Yes\" (True), else \"No\" (False)\n    return bool(np.any(ships_unrevealed))\n","name":"program_469","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is this ship horizontal","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all ship IDs that appear at least once on the partial board\n    # but not fully (i.e. partially revealed).\n    # We ignore 0 (water) and -1 (hidden).\n    candidate_ids = [sid for sid in np.unique(partial_board)\n                     if sid > 0]\n    \n    target_id = None\n    for sid in candidate_ids:\n        seen = np.count_nonzero(partial_board == sid)\n        total = np.count_nonzero(true_board    == sid)\n        # we want the ship that is partially but not fully revealed\n        if 0 < seen < total:\n            target_id = sid\n            break\n    \n    # If we didn\u2019t find any partially\u2010revealed ship, we can\u2019t answer\n    if target_id is None:\n        return False\n    \n    # Get the true coordinates of that ship\n    coords = np.argwhere(true_board == target_id)\n    rows = coords[:, 0]\n    cols = coords[:, 1]\n    \n    # If all row indices are the same, it\u2019s horizontal\n    return np.all(rows == rows[0])\n","name":"program_470","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"top left","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Define the \"top left\" quadrant: rows A\u2013D (0\u20133), columns 1\u20134 (0\u20133)\n    true_q = true_board[0:4, 0:4]\n    part_q = partial_board[0:4, 0:4]\n    # A ship tile is present if true_board>0, and unrevealed if partial_board==-1\n    unrevealed_ship = (true_q > 0) & (part_q == -1)\n    return np.any(unrevealed_ship)\n","name":"program_471","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship in row G","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letters A\u2013H to indices 0\u20137; 'G' corresponds to index 6\n    row_idx = ord('G') - ord('A')\n    \n    # A tile is (still) a hidden ship if:\n    #   true_board contains a ship (>0)\n    #   partial_board is still hidden (-1)\n    hidden_ship_tiles = (true_board[row_idx, :] > 0) & (partial_board[row_idx, :] == -1)\n    \n    # If any such tiles exist, there is an (unrevealed) ship in row G\n    return np.any(hidden_ship_tiles)\n","name":"program_472","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the top left ship horizontal","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Define the top\u2010left quadrant: rows 0\u20133 (A\u2013D), cols 0\u20133 (1\u20134)\n    quadrant = true_board[:4, :4]\n    \n    # Find which ship IDs (1\u20134) appear in that quadrant\n    ship_ids = np.unique(quadrant)\n    ship_ids = ship_ids[ship_ids > 0]  # drop 0 (water)\n    \n    # If no ship is (still) in that quadrant, answer False\n    if ship_ids.size == 0:\n        return False\n    \n    # We assume one ship per quadrant; pick the first ID found\n    ship_id = ship_ids[0]\n    \n    # Get all coordinates of that ship on the full board\n    coords = np.argwhere(true_board == ship_id)\n    rows = coords[:, 0]\n    cols = coords[:, 1]\n    \n    # If all rows are identical, it\u2019s horizontal\n    return np.all(rows == rows[0])\n","name":"program_473","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is this ship touching another ship","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the 'active' ship\u2014the one that has been hit but not yet fully revealed\u2014\n    is touching another ship on the true board. Touching is taken to mean any of the 8 neighbor\n    squares (horizontally, vertically, or diagonally adjacent).\n    \"\"\"\n    # All ship codes\n    ship_codes = [1, 2, 3, 4]\n    \n    # 1) Find which ships are 'active': they've been hit at least once but are not yet fully revealed.\n    active = []\n    for code in ship_codes:\n        true_mask = (true_board == code)\n        if not np.any(true_mask):\n            # That ship isn't even placed on the board\n            continue\n        partial_hits = (partial_board == code)\n        if np.any(partial_hits):\n            # At least one hit on this ship\n            # Check if it's fully revealed\n            if not np.all(true_mask == partial_hits):\n                active.append(code)\n    \n    # If more than one candidate, pick the one with the most hits (the one we're actively chasing)\n    if not active:\n        # No active ship to talk about\n        return False\n    if len(active) > 1:\n        active = [max(active, key=lambda c: np.count_nonzero(partial_board == c))]\n    \n    ship_code = active[0]\n    \n    # 2) Gather all true positions of that ship\n    ship_positions = np.argwhere(true_board == ship_code)\n    h, w = true_board.shape\n    \n    # 3) Check all 8-directional neighbors for any other non-zero, non-self code\n    neighbors = [(-1, -1), (-1, 0), (-1, 1),\n                 ( 0, -1),          ( 0, 1),\n                 ( 1, -1), ( 1, 0), ( 1, 1)]\n    \n    for (r, c) in ship_positions:\n        for dr, dc in neighbors:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < h and 0 <= nc < w:\n                val = true_board[nr, nc]\n                if val != 0 and val != ship_code:\n                    return True\n    return False\n","name":"program_474","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"row E?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to know if there are any *unrevealed* ship tiles in row E.\n    # Row E corresponds to index 4 (A=0, B=1, \u2026, E=4).\n    row_index = ord('E') - ord('A')\n    # A tile is an unrevealed ship tile if:\n    #   - partial_board == -1 (hidden)\n    #   - true_board  >  0 (is ship)\n    hidden_ship_mask = (partial_board[row_index] == -1) & (true_board[row_index] > 0)\n    return bool(np.any(hidden_ship_mask))\n","name":"program_475","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship in row H","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row H is the 8th row (index 7)\n    row_index = 7\n    \n    # A tile is hidden if partial_board == -1\n    hidden_tiles = (partial_board[row_index] == -1)\n    \n    # A tile is a ship if true_board > 0\n    ship_tiles = (true_board[row_index] > 0)\n    \n    # If there's any hidden ship tile in row H, answer Yes (True), otherwise No (False)\n    return bool(np.any(hidden_tiles & ship_tiles))\n","name":"program_476","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship under number 8","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Column \"8\" is index 7 in 0-based numpy arrays\n    col_idx = 7\n\n    # Identify tiles in column 8 that are still hidden\n    hidden_in_col = (partial_board[:, col_idx] == -1)\n    # Identify tiles in column 8 that are actually ship parts\n    ship_in_col   = (true_board[:,    col_idx] > 0)\n\n    # If any hidden tile in that column is a ship part, return True\n    return bool(np.any(hidden_in_col & ship_in_col))\n","name":"program_477","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it below 5-8","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # convert the human coordinate 5-8 (row E, col 8) to 0-based (4,7)\n    row, col = 4, 7\n    # look at all rows BELOW row 4 in the same column\n    below_true = true_board[row+1:, col] > 0        # any ship there?\n    below_hidden = partial_board[row+1:, col] == -1 # still unrevealed?\n    # if there's any position that's both a ship in true_board and hidden in partial_board, answer yes\n    return bool(np.any(below_true & below_hidden))\n","name":"program_478","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there ships in the upper left?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there are any unrevealed ship tiles in the upper-left\n    quadrant of the board (rows A\u2013D, columns 1\u20134), False otherwise.\n    \"\"\"\n    # Determine the midpoint of the board (for an 8\u00d78 board this is 4)\n    mid_row = true_board.shape[0] \/\/ 2\n    mid_col = true_board.shape[1] \/\/ 2\n\n    # Slice out the upper-left quadrant\n    tl_true = true_board[:mid_row, :mid_col]\n    tl_partial = partial_board[:mid_row, :mid_col]\n\n    # An unrevealed ship tile is where true_board > 0 and partial_board == -1\n    unrevealed_ships = (tl_true > 0) & (tl_partial == -1)\n\n    # If any such tiles exist, answer \"Yes\"\n    return bool(np.any(unrevealed_ships))\n","name":"program_479","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any ships under 6?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A tile is a still-hidden ship part if true_board>0 and partial_board==-1.\n    hidden_ship = (true_board > 0) & (partial_board == -1)\n    # Now check only columns 1\u20135, which are indices 0\u20134 in zero-based numpy\n    return bool(np.any(hidden_ship[:, :5]))\n","name":"program_480","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it below 5?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there are any *hidden* ship tiles in rows below row 5 (i.e. rows F, G or H).\n    We assume rows are 0-indexed so that row 0 = A, row 4 = E, and rows >=5 = F,H.\n    A tile is 'hidden' if partial_board == -1, and is a ship if true_board > 0.\n    \"\"\"\n    # Build a mask of hidden ship tiles\n    hidden_ship = (partial_board == -1) & (true_board > 0)\n    # Look only at rows F, G, H (indices 5, 6, 7)\n    return bool(np.any(hidden_ship[5:, :]))\n","name":"program_481","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"any ships under 8?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # we want column \u201c8\u201d, which is index 7 in zero\u2010based numpy\n    col_idx = 8 - 1\n\n    # Ship tiles on the true board are > 0.\n    is_ship    = true_board[:, col_idx] > 0\n    # Hidden tiles on the partial board are marked == -1.\n    is_hidden  = partial_board[:, col_idx] == -1\n\n    # If any position in that column is both a ship and still hidden, return True\n    return bool((is_ship & is_hidden).any())\n","name":"program_482","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any ships touching the orange ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if any non\u2010orange ship tile (1,2,3) is adjacent (including diagonal)\n    to any orange ship tile (4).\n    \"\"\"\n    n_rows, n_cols = true_board.shape\n    # Offsets for the 8 neighboring directions\n    neighbors = [(-1, -1), (-1, 0), (-1, 1),\n                 ( 0, -1),          ( 0, 1),\n                 ( 1, -1), ( 1, 0), ( 1, 1)]\n    \n    # Find all orange\u2010ship cells\n    orange_positions = np.argwhere(true_board == 4)\n    \n    for (r, c) in orange_positions:\n        for dr, dc in neighbors:\n            nr, nc = r + dr, c + dc\n            # Check bounds\n            if 0 <= nr < n_rows and 0 <= nc < n_cols:\n                val = true_board[nr, nc]\n                # If it's a ship but not orange\n                if val > 0 and val != 4:\n                    return True\n    return False\n","name":"program_483","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any ships in the lower left? Row F and down?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A tile is an unrevealed ship\u2010tile exactly when:\n    #   (true_board > 0)      <-- there is a ship there\n    # and\n    #   (partial_board == -1) <-- it has not yet been revealed\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n\n    # We want only rows F and below: rows with index >= 5 (0\u2192A, 1\u2192B, \u2026, 5\u2192F)\n    region = hidden_ships[5:, :]\n\n    # If any True remains in that region, the answer is \"Yes\"\n    return bool(np.any(region))\n","name":"program_484","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the last ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify hidden tiles\n    hidden = (partial_board == -1)\n    # Find which ship types have any hidden tiles\n    hidden_ships = np.unique(true_board[hidden & (true_board > 0)])\n    # If there's no hidden ship, default to False\n    if hidden_ships.size == 0:\n        return False\n    # We assume \"the last ship\" is the one still partially or completely hidden\n    ship_type = hidden_ships[0]\n    # Get all coordinates of that ship in the true board\n    coords = np.argwhere(true_board == ship_type)\n    # Separate row and column indices\n    rows, cols = coords[:, 0], coords[:, 1]\n    # If all row indices are the same, the ship is horizontal\n    return np.all(rows == rows[0])\n","name":"program_485","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the purple ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the purple ship (value 3)\n    coords = np.argwhere(true_board == 3)\n    if coords.size == 0:\n        # No purple ship found (shouldn't happen in a valid game)\n        return False\n    # Extract the row indices\n    rows = coords[:, 0]\n    # If all row indices are the same, the ship is horizontal\n    return np.all(rows == rows[0])\n","name":"program_486","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"boat in the upper right?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Define \"upper right\" as rows A\u2013D (0\u20133) and cols 5\u20138 (4\u20137)\n    sub_true = true_board[0:4, 4:8]\n    sub_partial = partial_board[0:4, 4:8]\n    # Look for any ship tile (>0) that remains hidden (-1)\n    unseen_ship = (sub_true > 0) & (sub_partial == -1)\n    return bool(np.any(unseen_ship))\n","name":"program_487","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"upper left?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine if there is at least one unrevealed ship tile in the upper-left quadrant\n    of the board. We interpret \"upper left\" to mean rows A\u2013D (0\u20133) and columns 1\u20134 (0\u20133).\n    \"\"\"\n    # define the quadrant bounds (for an 8\u00d78 board, split evenly in half)\n    mid_row = true_board.shape[0] \/\/ 2  # 8\/\/2 = 4\n    mid_col = true_board.shape[1] \/\/ 2  # 8\/\/2 = 4\n\n    # slice out the upper-left quadrant\n    true_sub = true_board[0:mid_row, 0:mid_col]\n    partial_sub = partial_board[0:mid_row, 0:mid_col]\n\n    # a ship tile is indicated by > 0 in true_board;\n    # an unrevealed tile is -1 in partial_board.\n    unrevealed_ship = (true_sub > 0) & (partial_sub == -1)\n\n    # return True if any such tile exists\n    return bool(np.any(unrevealed_ship))\n","name":"program_488","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row G?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed ship tile in row G, otherwise False.\n    An unrevealed ship tile is one where true_board[row] > 0 but partial_board[row] == -1.\n    \"\"\"\n    # Row G corresponds to index 6 (0-based, A\u21920, B\u21921, \u2026, G\u21926)\n    row_idx = ord('G') - ord('A')\n    \n    # Build a mask of where the true board has a ship (>0)\n    # and the partial board still marks it as hidden (-1).\n    unrevealed_ships_in_row = (true_board[row_idx] > 0) & (partial_board[row_idx] == -1)\n    \n    # If any cell satisfies both, there is at least one unrevealed ship tile in row G.\n    return bool(np.any(unrevealed_ships_in_row))\n","name":"program_489","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Between numbers 5-8","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A tile is an unrevealed ship tile if partial_board == -1 but true_board > 0\n    unrevealed_ship = (partial_board == -1) & (true_board > 0)\n    # Check only columns 5\u20138, i.e. indices 4\u20137\n    return bool(np.any(unrevealed_ship[:, 4:8]))\n","name":"program_490","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row B","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row B corresponds to index 1 (0-based indexing)\n    row_idx = 1\n    # A ship tile is indicated by value > 0 in true_board.\n    # A hidden tile is indicated by -1 in partial_board.\n    # We check if there's any position in row B that has a ship\n    # on the true board but is still hidden on the partial board.\n    unrevealed_ship_positions = (true_board[row_idx] > 0) & (partial_board[row_idx] == -1)\n    return bool(np.any(unrevealed_ship_positions))\n","name":"program_491","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Anything in row 7 or 8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows 7 and 8 correspond to zero-based indices 6 and 7.\n    # We return True if there is at least one ship tile (true_board > 0)\n    # in those rows that remains hidden (partial_board == -1).\n    rows_to_check = [6, 7]\n    # Build a mask of ship positions that are still hidden in the target rows.\n    hidden_ships = (true_board[rows_to_check, :] > 0) & (partial_board[rows_to_check, :] == -1)\n    return bool(np.any(hidden_ships))\n","name":"program_492","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"B4?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We're answering the question \"B4?\"\n    # Convert row letter 'B' to index 1, column '4' to index 3\n    row = ord('B') - ord('A')\n    col = 4 - 1\n    # Return True if there's a ship (value > 0) at that position, False otherwise\n    return bool(true_board[row, col] > 0)\n","name":"program_493","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"anthing in row 2 or 3","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship segment\n    in row 2 (index 1) or row 3 (index 2) of the board.\n    \"\"\"\n    # rows 2 and 3 correspond to indices 1 and 2\n    target_rows = [1, 2]\n    # A tile is an unrevealed ship segment if partial_board == -1 and true_board > 0\n    hidden_ship_mask = (partial_board == -1) & (true_board > 0)\n    # Check if any such tile exists in either target row\n    return bool(np.any(hidden_ship_mask[target_rows, :]))\n","name":"program_494","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"B6?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert row 'B' to zero-based index 1, and column 6 to zero-based index 5\n    row_idx = ord('B') - ord('A')\n    col_idx = 6 - 1\n    # Check if that tile contains a ship (value > 0) in the true board\n    return true_board[row_idx, col_idx] > 0\n","name":"program_495","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"F or E ?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is at least one unrevealed ship tile\n    in either row E or row F, and False otherwise.\n    Rows are 0-indexed: A\u21920, B\u21921, \u2026, E\u21924, F\u21925.\n    \"\"\"\n    # Create a mask of hidden ship tiles\n    hidden_ships = (partial_board == -1) & (true_board > 0)\n    # Check rows E (index 4) and F (index 5)\n    return bool(np.any(hidden_ships[[4, 5], :]))\n","name":"program_496","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the ship currently in play (i.e. the one with at least one revealed hit)\n    is oriented horizontally.\n\n    Args:\n        true_board (np.ndarray): The full hidden board with ship IDs 1\u20134.\n        partial_board (np.ndarray): The captain's view with -1 for hidden, 0 for water, >0 for hits.\n\n    Returns:\n        bool: True if that ship is horizontal, False otherwise.\n    \"\"\"\n    # Find which ship\u2010IDs have at least one revealed hit in the partial board\n    hit_ids = np.unique(partial_board[partial_board > 0])\n    if hit_ids.size == 0:\n        # No ship has been hit yet, so \"Horizontal?\" has no target ship \u2192 answer False\n        return False\n\n    # We assume there's only one ship in progress; pick the first hit ID\n    ship_id = hit_ids[0]\n\n    # Get all coordinates of that ship in the true board\n    coords = np.argwhere(true_board == ship_id)\n    if coords.shape[0] <= 1:\n        # A single\u2010tile ship (rare in standard Battleship) can't really be \"horizontal\"\n        return False\n\n    rows = coords[:, 0]\n    # If all row indices are the same, the ship lies horizontally\n    return np.unique(rows).size == 1\n","name":"program_497","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"up?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # 1) find which ship\u2010symbol in partial_board appears exactly once\n    revealed = partial_board[partial_board > 0]\n    # If there is no unique single\u2010tile ship (or multiple),\n    # we can\u2019t decide \u2013 say False.\n    if revealed.size == 0:\n        return False\n    # count occurrences of each ship\u2010symbol\n    vals, counts = np.unique(revealed, return_counts=True)\n    singles = vals[counts == 1]\n    if singles.size != 1:\n        return False\n    ship_type = singles[0]\n\n    # 2) locate that unique tile\n    r, c = np.argwhere(partial_board == ship_type)[0]\n\n    # 3) check one row up\n    if r == 0:\n        return False\n    return true_board[r - 1, c] > 0\n","name":"program_498","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there ships in the lower left?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there are any unrevealed ship tiles in the lower\u2010left quadrant\n    of the board, i.e. the bottom half of the rows and the left half of the columns.\n    \"\"\"\n    # Determine the halfway indices\n    nrows, ncols = true_board.shape\n    half_row = nrows \/\/ 2\n    half_col = ncols \/\/ 2\n\n    # Extract the lower\u2010left quadrant from both boards\n    true_ll = true_board[half_row:, :half_col]\n    partial_ll = partial_board[half_row:, :half_col]\n\n    # A ship tile is any cell > 0; unrevealed tiles are marked -1 in partial_board\n    unrevealed_ship = (true_ll > 0) & (partial_ll == -1)\n\n    return bool(np.any(unrevealed_ship))\n","name":"program_499","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any ships in row 4-5","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows 4 and 5 correspond to zero\u2010based indices 3 and 4.\n    rows_to_check = [3, 4]\n    # A hidden ship cell is one where true_board>0 (ship) and partial_board==-1 (hidden).\n    hidden_ships = (true_board[rows_to_check, :] > 0) & (partial_board[rows_to_check, :] == -1)\n    return np.any(hidden_ships)\n","name":"program_500","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"lower rigth?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # we assume an 8\u00d78 board; the \"half\" index is 4\n    half = true_board.shape[0] \/\/ 2\n    \n    # find cells that are ships in the true board but still hidden in the partial board\n    unrevealed_ships = (true_board > 0) & (partial_board == -1)\n    \n    # extract the lower-right quadrant (rows 4\u20137, cols 4\u20137)\n    lower_right = unrevealed_ships[half:, half:]\n    \n    # if any of those are True, there's at least one unrevealed ship cell\n    return bool(np.any(lower_right))\n","name":"program_501","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the ship currently being targeted (i.e. the one with\n    some but not all of its tiles revealed in partial_board) is placed\n    horizontally on the true_board.\n    \"\"\"\n    # Iterate over all ship IDs (1=Red, 2=Green, 3=Purple, 4=Orange)\n    for ship_id in (1, 2, 3, 4):\n        # All positions of this ship on the true board\n        true_pos = np.argwhere(true_board == ship_id)\n        # All revealed positions of this ship on the partial board\n        partial_pos = np.argwhere(partial_board == ship_id)\n        \n        # We only care about the ship that has been hit at least once\n        # but is not yet fully revealed\n        if 0 < partial_pos.shape[0] < true_pos.shape[0]:\n            # Check orientation: if all row indices are the same, it's horizontal\n            rows = true_pos[:, 0]\n            return np.all(rows == rows[0])\n    \n    # If there's no partially revealed ship, default to False\n    return False\n","name":"program_502","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all revealed ship\u2010tiles on the partial board\n    hits = partial_board > 0\n    # Extract the unique ship IDs that have been hit\n    ship_ids = np.unique(partial_board[hits])\n    ship_ids = ship_ids[ship_ids > 0]\n    # If there are no hits, we cannot determine a ship's orientation\n    if ship_ids.size == 0:\n        return False\n    # Assume question refers to the first (and in practice only) ship being pursued\n    target_id = ship_ids[0]\n    # Get all coordinates of that ship on the true board\n    coords = np.argwhere(true_board == target_id)\n    # If all row indices are the same, the ship is horizontal\n    return (coords[:, 0] == coords[0, 0]).all()\n","name":"program_503","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"upper left?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in the upper\u2010left quadrant (rows A\u2013D, columns 1\u20134).\n    \"\"\"\n    # Extract the upper\u2010left 4\u00d74 sub\u2010board\n    tb_quad = true_board[:4, :4]\n    pb_quad = partial_board[:4, :4]\n    \n    # A ship tile is true_board > 0, an unrevealed tile is partial_board == -1\n    mask_unrevealed_ship = (tb_quad > 0) & (pb_quad == -1)\n    \n    # If any such tile exists, answer \"Yes\" (True), else \"No\" (False)\n    return bool(np.any(mask_unrevealed_ship))\n","name":"program_504","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all hit tiles (positive values in partial_board)\n    hits = np.argwhere(partial_board > 0)\n    # If fewer than 2 hits, orientation can't be determined: default to False\n    if hits.shape[0] <= 1:\n        return False\n\n    # Get the ship IDs at those hit positions\n    hit_ids = partial_board[hits[:, 0], hits[:, 1]]\n    # Identify which ship has the most hits (assumed current target)\n    unique_ids, counts = np.unique(hit_ids, return_counts=True)\n    current_ship_id = unique_ids[np.argmax(counts)]\n\n    # Extract positions of that ship's hits\n    ship_hits = hits[hit_ids == current_ship_id]\n    # Rows are the first column, columns are the second\n    rows = ship_hits[:, 0]\n    cols = ship_hits[:, 1]\n\n    # If all hits share the same row index, it's horizontal\n    return np.all(rows == rows[0])\n","name":"program_505","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the last ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the last remaining (not fully revealed) ship on the board\n    is oriented vertically, False otherwise.\n    \"\"\"\n    # 1) Identify all ship IDs (positive integers) on the true board\n    ship_ids = np.unique(true_board)\n    ship_ids = ship_ids[ship_ids > 0]\n\n    # 2) Find which ship(s) still have hidden tiles (-1 in partial_board)\n    unrevealed_ships = []\n    for s in ship_ids:\n        mask = (true_board == s)\n        # If any of this ship's tiles are still hidden, it's not fully revealed\n        if np.any(partial_board[mask] == -1):\n            unrevealed_ships.append(s)\n\n    # We expect exactly one \"last\" ship remaining\n    if len(unrevealed_ships) != 1:\n        # In case of ambiguity or no ships left, default to False\n        return False\n\n    last_ship = unrevealed_ships[0]\n\n    # 3) Get the coordinates of that ship on the true board\n    coords = np.argwhere(true_board == last_ship)\n    # coords is an array of shape (N, 2): each row is (row_index, col_index)\n\n    # 4) Check orientation:\n    #    - Vertical if all column indices are the same\n    #    - Horizontal if all row indices are the same\n    cols = coords[:, 1]\n    return np.all(cols == cols[0])\n","name":"program_506","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any ships in the upper left?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in the \"upper\u2010left\" quadrant of the board (rows A\u2013D, cols 1\u20134),\n    otherwise returns False.\n    \"\"\"\n    # Determine the midpoint of the grid (assuming it's square)\n    n_rows, n_cols = true_board.shape\n    mid_row = n_rows \/\/ 2\n    mid_col = n_cols \/\/ 2\n\n    # Slice out the upper-left quadrant from both boards\n    true_quadrant = true_board[:mid_row, :mid_col]\n    partial_quadrant = partial_board[:mid_row, :mid_col]\n\n    # A ship tile is any value > 0 in true_board.\n    # An unrevealed tile in partial_board is indicated by -1.\n    unrevealed = (partial_quadrant == -1)\n    ships       = (true_quadrant  >  0)\n\n    # If any cell is both a ship and still unrevealed, return True\n    return bool(np.any(unrevealed & ships))\n","name":"program_507","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any in row 4 or 5?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want rows 4 and 5 \u2192 0-based indices 3 and 4\n    rows = [3, 4]\n    # Slice out those rows\n    tb = true_board[rows, :]\n    pb = partial_board[rows, :]\n    # Look for positions where there's a ship in true_board (>0)\n    # but still hidden in partial_board (== -1)\n    unrevealed_ship = (tb > 0) & (pb == -1)\n    return bool(np.any(unrevealed_ship))\n","name":"program_508","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"in row E-F?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there are any unrevealed ship tiles in rows E or F (rows 4 and 5, 0\u2010indexed).\n    \"\"\"\n    # Create a mask of all unrevealed ship tiles\n    unrevealed_ships = (true_board > 0) & (partial_board == -1)\n    \n    # Rows E and F correspond to indices 4 and 5\n    rows_E_F = unrevealed_ships[4:6, :]\n    \n    # If any of those positions is True, then there is at least one unrevealed ship tile\n    return np.any(rows_E_F)\n","name":"program_509","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines whether the ship that has been hit is oriented horizontally.\n\n    We locate the revealed hit(s) in partial_board, identify which ship\n    that belongs to using true_board, then examine the full set of\n    coordinates of that ship on true_board. If all of those coordinates\n    share the same row index, the ship is horizontal.\n    \"\"\"\n    # Find all positions of revealed ship hits (partial_board > 0)\n    hits = np.argwhere(partial_board > 0)\n    \n    # If there are no hits yet, we cannot determine orientation\n    if hits.size == 0:\n        return False\n    \n    # Look up the ship ID of the first hit in the true board\n    r, c = hits[0]\n    ship_id = true_board[r, c]\n    \n    # Find all coordinates of that ship on the true board\n    ship_positions = np.argwhere(true_board == ship_id)\n    \n    # If all row indices are the same, it's horizontal\n    return np.all(ship_positions[:, 0] == ship_positions[0, 0])\n","name":"program_510","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"up?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of revealed ship hits in partial_board (values > 0)\n    hits = np.argwhere(partial_board > 0)\n    for (r, c) in hits:\n        # check one row above, same column\n        if r > 0:\n            # only consider if it's still hidden in partial_board\n            if partial_board[r-1, c] == -1:\n                # if the true board has a ship there (>0), answer \"yes\"\n                if true_board[r-1, c] > 0:\n                    return True\n    # no unrevealed ship cell found directly above any hit\n    return False\n","name":"program_511","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Lower Right?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Define the lower-right quadrant: rows E\u2013H (indices 4\u20137), columns 5\u20138 (indices 4\u20137)\n    tr = true_board[4:, 4:]\n    pr = partial_board[4:, 4:]\n    # Check for any ship tiles (>0) in the true board that are still hidden (-1) in the partial board\n    return bool(np.any((tr > 0) & (pr == -1)))\n","name":"program_512","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row G?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'G' to its 0-based index (A\u21920, B\u21921, \u2026, H\u21927)\n    row_index = ord('G') - ord('A')\n    \n    # Extract the true and partial rows\n    true_row = true_board[row_index]\n    partial_row = partial_board[row_index]\n    \n    # A tile is an unrevealed ship tile if partial == -1 and true > 0\n    unrevealed_ship_tiles = (partial_row == -1) & (true_row > 0)\n    \n    # If any such tile exists, answer \"Yes\" (True), otherwise \"No\" (False)\n    return bool(np.any(unrevealed_ship_tiles))\n","name":"program_513","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"lower left?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in the\n    lower-left quadrant of the board, False otherwise.\n    \"\"\"\n    # Determine board dimensions\n    n_rows, n_cols = true_board.shape\n    \n    # Define the \"lower\" half as rows from n_rows\/\/2 to end,\n    # and the \"left\" half as columns from 0 to n_cols\/\/2 (exclusive).\n    lower_rows = slice(n_rows \/\/ 2, n_rows)\n    left_cols  = slice(0, n_cols \/\/ 2)\n    \n    # Extract the corresponding sub\u2010regions\n    true_sub    = true_board[lower_rows, left_cols]\n    partial_sub = partial_board[lower_rows, left_cols]\n    \n    # A ship tile is true_sub > 0.  A hidden tile is partial_sub == -1.\n    # We want any tile that is both ship in true_board AND still hidden.\n    unrevealed_ships = (true_sub > 0) & (partial_sub == -1)\n    \n    return bool(np.any(unrevealed_ships))\n","name":"program_514","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines whether the ship currently being targeted (i.e. the one with\n    at least one hit revealed but not yet sunk) is oriented horizontally.\n\n    Returns True if horizontal, False if vertical.\n    \"\"\"\n    # 1) Find which ship\u2010IDs have any revealed hits in partial_board\n    #    (we ignore water=0 and hidden=-1).\n    revealed_ids = np.unique(partial_board[partial_board > 0])\n\n    # 2) Among those, pick the one that is not yet fully revealed (i.e. hits < total length).\n    target_id = None\n    for ship_id in revealed_ids:\n        hits_so_far = np.count_nonzero(partial_board == ship_id)\n        total_length = np.count_nonzero(true_board == ship_id)\n        if 0 < hits_so_far < total_length:\n            target_id = ship_id\n            break\n\n    # If we didn't find any \"in\u2010progress\" ship, there's nothing to answer;\n    # we default to False (i.e. \"No, not horizontal\").\n    if target_id is None:\n        return False\n\n    # 3) Look up all the coordinates of that ship on the true board.\n    ship_rows, ship_cols = np.where(true_board == target_id)\n\n    # 4) If all row indices are the same, it's horizontal; otherwise vertical.\n    return np.all(ship_rows == ship_rows[0])\n","name":"program_515","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"in in rows a-c?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows A\u2013C correspond to indices 0,1,2\n    rows_ac_true  = true_board[0:3, :]\n    rows_ac_partial = partial_board[0:3, :]\n\n    # A ship\u2010cell in true_board is >0. A hidden cell in partial_board is -1.\n    hidden_ship_cells = (rows_ac_true > 0) & (rows_ac_partial == -1)\n\n    # If any such cell exists, answer is True (Yes), else False (No).\n    return bool(np.any(hidden_ship_cells))\n","name":"program_516","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Between numbers 5-8","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in columns 5 through 8 (1-based),\n    i.e. columns with 0-based indices 4,5,6,7. Otherwise returns False.\n    \"\"\"\n    # Create an array of column indices (0-based)\n    _, n_cols = true_board.shape\n    col_indices = np.arange(n_cols)\n    \n    # Build a mask for columns 5\u20138 (1-based) \u2192 indices 4,5,6,7\n    cols_5_to_8 = (col_indices >= 4) & (col_indices <= 7)\n    \n    # We want positions where:\n    # 1) The true board has a ship (true_board > 0)\n    # 2) The partial board is still hidden (partial_board == -1)\n    # 3) The column index is in 4..7\n    mask_unrevealed_in_5_8 = (\n        (true_board > 0) &\n        (partial_board == -1) &\n        cols_5_to_8[np.newaxis, :]\n    )\n    \n    # If any such tile exists, answer \"Yes\" (True), otherwise \"No\" (False)\n    return bool(np.any(mask_unrevealed_in_5_8))\n","name":"program_517","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"row c?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'C' to index 2 (0-based indexing)\n    row_idx = ord('C') - ord('A')\n    # A tile counts if it's a ship on the true board (> 0) but still hidden on the partial board (-1)\n    hidden_ships_in_row = (true_board[row_idx] > 0) & (partial_board[row_idx] == -1)\n    return bool(np.any(hidden_ships_in_row))\n","name":"program_518","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the purple ship on f or b?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if any segment of the purple ship (value 3 in true_board)\n    lies in row B (index 1) or row F (index 5), otherwise False.\n    \"\"\"\n    # find the row indices of all purple ship segments\n    purple_rows = np.where(true_board == 3)[0]\n    \n    # define the indices for rows B and F\n    target_rows = {1, 5}\n    \n    # check if any purple segment is on row B or row F\n    return bool(set(purple_rows) & target_rows)\n","name":"program_519","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the red ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the red ship (marked with 1)\n    red_positions = np.argwhere(true_board == 1)\n    \n    # If there are no red tiles, we cannot say it's horizontal\n    if red_positions.size == 0:\n        return False\n    \n    # Split into row indices and column indices\n    rows = red_positions[:, 0]\n    cols = red_positions[:, 1]\n    \n    # The red ship is horizontal if all its tiles share the same row\n    return np.all(rows == rows[0])\n","name":"program_520","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the green ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the green ship (encoded as 2)\n    green_positions = np.argwhere(true_board == 2)\n    # If there's fewer than 2 tiles, it can't form a vertical ship\n    if green_positions.shape[0] < 2:\n        return False\n    # Extract the column indices of those tiles\n    cols = green_positions[:, 1]\n    # The ship is vertical if all columns are the same\n    return np.unique(cols).size == 1\n","name":"program_521","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the purple shop horizontal","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the purple ship (denoted by 3)\n    coords = np.argwhere(true_board == 3)\n    # If all row indices are the same, the ship is horizontal\n    return np.all(coords[:, 0] == coords[0, 0])\n","name":"program_522","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the purple ship on H line?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines whether there are any unrevealed tiles of the purple ship (id=3)\n    on the H row (index 7).\n    \"\"\"\n    # Row 'H' corresponds to index 7 (0-based).\n    h_row_idx = 7\n    # A tile is an unrevealed purple tile if true_board==3 and partial_board==-1.\n    unrevealed_purple_on_H = (true_board[h_row_idx, :] == 3) & (partial_board[h_row_idx, :] == -1)\n    return bool(np.any(unrevealed_purple_on_H))\n","name":"program_523","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships on line D?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letters A\u2013H to indices 0\u20137; 'D' corresponds to index 3\n    row_index = ord('D') - ord('A')\n    # Extract the true row and the captain's partial view of that row\n    true_row = true_board[row_index, :]\n    partial_row = partial_board[row_index, :]\n    # A ship is present and still hidden if true_row > 0 and partial_row == -1\n    hidden_ships = (true_row > 0) & (partial_row == -1)\n    # If any such tile exists, return True ('Yes'), else False ('No')\n    return bool(np.any(hidden_ships))\n","name":"program_524","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a horizontal ship in row H?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to know if there's any *hidden* ship segment in row H\n    # that belongs to a ship oriented horizontally.\n    # Row H is the 8th row, index 7.\n    row_idx = ord('H') - ord('A')\n    n_cols = true_board.shape[1]\n    \n    for col in range(n_cols):\n        # is this tile still hidden, and is there actually a ship here?\n        if partial_board[row_idx, col] == -1 and true_board[row_idx, col] > 0:\n            ship_id = true_board[row_idx, col]\n            # check left neighbor\n            if col > 0 and true_board[row_idx, col - 1] == ship_id:\n                return True\n            # check right neighbor\n            if col < n_cols - 1 and true_board[row_idx, col + 1] == ship_id:\n                return True\n\n    # no hidden horizontal ship segments found in row H\n    return False\n","name":"program_525","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a horizontal ship in row A?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is a horizontal ship on row A that still has \n    at least one tile hidden in the partial_board, False otherwise.\n    \"\"\"\n    # Row A corresponds to index 0\n    row_idx = 0\n\n    # Iterate over each ship id on the board (1\u20134)\n    for ship_id in np.unique(true_board):\n        if ship_id <= 0:\n            continue  # skip water and empty\n\n        # Find all the coordinates occupied by this ship\n        coords = np.argwhere(true_board == ship_id)\n        if coords.shape[0] < 2:\n            # A single\u2010tile \"ship\" isn't really in this variant (ships are length 2\u20135)\n            continue\n\n        # Check if all of those coords lie in row A\n        rows = coords[:, 0]\n        if np.all(rows == row_idx):\n            # It's a horizontal ship in row A.\n            # Now check if at least one of its tiles is still hidden.\n            cols = coords[:, 1]\n            if np.any(partial_board[row_idx, cols] == -1):\n                return True\n\n    # No horizontal, partially hidden ship found in row A\n    return False\n","name":"program_526","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the ship on D4?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert row 'D' \u2192 index 3, column 4 \u2192 index 3\n    row_idx = ord('D') - ord('A')\n    col_idx = 4 - 1\n\n    # A tile contains an unrevealed ship if:\n    # 1) true_board at that tile is nonzero (a ship)\n    # 2) partial_board at that tile is still hidden (-1)\n    return (true_board[row_idx, col_idx] != 0) and (partial_board[row_idx, col_idx] == -1)\n","name":"program_527","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the ship have additional spaces up from where I just fired?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines if the ship that was just hit (i.e., a ship hit but not yet fully revealed)\n    has any additional contiguous segments directly above the hit positions.\n    \"\"\"\n    # Iterate through each ship ID\n    for ship_id in (1, 2, 3, 4):\n        # Count how many of this ship are revealed vs total on the true board\n        revealed = np.sum(partial_board == ship_id)\n        total    = np.sum(true_board   == ship_id)\n        # We're only interested in ships that have been hit but not yet fully sunk\n        if 0 < revealed < total:\n            # Find all revealed hit positions of this ship\n            hits = np.argwhere(partial_board == ship_id)\n            for i, j in hits:\n                # Check the cell directly above (i-1, j)\n                if i > 0 and true_board[i-1, j] == ship_id:\n                    return True\n            # No segment found above any of the hits\n            return False\n    # If no ship is currently in a \"hit but not sunk\" state, answer False\n    return False\n","name":"program_528","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the green ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # find all (row, col) positions of the green ship (value == 2)\n    coords = np.argwhere(true_board == 2)\n    # if we found fewer than 2 cells, there is no valid ship to orient\n    if coords.shape[0] < 2:\n        return False\n    # split into row and column arrays\n    rows, cols = coords[:, 0], coords[:, 1]\n    # vertical if all columns are equal (and rows span more than one)\n    return np.all(cols == cols[0])\n","name":"program_529","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it in lines G or H?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the green ship (encoded as 2) occupies any tiles in\n    row G (index 6) or row H (index 7) of the true_board.\n    \"\"\"\n    # Find the row indices of all green-ship tiles\n    green_rows = np.where(true_board == 2)[0]\n    # Check if any of those rows correspond to G (6) or H (7)\n    return np.any(np.isin(green_rows, [6, 7]))\n","name":"program_530","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it in lines B or C?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all positions of the green ship (coded as 2)\n    green_coords = np.argwhere(true_board == 2)\n    # If there's no green ship on the board, answer False\n    if green_coords.size == 0:\n        return False\n    # Extract the row indices of the green ship\n    green_rows = green_coords[:, 0]\n    # Check that every green\u2010ship row is either row index 1 (B) or 2 (C)\n    return np.all(np.isin(green_rows, [1, 2]))\n","name":"program_531","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it near B7?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine if the (green) ship has any unrevealed segment adjacent\n    (in Chebyshev distance 1) to the square B7.\n    \"\"\"\n    # Convert \"B7\" to zero-based indices (row 1, col 6)\n    target_r = ord('B') - ord('A')\n    target_c = 7 - 1\n\n    # Find all green\u2010ship segments (value 2 in true_board)\n    green_positions = np.argwhere(true_board == 2)\n\n    # Check if any unrevealed green segment is adjacent to B7\n    for r, c in green_positions:\n        if partial_board[r, c] == -1:\n            # Chebyshev distance \u2264 1 means \"adjacent\" including diagonals\n            if max(abs(r - target_r), abs(c - target_c)) == 1:\n                return True\n\n    return False\n","name":"program_532","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the purple ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the purple ship (value == 3)\n    positions = np.argwhere(true_board == 3)\n    # If fewer than 2 tiles, default to False (not enough info to call it horizontal)\n    if positions.shape[0] < 2:\n        return False\n    # Extract row indices\n    rows = positions[:, 0]\n    # If all row indices are the same, the ship is horizontal\n    return bool(np.all(rows == rows[0]))\n","name":"program_533","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the red ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the red ship (value 1) on the true board\n    red_coords = np.argwhere(true_board == 1)\n    \n    # If there are fewer than 2 tiles, orientation is undefined; return False by convention\n    if red_coords.shape[0] < 2:\n        return False\n    \n    # Extract the row indices and column indices\n    rows = red_coords[:, 0]\n    cols = red_coords[:, 1]\n    \n    # The ship is horizontal if all row indices are the same\n    return np.all(rows == rows[0])\n","name":"program_534","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it in a?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # The orange ship is encoded as 4.\n    ORANGE = 4\n    # Row A corresponds to index 0\n    row_index = 0\n\n    # Create a mask of all columns in row A where the true board has orange ship,\n    # and the partial board is still hidden (-1).\n    hidden_orange_in_A = (true_board[row_index] == ORANGE) & (partial_board[row_index] == -1)\n\n    # If there's any such tile, then the orange ship is (still) in row A.\n    return np.any(hidden_orange_in_A)\n","name":"program_535","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the purple ship in G or C?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the positions of the purple ship (coded as 3)\n    purple_positions = np.argwhere(true_board == 3)\n    # Extract the row indices of those positions\n    purple_rows = purple_positions[:, 0]\n    # Rows C and G correspond to indices 2 and 6\n    return bool(np.any((purple_rows == 2) | (purple_rows == 6)))\n","name":"program_536","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the green ship in b or c","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any *unrevealed* part of the green ship (value 2)\n    in row B or row C, False otherwise.\n    \"\"\"\n    # Row indices for B and C\n    rows_to_check = [1, 2]  # A=0, B=1, C=2, ...\n    # Build a mask of all unrevealed green\u2010ship tiles\n    green_unrevealed = (true_board == 2) & (partial_board == -1)\n    # Check rows B or C\n    for r in rows_to_check:\n        if np.any(green_unrevealed[r, :]):\n            return True\n    return False\n","name":"program_537","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is any part of it in E or F?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether any tile of the purple ship (coded as 3) lies in row E or row F.\n    Rows are 0-indexed as A\u21920, B\u21921, \u2026, H\u21927, so E is index 4 and F is index 5.\n    \"\"\"\n    # Mask for the purple ship\n    purple_mask = (true_board == 3)\n    # Check rows E (4) and F (5)\n    rows_E_and_F = purple_mask[[4, 5], :]\n    # If any True in those rows, some part of the purple ship is there\n    return bool(np.any(rows_E_and_F))\n","name":"program_538","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the green ship in E?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed part of the green ship (value 2 in true_board)\n    in row E, otherwise False.\n    \"\"\"\n    # Row E corresponds to index 4 (since A=0, B=1, ..., E=4)\n    row_e = ord('E') - ord('A')\n\n    # Find all positions of the green ship on the true board\n    green_rows, green_cols = np.where(true_board == 2)\n\n    # Check if any of those positions lie in row E and are still hidden on the partial board\n    for r, c in zip(green_rows, green_cols):\n        if r == row_e and partial_board[r, c] == -1:\n            return True\n\n    return False\n","name":"program_539","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is any part of it in B the D","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Answer the question: \"Is any part of the purple ship in rows B or D?\"\n    Row B has index 1, row D has index 3. We look for any tile in those rows\n    which on the true_board is the purple ship (3) and is still hidden on partial_board (-1).\n    \"\"\"\n    purple_id = 3\n    rows_to_check = [1, 3]        # B -> index 1, D -> index 3\n    # Build a mask of positions where the true board has the purple ship\n    # and the partial board still has it hidden.\n    mask = (true_board[rows_to_check, :] == purple_id) & \\\n           (partial_board[rows_to_check, :] == -1)\n    return bool(np.any(mask))\n","name":"program_540","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the Green ship anywhere near the red or purple?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if any green\u2010ship tile (value 2) on true_board is adjacent\n    (in any of the 8 directions) to a red (1) or purple (3) tile.\n    Otherwise returns False.\n    \"\"\"\n    # find the coordinates of all green\u2010ship tiles\n    green_coords = np.argwhere(true_board == 2)\n    max_row, max_col = true_board.shape\n\n    # relative offsets for all 8 neighbors\n    neighbors = [(-1, -1), (-1, 0), (-1, 1),\n                 ( 0, -1),          ( 0, 1),\n                 ( 1, -1), ( 1, 0), ( 1, 1)]\n\n    for r, c in green_coords:\n        for dr, dc in neighbors:\n            rr, cc = r + dr, c + dc\n            # check bounds\n            if 0 <= rr < max_row and 0 <= cc < max_col:\n                if true_board[rr, cc] in (1, 3):\n                    return True\n\n    return False\n","name":"program_541","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the red ship in g or h?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify unrevealed red\u2010ship tiles\n    red_unrevealed = (true_board == 1) & (partial_board == -1)\n    # Rows G and H correspond to indices 6 and 7\n    return bool(red_unrevealed[6, :].any() or red_unrevealed[7, :].any())\n","name":"program_542","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it in the numbers 4,5,6, or 7?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Any cell that is part of a ship in true_board but still hidden in partial_board\n    hidden_ships = (partial_board == -1) & (true_board > 0)\n    # Determine which ship(s) remain hidden\n    ship_types = np.unique(true_board[hidden_ships])\n    \n    # If exactly one ship is still entirely unrevealed, focus on that ship\n    if ship_types.size == 1:\n        ship_mask = (true_board == ship_types[0]) & hidden_ships\n    else:\n        # Otherwise consider all hidden ship parts\n        ship_mask = hidden_ships\n    \n    # Extract the column indices (0-based) of those hidden ship parts\n    cols = np.nonzero(ship_mask)[1]\n    # We're asking: are any of these in columns 4, 5, 6 or 7?\n    # (1-based columns 4-7 correspond to 0-based indices 3-6)\n    return np.any((cols >= 3) & (cols <= 6))\n","name":"program_543","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the green ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the green ship (value == 2) on the true board\n    coords = np.argwhere(true_board == 2)\n    \n    # If there's only one part (or none), we cannot say it's horizontal\n    if coords.shape[0] <= 1:\n        return False\n    \n    # Extract row indices and column indices\n    rows = coords[:, 0]\n    cols = coords[:, 1]\n    \n    # The ship is horizontal if all row indices are the same\n    return np.all(rows == rows[0])\n","name":"program_544","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the orange ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the orange ship (marked with 4)\n    coords = np.argwhere(true_board == 4)\n    if coords.size == 0:\n        # No orange ship found (shouldn't happen in a valid game)\n        return False\n    # Extract the row indices of all orange\u2010ship tiles\n    rows = coords[:, 0]\n    # If all row indices are the same, the ship is laid out horizontally\n    return bool(np.all(rows == rows[0]))\n","name":"program_545","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it in c or d?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # The orange ship is encoded as 4. We need to check if any of its tiles\n    # lie in row C or row D (which correspond to indices 2 and 3).\n    rows_to_check = [2, 3]  # 0\u2192A, 1\u2192B, 2\u2192C, 3\u2192D, etc.\n    for r in rows_to_check:\n        if np.any(true_board[r, :] == 4):\n            return True\n    return False\n","name":"program_546","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it in e or f?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows A\u2013H correspond to indices 0\u20137. E is index 4, F is index 5.\n    # Find all coordinates of the orange ship (value == 4)\n    orange_coords = np.argwhere(true_board == 4)\n    # Extract the row indices where the orange ship lies\n    orange_rows = orange_coords[:, 0]\n    # Check if any of those rows is E (4) or F (5)\n    return np.any(np.isin(orange_rows, [4, 5]))\n","name":"program_547","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a horizontal ship in rows D or E?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows D and E correspond to indices 3 and 4 (0\u2010based)\n    target_rows = [3, 4]\n    \n    for r in target_rows:\n        row = true_board[r]\n        # scan for any horizontal run of the same ship ID of length >= 2\n        c = 0\n        while c < row.size:\n            ship_id = row[c]\n            # skip water and hidden\n            if ship_id <= 0:\n                c += 1\n                continue\n            \n            # found the start of a potential ship segment\n            start = c\n            # extend to the right while the ship_id matches\n            while c < row.size and row[c] == ship_id:\n                c += 1\n            end = c  # one past the last tile of this segment\n            \n            # if the run is length >= 2, it's a horizontal ship\n            length = end - start\n            if length >= 2:\n                # check if any tile of this segment is still hidden on the partial board\n                if np.any(partial_board[r, start:end] == -1):\n                    return True\n            # continue scanning from c\n    # no unrevealed horizontal ship found in D or E\n    return False\n","name":"program_548","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the horizontal ship in row D?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row 'D' to its zero\u2010based index (A\u21920, B\u21921, \u2026)\n    row_idx = ord('D') - ord('A')\n    \n    # Extract the true row and the captain's partial view of that row\n    true_row = true_board[row_idx]\n    partial_row = partial_board[row_idx]\n    \n    # We'll only count ship cells that are still hidden to the captain\n    hidden_ship_cells = (true_row > 0) & (partial_row == -1)\n    \n    # For each ship type (1=Red, 2=Green, 3=Purple, 4=Orange),\n    # check if there are at least two contiguous hidden cells in this row.\n    # A count > 1 of the same ship ID in one row implies a horizontal placement.\n    for ship_id in (1, 2, 3, 4):\n        # Count how many hidden cells of this ship_id are in row D\n        count_in_row = np.sum((true_row == ship_id) & hidden_ship_cells)\n        if count_in_row > 1:\n            return True\n    \n    # No horizontal ship segment found in row D\n    return False\n","name":"program_549","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any vertical ships in rows F, G, or H?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows F, G, H correspond to indices 5, 6, 7\n    target_rows = {5, 6, 7}\n\n    # Iterate over each ship ID present in the true board\n    for ship_id in np.unique(true_board):\n        if ship_id <= 0:\n            # skip water (0) and hidden (-1)\n            continue\n\n        # Find all coordinates belonging to this ship\n        coords = np.argwhere(true_board == ship_id)\n        if coords.size == 0:\n            continue\n\n        # Determine if the ship is vertical: all columns are the same\n        cols = coords[:, 1]\n        if np.unique(cols).size != 1:\n            # not vertical\n            continue\n\n        # Check if this vertical ship occupies any of rows F, G, or H\n        rows = coords[:, 0]\n        if not any(r in target_rows for r in rows):\n            continue\n\n        # Finally, check if any of its tiles in those rows are still hidden\n        for r, c in coords:\n            if r in target_rows and partial_board[r, c] == -1:\n                return True\n\n    # No vertical ship with hidden parts in rows F, G, or H was found\n    return False\n","name":"program_550","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a horizontal ship in row G or H?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any ship in rows G or H that is placed horizontally\n    and still has at least one tile hidden on the partial_board.\n    Rows G and H correspond to indices 6 and 7 (0-based).\n    \"\"\"\n    # Iterate over each ship ID present on the board\n    for ship_id in np.unique(true_board):\n        if ship_id <= 0:\n            # skip water (0) or hidden areas (-1, if ever present in true_board)\n            continue\n\n        # Find all coordinates of this ship\n        coords = np.argwhere(true_board == ship_id)\n        rows = coords[:, 0]\n        cols = coords[:, 1]\n\n        # Check if the ship is placed horizontally (all in one row,\n        # and columns form a contiguous interval)\n        if np.all(rows == rows[0]) and (cols.max() - cols.min() + 1 == len(cols)):\n            ship_row = rows[0]\n            # Check if this horizontal ship lies in row G or H\n            if ship_row in (6, 7):\n                # Check if any part of it is still hidden on the partial board\n                for _, col in coords:\n                    if partial_board[ship_row, col] == -1:\n                        return True\n\n    return False\n","name":"program_551","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the orange ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Symbol for the orange ship is 4\n    # Find all (row, col) positions of orange in the true board\n    orange_positions = np.argwhere(true_board == 4)\n    \n    # If all of those positions lie in the same row, it's horizontal\n    rows = orange_positions[:, 0]\n    return np.unique(rows).size == 1\n","name":"program_552","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a horizontal ship in row G?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row G is index 6 (since A=0, B=1, \u2026, G=6)\n    row = 6\n    tb_row = true_board[row]\n    pb_row = partial_board[row]\n    \n    # Find all non\u2010zero runs in the true board row\n    i = 0\n    n = tb_row.size\n    while i < n:\n        if tb_row[i] > 0:\n            ship_id = tb_row[i]\n            # start of a possible horizontal ship\n            j = i\n            while j < n and tb_row[j] == ship_id:\n                j += 1\n            length = j - i\n            # if it's at least length 2, check if any of those tiles remain hidden\n            if length >= 2:\n                # pb_row[i:j] == -1 marks hidden tiles\n                if np.any(pb_row[i:j] == -1):\n                    return True\n            i = j\n        else:\n            i += 1\n    return False\n","name":"program_553","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Does the orange ship touch A6?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the cells occupied by the orange ship (denoted by 4)\n    orange_cells = np.argwhere(true_board == 4)\n\n    # Map the coordinate A6 -> row 0 (A), column 5 (6 \u2192 index 5)\n    target_row = ord('A') - ord('A')\n    target_col = 6 - 1\n\n    # Check whether any orange\u2010ship cell is adjacent (including diagonals)\n    for r, c in orange_cells:\n        if abs(r - target_row) <= 1 and abs(c - target_col) <= 1:\n            return True\n\n    return False\n","name":"program_554","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the red ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find the coordinates of all red ship tiles (denoted by 1)\n    red_positions = np.argwhere(true_board == 1)\n    \n    # If there's less than 2 tiles, we cannot determine orientation reliably.\n    # In standard Battleship, every ship has length >= 2, so this is mostly\n    # a sanity check.\n    if red_positions.shape[0] < 2:\n        return False  # Treat as not vertical if ambiguous.\n    \n    # Extract the column indices of those tiles\n    cols = red_positions[:, 1]\n    \n    # If all column indices are the same, the ship is vertical.\n    return np.all(cols == cols[0])\n","name":"program_555","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the orange ship in rows A, B or C?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any still-hidden tile of the orange ship (value 4)\n    in rows A, B, or C (i.e., row indices 0, 1, or 2). Otherwise returns False.\n    \"\"\"\n    # Find all coordinates of the orange ship on the true board\n    orange_coords = np.argwhere(true_board == 4)\n    \n    # Check if any of those coords are still hidden on the partial board\n    # and lie in rows A, B, or C (indices 0, 1, 2)\n    for r, c in orange_coords:\n        if r in (0, 1, 2) and partial_board[r, c] == -1:\n            return True\n    \n    return False\n","name":"program_556","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Does the orange ship start at A5?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Locate all tiles of the orange ship (symbol 4)\n    positions = np.argwhere(true_board == 4)\n    if positions.size == 0:\n        # No orange ship found\n        return False\n\n    rows = positions[:, 0]\n    cols = positions[:, 1]\n\n    # Determine orientation and the \"start\" tile\n    if np.all(rows == rows[0]):\n        # Horizontal: start is the leftmost column\n        start_row = rows[0]\n        start_col = cols.min()\n    elif np.all(cols == cols[0]):\n        # Vertical: start is the topmost row\n        start_row = rows.min()\n        start_col = cols[0]\n    else:\n        # Shouldn't happen in a valid Battleship placement\n        return False\n\n    # Convert A5 to zero\u2010based indices: row A -> 0, column 5 -> 4\n    return (start_row == 0 and start_col == 4)\n","name":"program_557","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any verticle ships in E f or G?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows E, F, G correspond to indices 4, 5, 6 (0-based for A\u2013H)\n    target_rows = [ord(r) - ord('A') for r in (\"E\", \"F\", \"G\")]\n    n_rows, n_cols = true_board.shape\n\n    for i in target_rows:\n        for j in range(n_cols):\n            # Check for an unrevealed ship tile in the target row\n            if true_board[i, j] > 0 and partial_board[i, j] == -1:\n                ship_id = true_board[i, j]\n                # If the same ship appears directly above or below, it's vertical\n                if (i > 0 and true_board[i - 1, j] == ship_id) or \\\n                   (i < n_rows - 1 and true_board[i + 1, j] == ship_id):\n                    return True\n    return False\n","name":"program_558","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any horizontal ships in rows G or H","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # rows G and H correspond to indices 6 and 7 in 0-based numpy arrays\n    for r in (6, 7):\n        # scan each possible adjacent pair for a horizontal ship\n        for c in range(true_board.shape[1] - 1):\n            # non-zero means ship; equality means same ship id, hence horizontal\n            if true_board[r, c] > 0 and true_board[r, c] == true_board[r, c + 1]:\n                # check if at least one of those two tiles is still hidden\n                if partial_board[r, c] == -1 or partial_board[r, c + 1] == -1:\n                    return True\n    return False\n","name":"program_559","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the orange ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the orange ship (denoted by 4)\n    coords = np.argwhere(true_board == 4)\n    \n    # If there are no orange ship tiles, default to False\n    if coords.size == 0:\n        return False\n    \n    # coords is an array of [row, col] pairs. \n    # For a horizontal ship, all row indices must be the same.\n    rows = coords[:, 0]\n    return np.all(rows == rows[0])\n","name":"program_560","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there any horizontal ships in E F or G?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows E, F, G correspond to indices 4, 5, 6\n    target_rows = [4, 5, 6]\n    n_cols = true_board.shape[1]\n    \n    for r in target_rows:\n        # scan each row for adjacent ship tiles (horizontal orientation)\n        for c in range(n_cols - 1):\n            if true_board[r, c] > 0 and true_board[r, c] == true_board[r, c + 1]:\n                # check if at least one of the two tiles is still hidden\n                if partial_board[r, c] == -1 or partial_board[r, c + 1] == -1:\n                    return True\n    return False\n","name":"program_561","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any horizontal ships in C or D?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows C and D correspond to indices 2 and 3 (0-based)\n    target_rows = [2, 3]\n    n_rows, n_cols = true_board.shape\n    \n    for r in target_rows:\n        for c in range(n_cols):\n            ship_id = true_board[r, c]\n            # Skip water or already revealed tiles\n            if ship_id <= 0 or partial_board[r, c] != -1:\n                continue\n            \n            # Check if this tile is part of a horizontal ship:\n            # look left or right for another tile of the same ship\n            left_same = (c > 0 and true_board[r, c-1] == ship_id)\n            right_same = (c < n_cols - 1 and true_board[r, c+1] == ship_id)\n            if left_same or right_same:\n                return True\n\n    return False\n","name":"program_562","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any horizontal ships in G or H?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows G and H correspond to indices 6 and 7 (0-based, A=0, B=1, \u2026)\n    rows_to_check = [ord('G') - ord('A'), ord('H') - ord('A')]\n    n_cols = true_board.shape[1]\n\n    for r in rows_to_check:\n        for c in range(n_cols):\n            cell_val = true_board[r, c]\n            if cell_val > 0 and partial_board[r, c] == -1:\n                # check if this cell is part of a horizontal ship\n                left_neighbor  = (c > 0       and true_board[r, c-1] == cell_val)\n                right_neighbor = (c < n_cols-1 and true_board[r, c+1] == cell_val)\n                if left_neighbor or right_neighbor:\n                    return True\n    return False\n","name":"program_563","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any horizontal ships in E or F?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one horizontal ship in row E or row F\n    that still has at least one hidden tile, otherwise returns False.\n    \"\"\"\n    # Rows E and F correspond to indices 4 and 5 (0-based)\n    target_rows = ['E', 'F']\n    ncols = true_board.shape[1]\n\n    for r in target_rows:\n        row_idx = ord(r) - ord('A')\n        # scan for any contiguous run of the same ship ID of length >= 2\n        for c in range(ncols - 1):\n            if true_board[row_idx, c] > 0 and true_board[row_idx, c] == true_board[row_idx, c + 1]:\n                # we found a horizontal segment \u2014 check if any part is still hidden\n                if partial_board[row_idx, c] == -1 or partial_board[row_idx, c + 1] == -1:\n                    return True\n    return False\n","name":"program_564","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any horizontal ships in A or H?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether there is any *horizontal* ship segment in row A or row H\n    that has not yet been revealed.\n\n    Arguments:\n    - true_board:    8\u00d78 numpy array encoding the full ship layout\n                     (-1 hidden, 0 water, 1\u20134 different ships).\n    - partial_board: 8\u00d78 numpy array showing the captain\u2019s view\n                     (-1 hidden, 0 water, 1\u20134 revealed ship).\n\n    Returns:\n    - True if there exists at least one horizontal ship (length \u2265 2)\n      in row A or row H with at least one tile still hidden.\n      False otherwise.\n    \"\"\"\n    # Rows A and H correspond to indices 0 and 7 in an 8\u00d78 array.\n    rows_to_check = [0, true_board.shape[0] - 1]\n\n    for r in rows_to_check:\n        # Slide a window of width 2 across columns 0..6 to detect horizontal adjacencies\n        for c in range(true_board.shape[1] - 1):\n            # Is there a ship at (r,c) and is it the same ship at (r,c+1)?\n            if true_board[r, c] > 0 and true_board[r, c] == true_board[r, c + 1]:\n                # If either tile of that adjacent pair is still hidden, we have an unrevealed\n                # horizontal segment in that row.\n                if partial_board[r, c] == -1 or partial_board[r, c + 1] == -1:\n                    return True\n\n    # No horizontal ships in A or H that remain (at least partially) hidden.\n    return False\n","name":"program_565","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the horizontal ship in H?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # we want to know if there's a horizontal ship in row H (index 7)\n    target_row = 7\n\n    # find all ship\u2010IDs on the board (1\u20264)\n    ship_ids = [sid for sid in np.unique(true_board) if sid > 0]\n\n    for sid in ship_ids:\n        # get the coordinates of this ship\n        coords = np.argwhere(true_board == sid)  # array of [row, col]\n\n        # determine if the ship is horizontal (all rows the same)\n        rows = coords[:, 0]\n        if np.all(rows == rows[0]):\n            # is this the row we're asking about?\n            if rows[0] == target_row:\n                # check if any of its cells are still hidden (-1) in partial_board\n                for (r, c) in coords:\n                    if partial_board[r, c] == -1:\n                        return True\n    # no horizontal, still-hidden ship pieces found in H\n    return False\n","name":"program_566","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a horizontal ship in A?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We're checking row A, which is index 0\n    row_idx = 0\n    row_true = true_board[row_idx]\n    row_partial = partial_board[row_idx]\n    \n    cur_id = None\n    run_start = 0\n    run_len = 0\n    n = row_true.shape[0]\n    \n    # Iterate one past the end to flush the last run\n    for j in range(n + 1):\n        if j < n and row_true[j] > 0:\n            # We're on a ship tile\n            if row_true[j] == cur_id:\n                run_len += 1\n            else:\n                # New ship segment starts\n                # Flush the previous segment if any\n                if cur_id is not None and run_len >= 2:\n                    # Check if any tile in that segment is still hidden\n                    if np.any(row_partial[run_start:run_start + run_len] == -1):\n                        return True\n                cur_id = row_true[j]\n                run_start = j\n                run_len = 1\n        else:\n            # Hit water or we're past the end: flush any ongoing segment\n            if cur_id is not None and run_len >= 2:\n                if np.any(row_partial[run_start:run_start + run_len] == -1):\n                    return True\n            cur_id = None\n            run_len = 0\n\n    # No hidden horizontal ship segments found in row A\n    return False\n","name":"program_567","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the red ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the red ship (denoted by 1)\n    red_coords = np.argwhere(true_board == 1)\n    # If all column indices are the same, it's vertical\n    return np.all(red_coords[:, 1] == red_coords[0, 1])\n","name":"program_568","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the red ship to the right of the purple ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find the column indices of the red ship (1) and the purple ship (3)\n    red_positions = np.where(true_board == 1)\n    purple_positions = np.where(true_board == 3)\n    \n    # Extract the column indices\n    red_cols = red_positions[1]\n    purple_cols = purple_positions[1]\n    \n    # If every red\u2010ship column is strictly to the right of every purple\u2010ship column,\n    # then the minimum red column index must be greater than the maximum purple column index.\n    return red_cols.min() > purple_cols.max()\n","name":"program_569","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the orange ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the orange ship (value == 4)\n    coords = np.argwhere(true_board == 4)\n    \n    # If there are no orange tiles, default to False\n    if coords.size == 0:\n        return False\n    \n    # Separate into row indices and column indices\n    rows = coords[:, 0]\n    cols = coords[:, 1]\n    \n    # The ship is horizontal if all row indices are the same\n    return np.all(rows == rows[0])\n","name":"program_570","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the red ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all positions of the red ship (marked with a 1)\n    red_positions = np.argwhere(true_board == 1)\n    \n    # If there are no red\u2010ship tiles (shouldn't happen in a valid game), say False\n    if red_positions.size == 0:\n        return False\n    \n    # Extract the row indices of those positions\n    rows = red_positions[:, 0]\n    \n    # The ship is horizontal if all row indices are the same\n    return np.unique(rows).size == 1\n","name":"program_571","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships close to the orange ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine if there is any non\u2010orange ship tile adjacent (including diagonals)\n    to any orange ship tile.\n    \"\"\"\n    # Find all coordinates of the orange ship (value == 4)\n    orange_positions = np.argwhere(true_board == 4)\n    max_row, max_col = true_board.shape\n\n    # Offsets to check all eight neighbors\n    neighbors = [(-1, -1), (-1, 0), (-1, 1),\n                 ( 0, -1),          ( 0, 1),\n                 ( 1, -1), ( 1, 0), ( 1, 1)]\n\n    for (r, c) in orange_positions:\n        for dr, dc in neighbors:\n            nr, nc = r + dr, c + dc\n            # Stay inside the board\n            if 0 <= nr < max_row and 0 <= nc < max_col:\n                val = true_board[nr, nc]\n                # If it's a ship and not orange (4), it's close\n                if val > 0 and val != 4:\n                    return True\n\n    return False\n","name":"program_572","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the purple shit 2 tiles?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the purple ship (marked with 3 on the true_board) \n    consists of exactly 2 tiles, False otherwise.\n    \"\"\"\n    # Count how many tiles are marked as purple (3) on the true board\n    purple_tile_count = np.sum(true_board == 3)\n    \n    # Return True if that count is exactly 2\n    return purple_tile_count == 2\n","name":"program_573","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the green ship close by the other ships?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines whether any tile of the green ship (value 2) is adjacent\n    (in any of the 8 surrounding directions) to a tile of any other ship\n    (red=1, purple=3, orange=4).\n    \"\"\"\n    # ship codes\n    GREEN = 2\n    OTHER_SHIPS = {1, 3, 4}\n    n_rows, n_cols = true_board.shape\n\n    # find all coordinates of the green ship\n    green_positions = np.argwhere(true_board == GREEN)\n\n    # check all 8 neighbors of each green\u2010ship tile\n    for (r, c) in green_positions:\n        for dr in (-1, 0, 1):\n            for dc in (-1, 0, 1):\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < n_rows and 0 <= nc < n_cols:\n                    if true_board[nr, nc] in OTHER_SHIPS:\n                        return True\n\n    return False\n","name":"program_574","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the orange ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the orange ship (denoted by 4)\n    orange_coords = np.argwhere(true_board == 4)\n    # If all column indices are the same, the ship is vertical\n    cols = orange_coords[:, 1]\n    return np.all(cols == cols[0])\n","name":"program_575","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is any on d?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to know if there are any *unrevealed* ship tiles in row D.\n    # Map row letter 'D' to index 3 (A\u21920, B\u21921, C\u21922, D\u21923).\n    row_index = ord('D') - ord('A')\n    \n    # A tile is still hidden if partial_board == -1.\n    hidden_mask = (partial_board == -1)\n    # A tile contains a ship if true_board > 0.\n    ship_mask   = (true_board   > 0)\n    \n    # Check if there is any position in row D that is both hidden and a ship.\n    return bool(np.any(hidden_mask[row_index] & ship_mask[row_index]))\n","name":"program_576","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is any ships on A","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row A is index 0. We want to know if there are any ship tiles in row A\n    # that remain hidden on the partial board.\n    row_index = 0  # corresponds to row A\n    # A ship tile in true_board is > 0; a hidden tile in partial_board is -1.\n    hidden_ship_tiles = (true_board[row_index] > 0) & (partial_board[row_index] == -1)\n    # If any such tile exists, answer \"Yes\" (True), otherwise \"No\" (False).\n    return bool(np.any(hidden_ship_tiles))\n","name":"program_577","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is any ships on B","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map rows A-H to indices 0-7; here we want row 'B' which is index 1\n    row_index = ord('B') - ord('A')\n    \n    # A ship tile is any entry > 0 in true_board.\n    # We only count those ship tiles in row B that are still hidden on partial_board (marked -1).\n    hidden_ships_in_B = ((true_board[row_index, :] > 0) & (partial_board[row_index, :] == -1))\n    \n    # If any hidden ship cell remains in row B, answer is True; otherwise False.\n    return bool(np.any(hidden_ships_in_B))\n","name":"program_578","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is any on C","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Compute the zero\u2010based row index for 'C'\n    row = ord('C') - ord('A')  # yields 2\n    \n    # A tile is an unrevealed ship if:\n    #   - true_board[row, col] > 0  (i.e. it's part of a ship)\n    #   - partial_board[row, col] == -1 (i.e. still hidden)\n    unrevealed_ship = (true_board[row] > 0) & (partial_board[row] == -1)\n    \n    # Return True if any such tile exists\n    return bool(np.any(unrevealed_ship))\n","name":"program_579","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships on A?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row 'A' to index 0\n    row_idx = 0\n    # A ship tile is any value > 0 in the true board\n    ships_in_row = true_board[row_idx, :] > 0\n    # We only care about tiles that are still hidden to the captain\n    hidden_tiles = partial_board[row_idx, :] == -1\n    # If there's any hidden ship tile in row A, answer Yes (True)\n    return bool(np.any(ships_in_row & hidden_tiles))\n","name":"program_580","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it only 2 tiles?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the orange ship (value 4) occupies exactly 2 tiles on the true_board,\n    otherwise returns False.\n    \"\"\"\n    # Count how many tiles on the true_board are marked as orange (4)\n    orange_tile_count = np.count_nonzero(true_board == 4)\n    # Return True if exactly 2, False otherwise\n    return (orange_tile_count == 2)\n","name":"program_581","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the last ship on H?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify all ship IDs present on the true board (ignore 0 = water)\n    ship_ids = np.unique(true_board)\n    ship_ids = ship_ids[ship_ids > 0]\n\n    # Find which ships are not yet fully revealed (i.e., have at least one hidden tile)\n    unsunk_ids = []\n    for ship_id in ship_ids:\n        # Mask of where this ship lives\n        ship_cells = (true_board == ship_id)\n        # Of those cells, check if any remain hidden on the partial board\n        if np.any(ship_cells & (partial_board == -1)):\n            unsunk_ids.append(ship_id)\n\n    # If there's no \"last\" ship, answer False\n    if not unsunk_ids:\n        return False\n\n    # We assume exactly one ship remains unsunk: the \"last\" ship\n    last_ship_id = unsunk_ids[0]\n\n    # Get the row indices of all cells of that last ship\n    rows, cols = np.where(true_board == last_ship_id)\n\n    # Row H corresponds to index 7 in 0-based indexing (A=0, B=1, ..., H=7)\n    return np.any(rows == 7)\n","name":"program_582","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it on rows 6, 7, or 8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one still\u2010hidden ship tile \n    in rows 6, 7, or 8 of the board (1-based row numbering A=1, \u2026, H=8).\n    We detect hidden ship tiles as positions where true_board \u2260 0\n    but partial_board == -1, and then check if any of those lie\n    in 0-based rows 5,6,7 (which correspond to 1-based rows 6,7,8).\n    \"\"\"\n    # Mask of all hidden ship cells\n    hidden_ship = (true_board != 0) & (partial_board == -1)\n    # 0-based rows 5,6,7 correspond to 1-based rows 6,7,8\n    return bool(hidden_ship[5:8, :].any())\n","name":"program_583","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"How about 1, 2, or 3?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there are any unrevealed ship tiles in columns 1, 2, or 3\n    (0\u2010based indices 0, 1, or 2); otherwise False.\n    \"\"\"\n    # A mask of all ship tiles that are still hidden\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n    \n    # Build an array of column indices for each position\n    # shape = (n_rows, n_cols), where entry [i,j] == j\n    col_indices = np.broadcast_to(np.arange(true_board.shape[1]), true_board.shape)\n    \n    # Check if any hidden ship tile lies in columns 0,1,2 (i.e. 1,2,3 in 1-based)\n    return bool(np.any(hidden_ships & (col_indices < 3)))\n","name":"program_584","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships on E?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row 'E' to index 4 (0-based indexing: A=0, B=1, ..., H=7)\n    row_idx = ord('E') - ord('A')\n    # A ship segment is a positive value in true_board.\n    # A hidden tile is marked as -1 in partial_board.\n    # We want to know if there is any *unrevealed* ship segment in row E.\n    unrevealed_ships = (true_board[row_idx] > 0) & (partial_board[row_idx] == -1)\n    return bool(np.any(unrevealed_ships))\n","name":"program_585","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the orange ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the orange ship (denoted by 4)\n    coords = np.argwhere(true_board == 4)\n    # If there are fewer than 2 tiles, it can't be \"horizontal\" in the sense of lying\n    if coords.shape[0] < 2:\n        return False\n    # Extract the row indices of those tiles\n    rows = coords[:, 0]\n    # If all row indices are the same, the ship lies in a single row \u2192 horizontal\n    return np.all(rows == rows[0])\n","name":"program_586","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships in the third column?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in the third column.\n    The third column corresponds to index 2 in 0-based numpy indexing.\n    \"\"\"\n    col_idx = 2\n    # A tile is an unrevealed ship tile if:\n    # - true_board has a ship (> 0)\n    # - partial_board is still hidden (-1)\n    unrevealed_ship_mask = (true_board[:, col_idx] > 0) & (partial_board[:, col_idx] == -1)\n    return bool(unrevealed_ship_mask.any())\n","name":"program_587","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships in the column labeled '8'?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in column 8,\n    i.e., any tile in column index 7 where true_board > 0 but partial_board is still hidden (-1).\n    \"\"\"\n    # Zero-based index for column '8' is 7\n    col_index = 7\n    # Find positions in that column where there's a ship in the true board\n    # and it is still unrevealed in the partial board\n    unrevealed_ships = (true_board[:, col_index] > 0) & (partial_board[:, col_index] == -1)\n    return bool(np.any(unrevealed_ships))\n","name":"program_588","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships in the row labeled \"H\"?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the 0-based index for row 'H'\n    row_index = ord('H') - ord('A')\n    \n    # Extract the true and partial rows\n    true_row = true_board[row_index]\n    partial_row = partial_board[row_index]\n    \n    # A ship tile is indicated by >0 in true_board.\n    # A hidden tile is indicated by -1 in partial_board.\n    # We return True if there's any tile in row H that is both a ship\n    # and still hidden.\n    hidden_ship_tiles = (true_row > 0) & (partial_row == -1)\n    return bool(np.any(hidden_ship_tiles))\n","name":"program_589","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships in the column labeled '1'?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Column labeled \"1\" corresponds to index 0\n    col_idx = 0\n    \n    # A tile has an unrevealed ship if true_board > 0 (ship)\n    # and partial_board == -1 (still hidden)\n    unrevealed = (true_board[:, col_idx] > 0) & (partial_board[:, col_idx] == -1)\n    \n    # If any such tile exists, answer \"Yes\"\n    return bool(np.any(unrevealed))\n","name":"program_590","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a numbered column, besides '8', that does not have any ships in it?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to know if there's any column other than the 8th\n    # (index 7 in zero-based indexing) that contains no ship tiles.\n    # On true_board, water is coded as 0 and ships as values > 0.\n    n_cols = true_board.shape[1]\n    # Iterate over columns 0 through n_cols-2 (i.e. excluding the last column)\n    for col in range(n_cols - 1):\n        # If no cell in this column has a ship (> 0), we found one\n        if not np.any(true_board[:, col] > 0):\n            return True\n    # If we never found an all-water column among columns 1\u20137, return False\n    return False\n","name":"program_591","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Do columns 5, 6 and 7 all have ships?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Columns labeled 5, 6, 7 correspond to indices 4, 5, 6 in a 0-based NumPy array.\n    cols = [4, 5, 6]\n    # For each of these columns, check if there's at least one ship tile (> 0).\n    return all(np.any(true_board[:, c] > 0) for c in cols)\n","name":"program_592","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Does column 7 have ships?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to know if there are any *unrevealed* ship tiles in column 7 (index 6).\n    col = 6\n    # A tile is an unrevealed ship if true_board > 0 and partial_board == -1\n    unrevealed = (true_board[:, col] > 0) & (partial_board[:, col] == -1)\n    return bool(unrevealed.any())\n","name":"program_593","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Does column 6 have any ships?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in column 6,\n    otherwise False.\n    \"\"\"\n    # Convert from human 1\u20138 \u2192 0\u20137 indexing\n    col_idx = 6 - 1\n    \n    # A tile is an unrevealed ship if true_board > 0 (ship) AND partial_board == -1 (hidden)\n    unrevealed_ship_mask = (true_board > 0) & (partial_board == -1)\n    \n    # Check if any tile in the specified column is an unrevealed ship\n    return bool(unrevealed_ship_mask[:, col_idx].any())\n","name":"program_594","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Do any other numbered rows, besides H, not contain any ships?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there exists at least one row, other than the last row (H),\n    that contains no ship cells on the true_board. Otherwise return False.\n    \"\"\"\n    # Determine which rows have any ship cells (> 0)\n    # true_board > 0 marks ship cells; .any(axis=1) tells us per-row occupancy.\n    has_ship = (true_board > 0).any(axis=1)\n    \n    # Exclude the last row (index = number_of_rows - 1), which corresponds to \"H\"\n    rows_except_H = has_ship[:-1]\n    \n    # If any of these rows has no ships (i.e. False), answer is True\n    return bool(np.any(~rows_except_H))\n","name":"program_595","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Do rows E, F and G all have ships?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if each of rows E, F, and G still contains at least one\n    unrevealed ship segment; otherwise returns False.\n    \"\"\"\n    # Map row labels to indices\n    row_labels = ['A','B','C','D','E','F','G','H']\n    target_rows = ['E','F','G']\n    \n    for label in target_rows:\n        i = row_labels.index(label)\n        # A ship segment is present and still hidden if true_board > 0 and partial_board == -1\n        hidden_ship_mask = (true_board[i, :] > 0) & (partial_board[i, :] == -1)\n        if not hidden_ship_mask.any():\n            # This row has no unrevealed ship segments\n            return False\n    # All rows E, F, and G have at least one hidden ship tile\n    return True\n","name":"program_596","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Does row G have any ships?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'G' to its 0-based index (A\u21920, B\u21921, \u2026, G\u21926)\n    row_idx = ord('G') - ord('A')\n    \n    # Extract that row from both boards\n    true_row = true_board[row_idx]\n    partial_row = partial_board[row_idx]\n    \n    # A ship segment is any cell where true_board > 0.\n    # We only count those that are still hidden on partial_board (== \u20131).\n    still_hidden_ship = np.logical_and(true_row > 0, partial_row == -1)\n    \n    # If any such segment exists, the answer is True (\"Yes\"), otherwise False (\"No\").\n    return np.any(still_hidden_ship)\n","name":"program_597","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Does row F have any ships?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row label 'A'\u2013'H' to indices 0\u20137. We want row 'F'.\n    row_label = 'F'\n    row_idx = ord(row_label) - ord('A')\n    # In the true_board, ship tiles are marked > 0.\n    # In the partial_board, unrevealed tiles are -1.\n    # If there's any cell in row F where true_board > 0 and partial_board is still -1,\n    # then there is at least one (hidden) ship tile remaining in row F.\n    hidden_ship_mask = (true_board[row_idx] > 0) & (partial_board[row_idx] == -1)\n    return bool(np.any(hidden_ship_mask))\n","name":"program_598","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Do any other rows, besides F and H, not have any ships?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine if there is any row, other than F and H, which has\n    no unrevealed ship tiles. We treat 'unrevealed ship tiles' as\n    positions where true_board > 0 (a ship) and partial_board == -1\n    (still hidden).\n    \"\"\"\n    # Map row letters to indices: A\u21920, B\u21921, \u2026, F\u21925, \u2026, H\u21927\n    row_F = ord('F') - ord('A')\n    row_H = ord('H') - ord('A')\n    \n    n_rows = true_board.shape[0]\n    for r in range(n_rows):\n        if r in (row_F, row_H):\n            # skip rows F and H\n            continue\n        # mask of unrevealed ship tiles in this row\n        unrevealed_ships = (true_board[r, :] > 0) & (partial_board[r, :] == -1)\n        # if there are no unrevealed ships in this row, it \"does not have any ships\"\n        if not np.any(unrevealed_ships):\n            return True\n\n    return False\n","name":"program_599","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships in row A?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row A corresponds to index 0\n    row_idx = 0\n    \n    # A ship tile on the true board is > 0.\n    # A hidden tile on the partial board is == -1.\n    # We want to know if there's any ship tile in row A that remains hidden.\n    hidden_ship_tiles = (true_board[row_idx] > 0) & (partial_board[row_idx] == -1)\n    \n    return bool(np.any(hidden_ship_tiles))\n","name":"program_600","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships in row B?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row labels 'A'\u2013'H' to indices 0\u20137\n    # The captain asked about row 'B'\n    row_label = 'B'\n    row_idx = ord(row_label) - ord('A')\n    \n    # A ship tile is indicated by a value > 0 in true_board.\n    # Hidden tiles on partial_board are marked as -1.\n    # We want to know if there is at least one hidden ship tile in row B.\n    hidden_ship_tiles = (true_board[row_idx] > 0) & (partial_board[row_idx] == -1)\n    \n    return bool(np.any(hidden_ship_tiles))\n","name":"program_601","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any ships or part of any ships in Row A?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letters to indices: 'A' -> 0, 'B' -> 1, ..., 'H' -> 7\n    # Here the Captain asked about Row A, so index = 0.\n    row_index = 0\n    \n    # A tile counts as an unrevealed ship part if\n    # 1) true_board at that position is nonzero (i.e., there is a ship)\n    # 2) partial_board at that position is still hidden (i.e., == -1)\n    unrevealed_ship_tiles = (true_board[row_index] != 0) & (partial_board[row_index] == -1)\n    \n    # If any such tile exists, the answer is \"Yes\"\n    return bool(np.any(unrevealed_ship_tiles))\n","name":"program_602","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Do any other lettered rows, besides A, have no ships or part of any ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A row is \u201cempty\u201d if it has no entries > 0 in the true_board.\n    # We assume row 0 == A, row 1 == B, \u2026, row 7 == H.\n    ship_cells_per_row = np.sum(true_board > 0, axis=1)\n    # Exclude row A (index 0) and see if any of the others is empty\n    return bool(np.any(ship_cells_per_row[1:] == 0))\n","name":"program_603","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is any part of the remaining ship in row H?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in row H,\n    False otherwise.\n    \n    We identify all ship tiles in true_board (values > 0) that are still\n    hidden in partial_board (value == -1).  Then we check if any of those\n    tiles lie in the last row (index 7, corresponding to 'H').\n    \"\"\"\n    # mask of all ship cells in the true board\n    ship_cells = true_board > 0\n    \n    # mask of all remaining hidden cells in the partial board\n    hidden_cells = partial_board == -1\n    \n    # unrevealed ship cells\n    remaining_ships = ship_cells & hidden_cells\n    \n    # row H is the 8th row => index 7\n    return np.any(remaining_ships[7, :])\n","name":"program_604","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Do any of the remaining two ships border the two destroyed ships?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if any of the remaining (undestroyed) ships\n    border (share an edge with) any of the destroyed ships.\n    Otherwise return False.\n    \"\"\"\n    # All ship\u2010IDs on the board\n    ship_ids = [1, 2, 3, 4]\n\n    # 1) Identify which ships are destroyed: every true_board cell for that ship\n    #    has already been uncovered in partial_board.\n    destroyed_ids = []\n    for sid in ship_ids:\n        # Find all coordinates of ship sid in the true board\n        coords = np.argwhere(true_board == sid)\n        if coords.size == 0:\n            # No such ship\u2014or it's already sunk and cleared\u2014skip it\n            continue\n        # Check that every one of those coords is revealed in partial_board\n        if all(partial_board[tuple(pt)] == sid for pt in coords):\n            destroyed_ids.append(sid)\n\n    # 2) The remaining ships are those not in destroyed_ids\n    remaining_ids = [sid for sid in ship_ids if sid not in destroyed_ids]\n\n    # 3) Gather the sets of coordinates for destroyed ships and remaining ships\n    destroyed_cells = set()\n    for sid in destroyed_ids:\n        for (r, c) in np.argwhere(true_board == sid):\n            destroyed_cells.add((r, c))\n\n    remaining_cells = set()\n    for sid in remaining_ids:\n        for (r, c) in np.argwhere(true_board == sid):\n            remaining_cells.add((r, c))\n\n    # 4) Check for any orthogonal adjacency between remaining_cells and destroyed_cells\n    #    Adjacent offsets\n    neighbors = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    for (r, c) in remaining_cells:\n        for dr, dc in neighbors:\n            if (r + dr, c + dc) in destroyed_cells:\n                return True\n\n    return False\n","name":"program_605","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Does every numbered column have a ship or part of a ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if and only if every column (1 through 8) still\n    contains at least one unrevealed ship tile.\n\n    A tile is an unrevealed ship tile if:\n      - true_board[i, j] > 0   (it is part of a ship)\n      - partial_board[i, j] == -1  (it has not yet been revealed)\n\n    We then check for each column j whether there is any such tile.\n    If every column has at least one, return True; otherwise False.\n    \"\"\"\n    # mask of all unrevealed ship cells\n    unrevealed_ship = (true_board > 0) & (partial_board == -1)\n    # for each column, check if there's any unrevealed ship cell\n    cols_have_ship = np.any(unrevealed_ship, axis=0)\n    # return True only if all columns have at least one unrevealed ship cell\n    return bool(np.all(cols_have_ship))\n","name":"program_606","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Would G7 be a hit or border a ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert \"G7\" into zero\u2010based row, col indices\n    row = ord('G') - ord('A')   # G \u2192 6\n    col = 7 - 1                 # 7 \u2192 6\n\n    # Check if G7 itself is a ship\n    if true_board[row, col] > 0:\n        return True\n\n    # Check its four orthogonal neighbors for any ship part\n    for dr, dc in ((1,0), (-1,0), (0,1), (0,-1)):\n        r, c = row + dr, col + dc\n        # stay inside the board\n        if 0 <= r < true_board.shape[0] and 0 <= c < true_board.shape[1]:\n            if true_board[r, c] > 0:\n                return True\n\n    # Neither a hit nor adjacent to any ship\n    return False\n","name":"program_607","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Do any ships border another?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if any two different ships on true_board share an edge\n    (i.e., touch orthogonally), False otherwise.\n    \"\"\"\n    rows, cols = true_board.shape\n    # Directions for orthogonal neighbors: up, down, left, right\n    neighbors = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    \n    for r in range(rows):\n        for c in range(cols):\n            ship_id = true_board[r, c]\n            # Skip water and hidden tiles\n            if ship_id <= 0:\n                continue\n            # Check each orthogonal neighbor\n            for dr, dc in neighbors:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    neighbor_id = true_board[nr, nc]\n                    # If neighbor is a different ship, they border\n                    if neighbor_id > 0 and neighbor_id != ship_id:\n                        return True\n    return False\n","name":"program_608","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are either of the remaining ships in numbered columns 1, 2 or 3?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # mask of all ship\u2010tiles (true_board>0) that are still hidden (partial_board == -1)\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n    # columns 1,2,3 correspond to indices 0,1,2\n    # if any hidden ship\u2010tile exists in those columns, return True\n    return bool(hidden_ships[:, :3].any())\n","name":"program_609","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there more than one ship in column 1?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We're interested in column 1, which is index 0 in a 0\u2010based numpy array.\n    col_index = 0\n\n    # Extract the true values and the partial (captain's) view for column 1.\n    true_col = true_board[:, col_index]\n    partial_col = partial_board[:, col_index]\n\n    # A ship segment is \"hidden\" if the true board has a ship (value > 0)\n    # and the partial board still shows it as hidden (-1).\n    hidden_mask = (true_col > 0) & (partial_col == -1)\n\n    # Gather the distinct ship IDs in that column that are still hidden.\n    hidden_ships = np.unique(true_col[hidden_mask])\n\n    # If more than one distinct ship ID remains hidden in column 1, return True.\n    return hidden_ships.size > 1\n","name":"program_610","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are either of the remaining ships in columns 4 and 5?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # 1) Find which ship\u2010IDs still have at least one hidden tile:\n    #    a hidden ship tile is true_board>0 and partial_board==-1\n    hidden_tiles = (true_board > 0) & (partial_board == -1)\n    remaining_labels = np.unique(true_board[hidden_tiles])\n    \n    # 2) For each remaining ship\u2010ID, check whether any of its tiles lie\n    #    in column 4 or 5 (1-based), i.e. indices 3 or 4 (0-based).\n    for label in remaining_labels:\n        ship_mask = (true_board == label)\n        # check column index 3 or 4\n        if ship_mask[:, 3].any() or ship_mask[:, 4].any():\n            return True\n\n    # if none of the remaining ships touch column 4 or 5:\n    return False\n","name":"program_611","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Would H1 be a hit?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # H1 corresponds to row 'H' (index 7) and column '1' (index 0)\n    # It's a hit if the true board at that position is nonzero.\n    return true_board[7, 0] != 0\n","name":"program_612","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the rest of the green ship on B5?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A green ship is denoted by 2. Find all its tiles that are still hidden.\n    hidden_green = (true_board == 2) & (partial_board == -1)\n    # Get their coordinates\n    rows, cols = np.where(hidden_green)\n    # We want to know if the *only* remaining green tile is at B5.\n    # B5 in 0-based indexing is row 1, column 4.\n    return (rows.size == 1) and (rows[0] == 1) and (cols[0] == 4)\n","name":"program_613","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the rest of the green ship on A4?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if any as-yet-unrevealed green ship tile (value 2 in true_board)\n    lies at A4, otherwise False.\n    \"\"\"\n    # Identify the green ship tiles in the true board\n    green_tiles = (true_board == 2)\n    # Identify which of those tiles are still hidden on the partial board\n    hidden_green = green_tiles & (partial_board == -1)\n    # A4 corresponds to row 0, column 3 in 0-based indexing\n    return bool(hidden_green[0, 3])\n","name":"program_614","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Does that ship, the red one, border any other ships?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if any cell of the red ship (value==1) borders\n    any cell of a different ship (values 2,3,4) in the true_board.\n    Adjacency is considered in all 8 directions.\n    \"\"\"\n    # Find all coordinates of the red ship\n    red_positions = np.argwhere(true_board == 1)\n    n_rows, n_cols = true_board.shape\n\n    # Offsets for all 8 neighbors\n    neighbors = [(-1, -1), (-1, 0), (-1, 1),\n                 ( 0, -1),          ( 0, 1),\n                 ( 1, -1), ( 1, 0), ( 1, 1)]\n\n    for (r, c) in red_positions:\n        for dr, dc in neighbors:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < n_rows and 0 <= nc < n_cols:\n                # If the neighbor cell is a ship other than red (i.e., 2,3,4)\n                if true_board[nr, nc] > 1:\n                    return True\n    return False\n","name":"program_615","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the bordering ship below it?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines whether the ship(s) that border the red ship (value 1)\n    touch the red ship from below (i.e. on the row immediately beneath\n    any red\u2010ship cell).\n    \"\"\"\n    # Dimensions of the board\n    n_rows, n_cols = true_board.shape\n\n    # Find all coordinates of the red ship (value == 1)\n    red_positions = np.argwhere(true_board == 1)\n\n    # For each red\u2010ship cell, check the cell directly below it.\n    for r, c in red_positions:\n        below_row = r + 1\n        # Skip if we're at the bottom edge\n        if below_row < n_rows:\n            # If the cell below is a ship (value > 1), it's a different ship\n            if true_board[below_row, c] > 1:\n                return True\n\n    # No red\u2010ship cell has a different ship directly below it\n    return False\n","name":"program_616","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships or part of any ships in row A?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in row A,\n    False otherwise.\n    \"\"\"\n    # Row A corresponds to index 0\n    row_index = 0\n    \n    # A tile is an unrevealed ship tile if:\n    #   - true_board > 0 (it is part of a ship)\n    #   - partial_board == -1 (it is still hidden)\n    unrevealed_in_A = np.logical_and(true_board[row_index] > 0,\n                                      partial_board[row_index] == -1)\n    \n    return bool(np.any(unrevealed_in_A))\n","name":"program_617","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Does every lettered row have any ships or part of any ships?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if every lettered row (A through H) still contains at least one\n    unrevealed ship tile, False otherwise.\n    \"\"\"\n    # A tile is still hidden if partial_board == -1\n    hidden_tiles = (partial_board == -1)\n    # A tile is part of a ship if true_board > 0\n    ship_tiles = (true_board > 0)\n    # Hidden ship tiles\n    hidden_ship_tiles = hidden_tiles & ship_tiles\n    # Check each row: does it contain any hidden ship tile?\n    rows_with_hidden_ships = np.any(hidden_ship_tiles, axis=1)\n    # Return True if ALL rows have at least one hidden ship tile\n    return bool(np.all(rows_with_hidden_ships))\n","name":"program_618","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships are part of any ships in row H?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'H' to index 7 (0-based)\n    row_index = ord('H') - ord('A')\n    # A tile is an unrevealed ship part if true_board>0 and partial_board is still hidden (-1)\n    unrevealed_ship_tiles = (true_board[row_index, :] > 0) & (partial_board[row_index, :] == -1)\n    # If any such tile exists, answer is True; otherwise False\n    return bool(np.any(unrevealed_ship_tiles))\n","name":"program_619","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Do the three rows E, F and G all have ships or parts of ships?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if each of rows E, F, and G has at least one *unrevealed* ship tile,\n    i.e., a position where true_board > 0 and partial_board == -1.\n    Otherwise return False.\n    \"\"\"\n    # Map row letters 'E','F','G' to zero-based indices 4,5,6\n    target_rows = [ord(c) - ord('A') for c in ['E', 'F', 'G']]\n    \n    # For each target row, check if there's any ship tile (true_board>0)\n    # that is still hidden (partial_board == -1).\n    for r in target_rows:\n        # Boolean mask of unrevealed ship tiles in row r\n        unrevealed_ships = (true_board[r, :] > 0) & (partial_board[r, :] == -1)\n        if not np.any(unrevealed_ships):\n            # If any of the rows lacks an unrevealed ship part, answer is False\n            return False\n    \n    # All three rows have at least one unrevealed ship part\n    return True\n","name":"program_620","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the green ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find the coordinates of all green ship tiles (denoted by 2)\n    green_positions = np.argwhere(true_board == 2)\n    if green_positions.size == 0:\n        # No green ship found (shouldn't happen in a valid game), default to False\n        return False\n    # Extract the row indices of those positions\n    rows = green_positions[:, 0]\n    # The green ship is horizontal if all its tiles share the same row index\n    return np.all(rows == rows[0])\n","name":"program_621","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Does G7 has a ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # The Captain is asking about tile G7.\n    # Rows A\u2013H map to indices 0\u20137, columns 1\u20138 map to indices 0\u20137.\n    row_idx = ord('G') - ord('A')  # G \u2192 6\n    col_idx = 7 - 1                # 7 \u2192 6\n\n    # Return True if there's a ship on the true board at G7, False otherwise.\n    return bool(true_board[row_idx, col_idx] > 0)\n","name":"program_622","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Does B4 have a ship?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert row 'B' to index 1 and column '4' to index 3\n    row_idx = ord('B') - ord('A')\n    col_idx = 4 - 1\n    # True if there's a ship (value > 0) at that position\n    return true_board[row_idx, col_idx] > 0\n","name":"program_623","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the green ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the green ship (value 2) on the true board\n    green_positions = np.argwhere(true_board == 2)\n    if green_positions.size == 0:\n        # No green ship found (shouldn't happen in a valid game)\n        return False\n\n    # Extract row indices and column indices\n    rows = green_positions[:, 0]\n    cols = green_positions[:, 1]\n\n    # The ship is vertical if all columns are the same (and it spans more than one row)\n    return np.all(cols == cols[0]) and (rows.max() - rows.min() + 1 == len(rows))\n","name":"program_624","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"H4 got ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert row letter 'H' to 0-based index (A->0, B->1, ..., H->7)\n    row_idx = ord('H') - ord('A')\n    # Convert column number 4 to 0-based index\n    col_idx = 4 - 1\n    # Return True if there's a ship (value > 0) at H4, False otherwise\n    return true_board[row_idx, col_idx] > 0\n","name":"program_625","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"C5 any ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Captain asked: \"C5 any ship?\"\n    # Convert row 'C' to index 2 (0-based), column 5 to index 4 (0-based)\n    row_idx = ord('C') - ord('A')\n    col_idx = 5 - 1\n\n    # If the captain has already revealed this tile, there is no _hidden_ ship there.\n    if partial_board[row_idx, col_idx] != -1:\n        return False\n\n    # Otherwise, return True iff the true board has a ship (> 0) at that location.\n    return true_board[row_idx, col_idx] > 0\n","name":"program_626","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Ship G5?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is (still hidden or already revealed) a ship\n    at coordinate G5, False otherwise.\n    \"\"\"\n    # Convert row 'G' \u2192 index 6 (A\u21920, B\u21921, \u2026, G\u21926), column 5 \u2192 index 4\n    row_idx = ord('G') - ord('A')\n    col_idx = 5 - 1\n    # In our encoding, 1\u20134 are ship ids, 0 is water\n    return true_board[row_idx, col_idx] != 0\n","name":"program_627","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"H6 any ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'H' to index 7 (0-based), and column 6 to index 5\n    row_idx = ord('H') - ord('A')\n    col_idx = 6 - 1\n    # Return True if there's an (unrevealed) ship at H6\n    return true_board[row_idx, col_idx] > 0\n","name":"program_628","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Does A1 have ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert coordinate \"A1\" to zero-based indices (row 0, col 0)\n    row_idx = 0\n    col_idx = 0\n\n    # A tile contains a ship if its true_board value is > 0\n    return true_board[row_idx, col_idx] > 0\n","name":"program_629","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"G8 any ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # The Captain asked: \"G8 any ship?\"\n    # Convert the row letter 'G' to a 0-based index (A\u21920, B\u21921, \u2026, G\u21926)\n    row_idx = ord('G') - ord('A')\n    # Convert the column number 8 to a 0-based index (1\u21920, 2\u21921, \u2026, 8\u21927)\n    col_idx = 8 - 1\n\n    # Check the true board at that position: \n    # if it's > 0, there's a ship; if it's 0, it's water.\n    return true_board[row_idx, col_idx] > 0\n","name":"program_630","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Does A2 have ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # The Captain asked about A2, which is row 'A' (index 0) and column '2' (index 1).\n    # We simply check the true board at that location: if it's non\u2010zero, there's a ship.\n    return true_board[0, 1] != 0\n","name":"program_631","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"D5 any ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # The Captain asked: \"D5 any ship?\"\n    # Convert \"D5\" to zero\u2010based indices: row D \u2192 3, column 5 \u2192 4\n    row_idx = ord('D') - ord('A')\n    col_idx = 5 - 1\n    \n    # A ship is present in true_board if the value > 0.\n    # We only count it as \"unrevealed\" if partial_board still has -1 at that spot.\n    is_ship = true_board[row_idx, col_idx] > 0\n    is_hidden = partial_board[row_idx, col_idx] == -1\n    \n    return bool(is_ship and is_hidden)\n","name":"program_632","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is t5here a ship in D1","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We're being asked: \"Is there a ship in D1?\"\n    coord = \"D1\"\n    # Convert row letter to 0-based index (A\u21920, B\u21921, \u2026)\n    row = ord(coord[0]) - ord(\"A\")\n    # Convert column string to 0-based index\n    col = int(coord[1:]) - 1\n    # If the true board at that position is > 0, there is a ship\n    return true_board[row, col] > 0\n","name":"program_633","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"C5 any ship?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row 'C' -> index 2, column 5 -> index 4\n    row = ord('C') - ord('A')\n    col = 5 - 1\n    # true_board uses 0 for water, >0 for ship\n    return true_board[row, col] > 0\n","name":"program_634","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"H5 any ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert \"H5\" into zero\u2010based indices: row 'H' \u2192 7, column 5 \u2192 index 4\n    row_idx = ord('H') - ord('A')\n    col_idx = 5 - 1\n    \n    # There is a ship at H5 if the true_board entry is nonzero.\n    return true_board[row_idx, col_idx] != 0\n","name":"program_635","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"D4 any ship?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map 'D4' \u2192 row index 3 (A=0, B=1, C=2, D=3), column index 3 (1\u21920, 2\u21921, 3\u21922, 4\u21923)\n    row_idx = ord('D') - ord('A')\n    col_idx = 4 - 1\n    # Return True if the true_board at D4 is a ship (i.e., > 0)\n    return true_board[row_idx, col_idx] > 0\n","name":"program_636","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the purple ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # In this variant, the purple ship is represented by 3.\n    # Find all coordinates (row, col) where true_board == 3\n    purple_positions = np.argwhere(true_board == 3)\n    \n    # If there are fewer than 2 tiles, it can't form a ship of length >=2\n    if purple_positions.shape[0] < 2:\n        return False\n    \n    # Extract the column indices of those positions\n    cols = purple_positions[:, 1]\n    \n    # If all column indices are the same, the ship is vertical\n    return np.all(cols == cols[0])\n","name":"program_637","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the green ship horizontal on the right?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find the (row, col) coordinates of every green\u2010ship cell (value == 2)\n    rows, cols = np.where(true_board == 2)\n\n    # If there are no green cells, we cannot say it's horizontal on the right\n    if len(rows) == 0:\n        return False\n\n    # 1) Check horizontal: are all green\u2010cells in the same row?\n    is_horizontal = (rows.max() == rows.min())\n\n    # 2) Check \"on the right\": are all green\u2010cells in the right half?\n    #    We divide the board vertically in two equal halves.\n    n_cols = true_board.shape[1]\n    right_threshold = n_cols \/\/ 2  # e.g. for 8 columns, this is 4\n    is_on_right = np.all(cols >= right_threshold)\n\n    # Return True only if both conditions hold\n    return bool(is_horizontal and is_on_right)\n","name":"program_638","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"B7 any ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert \"B7\" into zero\u2010based indices:\n    row = ord('B') - ord('A')   # B \u2192 1\n    col = 7 - 1                 # 7 \u2192 6\n\n    # We only report \"Yes\" if there's a ship on the true board at B7\n    # that the captain has not yet revealed (partial_board is still -1).\n    return (partial_board[row, col] == -1) and (true_board[row, col] != 0)\n","name":"program_639","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"any ship line one ?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in column 1 (i.e., 'line one'),\n    otherwise returns False.\n    \"\"\"\n    # Column index for \"line one\" is 0 (since columns are numbered 1\u20138 but zero\u2010indexed in numpy).\n    col_idx = 0\n\n    # Extract the true contents and the visible (partial) contents of column 1\n    true_col = true_board[:, col_idx]\n    partial_col = partial_board[:, col_idx]\n\n    # A tile is an unrevealed ship if:\n    #   - true_board > 0  (there really is a ship there)\n    #   - partial_board == -1  (the Captain hasn't seen it yet)\n    unrevealed_ship_mask = (true_col > 0) & (partial_col == -1)\n\n    # If any entry in that mask is True, then there remains at least one ship tile in column 1\n    return bool(np.any(unrevealed_ship_mask))\n","name":"program_640","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"any ship beneath the orange ones?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the orange ship (value 4) on the true board\n    orange_coords = np.argwhere(true_board == 4)\n    max_row = true_board.shape[0]\n    \n    # For each orange tile, check every tile directly below it in the same column\n    for row, col in orange_coords:\n        for r in range(row + 1, max_row):\n            # If there's any ship segment (value > 0) beneath, return True\n            if true_board[r, col] > 0:\n                return True\n    \n    # If we exhaust all orange tiles without finding a ship beneath, return False\n    return False\n","name":"program_641","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any on line one both horizontal and vertical?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A tile is an unrevealed ship\u2010tile if partial_board == -1 and true_board > 0\n    unrevealed_ships = (partial_board == -1) & (true_board > 0)\n    # check row 0 (line one horizontal) or column 0 (line one vertical)\n    if unrevealed_ships[0, :].any() or unrevealed_ships[:, 0].any():\n        return True\n    else:\n        return False\n","name":"program_642","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"any on the line d above ?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines whether there is at least one (hidden) ship tile on row D\n    immediately above any revealed orange ship tile in the partial_board.\n    \"\"\"\n    # Find the coordinates of all revealed orange ship tiles in the partial board.\n    # In our encoding, orange ships are denoted by 4.\n    orange_coords = np.argwhere(partial_board == 4)\n\n    # For each orange tile, look one row up (row index -1).\n    for r, c in orange_coords:\n        r_above = r - 1\n        # ensure the \"above\" row is still on the board\n        if r_above >= 0:\n            # Check true_board to see if there's a ship there (>0) and\n            # check partial_board to see if it's still hidden (-1).\n            if true_board[r_above, c] > 0 and partial_board[r_above, c] == -1:\n                return True\n\n    # If none of the spots above the revealed oranges contain a hidden ship,\n    # return False.\n    return False\n","name":"program_643","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the green ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Locate all the tiles belonging to the green ship (denoted by 2)\n    green_positions = np.argwhere(true_board == 2)\n    \n    # Extract the unique columns occupied by the green ship\n    unique_cols = np.unique(green_positions[:, 1])\n    \n    # If there's exactly one unique column, the green ship is vertical\n    return unique_cols.size == 1\n","name":"program_644","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any orange ship on the right?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed orange ship tile (value 4)\n    in the right half of the board (columns 5\u20138, i.e., indices 4\u20137).\n    Otherwise returns False.\n    \"\"\"\n    # Determine the column split for the \"right\" half\n    n_cols = true_board.shape[1]\n    right_start = n_cols \/\/ 2  # for an 8-column board, this is index 4 (5th column)\n\n    # Slice out the right half of both boards\n    true_right = true_board[:, right_start:]\n    partial_right = partial_board[:, right_start:]\n\n    # Identify positions of orange ship tiles that remain hidden\n    orange_unrevealed = (true_right == 4) & (partial_right == -1)\n\n    # If any such tile exists, answer \"Yes\" (True), otherwise \"No\" (False)\n    return bool(np.any(orange_unrevealed))\n","name":"program_645","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are the remaining ship beneath the red ones?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one still\u2010hidden ship tile located\n    in any row beneath any of the red ship's tiles.\n    Otherwise returns False.\n    \"\"\"\n    # Locate all the red\u2010ship cells (value == 1) in the full board\n    red_rows = np.where(true_board == 1)[0]\n    # If there is no red ship or no rows under the red ship, answer is False\n    if red_rows.size == 0:\n        return False\n    max_red_row = red_rows.max()\n    if max_red_row == true_board.shape[0] - 1:\n        return False\n\n    # Look at all rows strictly below the lowest red row\n    sub_true = true_board[max_red_row + 1 :, :]\n    sub_part = partial_board[max_red_row + 1 :, :]\n\n    # A hidden ship tile is one where true_board>0 but partial_board==-1\n    hidden_ships_below = (sub_true > 0) & (sub_part == -1)\n    return bool(np.any(hidden_ships_below))\n","name":"program_646","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any ships in columns 1 or 2","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert human columns 1 and 2 to zero\u2010based indices 0 and 1\n    cols_to_check = [0, 1]\n    # A ship tile is true_board>0. We only care about those that are still hidden on partial_board (== -1).\n    ships_still_hidden = (true_board[:, cols_to_check] > 0) & (partial_board[:, cols_to_check] == -1)\n    # If any such tile exists, answer \"Yes\" (True), otherwise \"No\" (False).\n    return bool(np.any(ships_still_hidden))\n","name":"program_647","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the green boat horizontal","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Locate all tiles of the green ship (encoded as 2)\n    green_positions = np.argwhere(true_board == 2)\n    \n    # If there are fewer than 2 tiles, we can't infer orientation; return False by default\n    if green_positions.shape[0] < 2:\n        return False\n    \n    # Extract row and column indices\n    rows = green_positions[:, 0]\n    cols = green_positions[:, 1]\n    \n    # The ship is horizontal if all row indices are the same\n    return np.all(rows == rows[0])\n","name":"program_648","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any boats in columns 6 or 7","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Columns 6 and 7 correspond to indices 5 and 6 (0-based indexing)\n    cols = [5, 6]\n    \n    # We want to know if there is any unrevealed ship tile in those columns.\n    # An unrevealed tile in partial_board is marked as -1.\n    # Ship tiles in true_board are marked with values > 0.\n    unrevealed = (partial_board[:, cols] == -1)\n    ships_there = (true_board[:, cols] > 0)\n    \n    # If there exists any position that's both unrevealed and a ship, answer is True.\n    return bool(np.any(unrevealed & ships_there))\n","name":"program_649","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a boat in the bottom right corner","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is a ship tile in the bottom-right corner of the board,\n    i.e., at the last row and last column; otherwise returns False.\n    \"\"\"\n    # The bottom-right corner is at index [-1, -1]\n    return bool(true_board[-1, -1] > 0)\n","name":"program_650","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a boat in the top left corner","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # The \"top left corner\" is A1, which corresponds to index [0, 0].\n    # Return True if there's a ship there (any value > 0), False otherwise.\n    return true_board[0, 0] > 0\n","name":"program_651","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a third boat in the bottom left quadrant?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # assume true_board is square or rectangular\n    rows, cols = true_board.shape\n    mid_row = rows \/\/ 2\n    mid_col = cols \/\/ 2\n\n    # bottom\u2010left quadrant is rows [mid_row:rows], columns [0:mid_col]\n    bl_quad = true_board[mid_row:rows, 0:mid_col]\n\n    # collect unique non\u2010zero ship IDs in that quadrant\n    ships_in_bl = set(np.unique(bl_quad))\n    ships_in_bl.discard(0)  # remove water\n    # if there are 3 or more distinct ships, answer is yes\n    return len(ships_in_bl) >= 3\n","name":"program_652","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a boat in row h?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row H corresponds to index 7 (0-based: A=0, B=1, \u2026, H=7)\n    row_idx = 7\n    # A hidden ship tile is one where true_board > 0 but partial_board == -1\n    hidden_ship_tiles = (true_board[row_idx, :] > 0) & (partial_board[row_idx, :] == -1)\n    return bool(np.any(hidden_ship_tiles))\n","name":"program_653","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there another boat in row g","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the zero-based index for row 'G'\n    row_index = ord('G') - ord('A')\n    \n    # Extract the corresponding rows from the true and partial boards\n    true_row = true_board[row_index, :]\n    partial_row = partial_board[row_index, :]\n    \n    # A hidden ship tile is one where true_board > 0 (ship)\n    # and partial_board == -1 (still hidden)\n    hidden_ship_tiles = (true_row > 0) & (partial_row == -1)\n    \n    # If any such tile exists in row G, answer \"yes\"\n    return bool(np.any(hidden_ship_tiles))\n","name":"program_654","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a boat in the top right quadrant?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in the top-right quadrant (rows A\u2013D, columns 5\u20138), otherwise False.\n    \"\"\"\n    # Define the top-right quadrant: rows 0\u20133 (A\u2013D), columns 4\u20137 (5\u20138)\n    tr_true = true_board[0:4, 4:8]\n    tr_partial = partial_board[0:4, 4:8]\n    \n    # A ship tile is any non-zero in true_board; unrevealed means partial_board == -1\n    unseen_ship_mask = (tr_true != 0) & (tr_partial == -1)\n    return bool(np.any(unseen_ship_mask))\n","name":"program_655","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships in the top left quadrant","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Define the top-left quadrant (rows A\u2013D, columns 1\u20134)\n    # In zero\u2010based indexing this is rows 0\u20133 and columns 0\u20133.\n    tl_true = true_board[0:4, 0:4]\n    tl_partial = partial_board[0:4, 0:4]\n\n    # A ship tile is any positive value in true_board.\n    # We only care about those that remain hidden in partial_board (value == -1).\n    hidden_ship_tiles = (tl_true > 0) & (tl_partial == -1)\n\n    # If there's any such tile, answer \"Yes\"\n    return np.any(hidden_ship_tiles)\n","name":"program_656","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any ships in the top right quadrant?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one *unrevealed* ship tile\n    in the top-right quadrant (rows 0\u20133, cols 4\u20137) of the board.\n    \"\"\"\n    # Define the top-right quadrant\n    tr_true = true_board[0:4, 4:8]\n    tr_partial = partial_board[0:4, 4:8]\n    \n    # A ship tile is any true_board cell != 0\n    # An unrevealed cell is partial_board == -1\n    unrevealed_ship = (tr_true != 0) & (tr_partial == -1)\n    \n    # If any unrevealed ship tile exists, answer is Yes (True)\n    return bool(np.any(unrevealed_ship))\n","name":"program_657","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is g6 a hit?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # \"G6\" corresponds to row G (index 6) and column 6 (index 5)\n    row_idx = ord('G') - ord('A')  # G \u2192 6\n    col_idx = 6 - 1                # 6 \u2192 5\n    # It's a hit if there's a non-zero (ship) value at that location\n    return true_board[row_idx, col_idx] != 0\n","name":"program_658","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any ships in the bottom left quadrant?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in the bottom-left quadrant (rows E\u2013H, columns 1\u20134), else False.\n    \"\"\"\n    # slice out bottom-left quadrant: rows 4\u20137, cols 0\u20133\n    tb = true_board[4:8, 0:4]\n    pb = partial_board[4:8, 0:4]\n    # a ship tile is >0 in true_board; unrevealed means partial_board == -1\n    return np.any((tb > 0) & (pb == -1))\n","name":"program_659","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is h7 a hit?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert the coordinate H7 to zero\u2010based indices:\n    row = ord('H') - ord('A')  # 7\n    col = 7 - 1                # 6\n    # A \"hit\" means the true_board at that position is nonzero:\n    return true_board[row, col] != 0\n","name":"program_660","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any ships in the bottom right quadrant?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines if there are any *hidden* ship tiles in the bottom right quadrant\n    of the 8x8 board. The board is zero-indexed as follows:\n      - Rows 0\u20133 correspond to A\u2013D (top half), 4\u20137 correspond to E\u2013H (bottom half).\n      - Columns 0\u20133 correspond to 1\u20134 (left half), 4\u20137 correspond to 5\u20138 (right half).\n\n    We want the bottom right quadrant, i.e. rows 4:8 and columns 4:8.\n    A tile is a hidden ship tile if:\n      - true_board[r, c] > 0   (there is a ship in the true board)\n      - partial_board[r, c] == -1  (that tile has not yet been revealed)\n\n    Return True if any such tile exists, otherwise False.\n    \"\"\"\n    # Define the row and column slices for the bottom right quadrant\n    row_slice = slice(4, 8)   # rows E\u2013H\n    col_slice = slice(4, 8)   # cols 5\u20138\n\n    # Extract the corresponding subarrays\n    true_sub = true_board[row_slice, col_slice]\n    partial_sub = partial_board[row_slice, col_slice]\n\n    # A hidden ship tile is where true_sub > 0 AND partial_sub == -1\n    hidden_ships_mask = (true_sub > 0) & (partial_sub == -1)\n\n    # If any hidden ship tile exists, return True, else False\n    return bool(np.any(hidden_ships_mask))\n","name":"program_661","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are all the ships on the board to the left of column 5?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if every ship cell in true_board lies strictly to the left of column 5\n    (i.e. in columns 1\u20134), otherwise returns False.\n    \"\"\"\n    # Find all ship cells (values > 0) in the true board\n    ship_rows, ship_cols = np.nonzero(true_board > 0)\n    # Column indices in numpy are 0-based, so column 5 is index 4.\n    # We require all ship_cols < 4 (i.e. strictly to the left of column 5).\n    return np.all(ship_cols < 4)\n","name":"program_662","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the 5 square ship vertical?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify all ship labels (values > 0) and count their occurrences\n    labels, counts = np.unique(true_board[true_board > 0], return_counts=True)\n    # The 5\u2010square ship is the one with the maximum count (should be 5)\n    ship_id = labels[np.argmax(counts)]\n    # Find all coordinates of that ship\n    positions = np.argwhere(true_board == ship_id)\n    # positions is an array of [row, col] pairs. If all cols are the same, it's vertical.\n    cols = positions[:, 1]\n    return np.all(cols == cols[0])\n","name":"program_663","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the biggest ship in row a?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Extract only the ship cells (values > 0)\n    ship_cells = true_board[true_board > 0]\n    # Find each ship ID and its count (length)\n    ship_ids, counts = np.unique(ship_cells, return_counts=True)\n    # Determine the maximum length\n    max_len = counts.max()\n    # Find the ID(s) of the largest ship(s)\n    biggest_ids = ship_ids[counts == max_len]\n    \n    # Check each largest ship to see if it lies entirely in row A (row index 0)\n    for sid in biggest_ids:\n        # Get all coordinates (row, col) of this ship\n        coords = np.argwhere(true_board == sid)\n        # Extract the set of row\u2010indices occupied by this ship\n        rows_occupied = np.unique(coords[:, 0])\n        # If all of those rows == 0, the ship is entirely in row A\n        if rows_occupied.size == 1 and rows_occupied[0] == 0:\n            return True\n    \n    # If none of the largest ships is entirely in row A, answer No\n    return False\n","name":"program_664","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is a4 a hit?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # The Captain asked about A4, which is row 0, column 3 in zero\u2010based indexing.\n    # Return True if there's a ship there (value > 0), otherwise False.\n    return true_board[0, 3] > 0\n","name":"program_665","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is G4 a hit?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'G' to index 6 (0-based), column '4' to index 3 (0-based).\n    row_idx = ord('G') - ord('A')\n    col_idx = 4 - 1\n    # A hit means that the true board at G4 is non-zero (part of some ship).\n    return true_board[row_idx, col_idx] != 0\n","name":"program_666","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a horizontal ship in row d?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'D' \u2192 index 3\n    row_idx = ord('d') - ord('a')\n    ncols = true_board.shape[1]\n    \n    # Scan adjacent pairs in that row\n    for c in range(ncols - 1):\n        ship_id = true_board[row_idx, c]\n        # must be a ship and same ship in next column\n        if ship_id > 0 and true_board[row_idx, c+1] == ship_id:\n            # check if at least one of those two tiles is still hidden\n            if partial_board[row_idx, c] == -1 or partial_board[row_idx, c+1] == -1:\n                return True\n    return False\n","name":"program_667","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any ships in the top left quadrant","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in the top-left quadrant (rows 0\u20133, columns 0\u20133), otherwise False.\n    \"\"\"\n    # Extract the top-left 4x4 sub\u2010board\n    true_sub = true_board[0:4, 0:4]\n    partial_sub = partial_board[0:4, 0:4]\n    \n    # A ship tile is indicated by a value > 0 in true_board\n    # An unrevealed tile is indicated by -1 in partial_board\n    unrevealed_ships = (true_sub > 0) & (partial_sub == -1)\n    \n    # If any such tile exists, answer \"Yes\" (True), else \"No\" (False)\n    return bool(np.any(unrevealed_ships))\n","name":"program_668","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any ships in the top right quadrant?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the midpoint to split the board into quadrants\n    n_rows, n_cols = true_board.shape\n    mid_row = n_rows \/\/ 2\n    mid_col = n_cols \/\/ 2\n\n    # Extract the top\u2010right quadrant from both boards\n    true_top_right = true_board[:mid_row, mid_col:]\n    partial_top_right = partial_board[:mid_row, mid_col:]\n\n    # A ship tile is > 0, a hidden tile is == -1\n    ship_tiles = true_top_right > 0\n    hidden_tiles = partial_top_right == -1\n\n    # There are unrevealed ship tiles in the top\u2010right quadrant?\n    return bool(np.any(ship_tiles & hidden_tiles))\n","name":"program_669","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is g2 a hit?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # \"G2\" corresponds to row G (index 6) and column 2 (index 1)\n    row_idx = ord('G') - ord('A')\n    col_idx = 2 - 1\n    # It's a hit iff the true board at that location is a ship (> 0)\n    return true_board[row_idx, col_idx] > 0\n","name":"program_670","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any ships in the bottom left quadrant?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines if there are any unrevealed ship tiles in the bottom-left quadrant\n    of the board, given the full board (true_board) and the captain's current view\n    (partial_board). The board is assumed to be square (8x8), but this will\n    generalize to any even-dimensioned square board.\n    \"\"\"\n    # board dimensions\n    n_rows, n_cols = true_board.shape\n    # compute midpoints\n    mid_row = n_rows \/\/ 2\n    mid_col = n_cols \/\/ 2\n\n    # define bottom-left quadrant\n    true_quadrant   = true_board[mid_row:, :mid_col]\n    partial_quadrant = partial_board[mid_row:, :mid_col]\n\n    # we only care about tiles that are still hidden to the captain\n    hidden_mask = (partial_quadrant == -1)\n    # among those hidden, check if any are ship tiles (> 0)\n    has_ship = np.any((true_quadrant > 0) & hidden_mask)\n\n    return bool(has_ship)\n","name":"program_671","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is g1 a hit?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Captain asked: \"is g1 a hit?\"\n    # Convert 'G' to row index 6 and '1' to column index 0\n    row = ord('G') - ord('A')\n    col = 1 - 1\n    # A hit means the true_board at that position is a ship (1\u20134), not water (0)\n    return true_board[row, col] > 0\n","name":"program_672","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship in row b?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed ship tile in row B (index 1).\n    \"\"\"\n    # Row B corresponds to index 1 (A=0, B=1, \u2026)\n    row_idx = 1\n\n    # A ship tile is any true_board entry > 0\n    # A hidden tile in partial_board is marked as -1\n    ship_tiles = true_board[row_idx, :] > 0\n    hidden_tiles = partial_board[row_idx, :] == -1\n\n    # Check if there's any tile that is both a ship and still hidden\n    return bool(np.any(ship_tiles & hidden_tiles))\n","name":"program_673","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is c7 a hit?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # The question is asking whether C7 is a hit.\n    # Convert 'C' -> row index 2, '7' -> column index 6 (0-based).\n    row_idx = ord('C') - ord('A')\n    col_idx = 7 - 1\n    # A hit corresponds to a non\u2010zero ship value at that position.\n    return true_board[row_idx, col_idx] != 0\n","name":"program_674","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the green ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the green ship (denoted by 2) on the true board\n    green_positions = np.argwhere(true_board == 2)\n    \n    # If there's fewer than 2 tiles, it can't really be \"vertical\" in the usual sense,\n    # but we'll return False by default in that degenerate case.\n    if green_positions.shape[0] < 2:\n        return False\n    \n    # Check if all column indices are the same (vertical alignment)\n    cols = green_positions[:, 1]\n    return np.all(cols == cols[0])\n","name":"program_675","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is e3 a hit?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert row letter 'E' to 0-based index (A->0, B->1, \u2026)\n    row_idx = ord('e') - ord('a')\n    # Column 3 in 1-based numbering becomes index 2\n    col_idx = 3 - 1\n    # It's a hit if the true board at that position has a ship (>0)\n    return true_board[row_idx, col_idx] > 0\n","name":"program_676","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship in row f?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed ship tile in row F (index 5),\n    otherwise False.\n    \"\"\"\n    row_idx = 5  # Row F corresponds to index 5 (A=0, B=1, ..., F=5)\n    # A tile is an unrevealed ship tile if true_board > 0 (ship)\n    # and partial_board == -1 (still hidden).\n    unrevealed_ships = (true_board[row_idx, :] > 0) & (partial_board[row_idx, :] == -1)\n    return bool(np.any(unrevealed_ships))\n","name":"program_677","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship in row a?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row A corresponds to index 0\n    row_index = 0\n    \n    # We want to know if there is any ship tile in row A that has not yet been revealed.\n    # A ship tile in the true_board is indicated by a value > 0.\n    # An unrevealed tile in the partial_board is indicated by -1.\n    # So we look for any column in row A where true_board>0 AND partial_board==-1.\n    unrevealed_ship_tiles = (true_board[row_index, :] > 0) & (partial_board[row_index, :] == -1)\n    \n    return bool(np.any(unrevealed_ship_tiles))\n","name":"program_678","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the biggest ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the largest ship on the true_board is placed horizontally.\n    Returns True if horizontal, False if vertical.\n    \"\"\"\n    # Find all ship IDs (positive integers)\n    ship_ids = np.unique(true_board[true_board > 0])\n    \n    max_len = 0\n    is_horizontal = False\n    \n    for ship_id in ship_ids:\n        # Get the coordinates of all tiles belonging to this ship\n        coords = np.argwhere(true_board == ship_id)\n        length = coords.shape[0]\n        \n        # If this ship is larger than any seen so far, record its orientation\n        if length > max_len:\n            max_len = length\n            rows = coords[:, 0]\n            cols = coords[:, 1]\n            \n            # If all row indices are the same, it's horizontal\n            if np.all(rows == rows[0]):\n                is_horizontal = True\n            # If all column indices are the same, it's vertical\n            elif np.all(cols == cols[0]):\n                is_horizontal = False\n            else:\n                # In a valid Battleship setup this shouldn't happen,\n                # but default to False if the ship isn't strictly aligned.\n                is_horizontal = False\n    \n    return is_horizontal\n","name":"program_679","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the biggest ship in row g?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify all ship IDs (exclude 0 which represents water)\n    ship_ids, counts = np.unique(true_board, return_counts=True)\n    # Filter out water (0) and hidden (if any)\n    mask = ship_ids > 0\n    ship_ids = ship_ids[mask]\n    counts = counts[mask]\n    \n    # Determine which ship is the largest\n    largest_ship_id = ship_ids[np.argmax(counts)]\n    \n    # Find the row indices occupied by that ship\n    row_indices, _ = np.where(true_board == largest_ship_id)\n    \n    # Convert row letter 'G' to its 0-based index: A\u21920, B\u21921, \u2026, G\u21926\n    target_row = ord('G') - ord('A')\n    \n    # Return True if every piece of the largest ship lies in row G\n    return np.all(row_indices == target_row)\n","name":"program_680","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are any ships on the edges?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any ship tile on the outer edges of the board\n    that has not yet been revealed to the Captain.\n    \"\"\"\n    # Build a mask for the edge positions (top row, bottom row, left column, right column)\n    edge_mask = np.zeros_like(true_board, dtype=bool)\n    edge_mask[0, :] = True\n    edge_mask[-1, :] = True\n    edge_mask[:, 0] = True\n    edge_mask[:, -1] = True\n\n    # A ship tile is where true_board > 0. It's still hidden if partial_board == -1.\n    hidden_ship_on_edge = (true_board > 0) & (partial_board == -1) & edge_mask\n\n    # If any such tile exists, answer \"Yes\" (True), otherwise \"No\" (False).\n    return bool(np.any(hidden_ship_on_edge))\n","name":"program_681","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is purple to the left?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find any revealed purple tile (value == 3) on the partial board\n    hits = np.argwhere(partial_board == 3)\n    if hits.size == 0:\n        # No purple has been revealed yet, so we can't say it's to the left\n        return False\n\n    # We'll take the first revealed purple tile (there should typically only be one so far)\n    row, col = hits[0]\n\n    # Check the tile immediately to the left (if it exists)\n    if col - 1 < 0:\n        return False\n\n    # If the true board has a purple tile to the left, return True; otherwise False\n    return bool(true_board[row, col - 1] == 3)\n","name":"program_682","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the last ship in the bottom half?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the one ship that is not yet fully revealed\n    lies entirely in the bottom half of the board.\n    \"\"\"\n    # Dimensions\n    n_rows = true_board.shape[0]\n    half = n_rows \/\/ 2  # rows 0..half-1 = top half, half..n_rows-1 = bottom half\n\n    # All ship IDs are assumed to be positive integers in true_board (non\u2010zero).\n    ship_ids = set(np.unique(true_board)) - {0}\n\n    # Find the one ship that still has at least one hidden tile\n    remaining = []\n    for sid in ship_ids:\n        # mask of where that ship is on the true board\n        ship_mask = (true_board == sid)\n        # of those tiles, check if any are still hidden on the partial board\n        if np.any(np.logical_and(ship_mask, partial_board == -1)):\n            remaining.append(sid)\n\n    # If there's not exactly one \"last\" ship, we cannot answer uniquely\n    if len(remaining) != 1:\n        raise ValueError(\"Expected exactly one remaining ship, found %d\" % len(remaining))\n\n    last_id = remaining[0]\n\n    # Get the row-indices of all tiles of the last ship\n    rows, cols = np.where(true_board == last_id)\n\n    # Check if all those row-indices lie in the bottom half\n    # i.e. every row index >= half\n    return bool(np.all(rows >= half))\n","name":"program_683","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Have I hit anything?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A hit is a revealed tile (partial_board != -1) that corresponds to a ship on the true board (true_board > 0).\n    revealed = partial_board != -1\n    hits = np.logical_and(revealed, true_board > 0)\n    return bool(np.any(hits))\n","name":"program_684","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is ship at the edge?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A tile is unrevealed if partial_board == -1\n    unrevealed = (partial_board == -1)\n    # A tile is a ship if its value in true_board is 1,2,3 or 4\n    is_ship = (true_board > 0)\n    # Combine to find unrevealed ship tiles\n    unrevealed_ships = unrevealed & is_ship\n\n    # Build an \"edge\" mask: True on row 0, row -1, col 0, col -1\n    edge_mask = np.zeros_like(true_board, dtype=bool)\n    edge_mask[0, :] = True\n    edge_mask[-1, :] = True\n    edge_mask[:, 0] = True\n    edge_mask[:, -1] = True\n\n    # If any unrevealed ship lies on the edge, return True\n    return bool(np.any(unrevealed_ships & edge_mask))\n","name":"program_685","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there ships near the middle?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in the central region of the board, False otherwise.\n    We define the \"central region\" as the sub\u2010array of rows and columns\n    from index floor(n\/4) up to index n - floor(n\/4), which for an 8\u00d78\n    board corresponds to rows 2\u20135 and columns 2\u20135 (0\u2010based).\n    \"\"\"\n    # board dimensions\n    h, w = true_board.shape\n\n    # compute central region boundaries\n    row_start = h \/\/ 4\n    row_end   = h - (h \/\/ 4)\n    col_start = w \/\/ 4\n    col_end   = w - (w \/\/ 4)\n\n    # slice out the region\n    center_true    = true_board[row_start:row_end, col_start:col_end]\n    center_partial = partial_board[row_start:row_end, col_start:col_end]\n\n    # look for any ship part (>0) that is still hidden (-1 in partial)\n    has_unseen_ship = np.any((center_true > 0) & (center_partial == -1))\n    return bool(has_unseen_ship)\n","name":"program_686","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the 2 block ship still in the 8 column?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one tile of the 2\u2010block (green) ship\n    still hidden in column 8, otherwise False.\n    \"\"\"\n    # Python indices are 0-based, so column \u201c8\u201d is index 7\n    col_idx = 7\n\n    # A green\u2010ship tile is encoded as 2 in true_board.\n    # A hidden tile is encoded as -1 in partial_board.\n    hidden_green_in_col8 = (true_board[:, col_idx] == 2) & (partial_board[:, col_idx] == -1)\n\n    return bool(np.any(hidden_green_in_col8))\n","name":"program_687","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Should I move left to find the red ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all revealed red\u2010ship hits on the partial board\n    hit_rows, hit_cols = np.where(partial_board == 1)\n    \n    # For each hit, check if the tile directly to the left is a hidden red tile\n    for r, c in zip(hit_rows, hit_cols):\n        left_c = c - 1\n        if left_c >= 0:\n            # Only consider it if it is still hidden to the Captain\n            if partial_board[r, left_c] == -1:\n                # Check the true board to see if it's actually part of the red ship\n                if true_board[r, left_c] == 1:\n                    return True\n    # If no hidden red tile is found to the left of any revealed red hit, answer No\n    return False\n","name":"program_688","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the last ship close to red and orange?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A tile is unrevealed ship if it's a ship in true_board but hidden (-1) in partial_board\n    unrevealed_mask = (true_board != 0) & (partial_board == -1)\n    # Which ship types still have unrevealed tiles?\n    remaining_types = np.unique(true_board[unrevealed_mask])\n    # If there's not exactly one remaining ship type, we can't isolate \"the last ship\"\n    if remaining_types.size != 1:\n        return False\n    last_ship_type = remaining_types[0]\n\n    # Get coordinates of the last ship\u2019s unrevealed tiles\n    last_coords = np.argwhere(true_board == last_ship_type)\n\n    # Get coordinates of all revealed (and known) red (1) and orange (4) tiles\n    red_coords = np.argwhere(true_board == 1)\n    orange_coords = np.argwhere(true_board == 4)\n    ro_coords = np.vstack((red_coords, orange_coords))\n\n    # Compute Manhattan distances between every last-ship tile and every red\/orange tile\n    # and take the minimum distance\n    dists = np.abs(last_coords[:, None, :] - ro_coords[None, :, :]).sum(axis=2)\n    min_dist = dists.min()\n\n    # Define \"close\" as Manhattan distance of at most 2\n    return bool(min_dist <= 2)\n","name":"program_689","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is orange to the right?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # 1) Find all revealed orange hits on the partial board\n    orange_hits = np.argwhere(partial_board == 4)\n    \n    # 2) If we haven't hit any orange yet, we can't say it's to the right\n    if orange_hits.size == 0:\n        return False\n    \n    # 3) Pick the hit with the largest column index (rightmost hit)\n    #    orange_hits is a list of [row, col] pairs; we sort by col\n    rightmost_hit = orange_hits[np.argmax(orange_hits[:, 1])]\n    row, col = rightmost_hit\n    \n    # 4) Find any unrevealed orange tiles in the same row to the right\n    #    Unrevealed means partial_board == -1\n    #    Orange in true_board means true_board == 4\n    #    We scan columns strictly greater than 'col'\n    for c in range(col + 1, partial_board.shape[1]):\n        if true_board[row, c] == 4 and partial_board[row, c] == -1:\n            return True\n    \n    # 5) If none found, it's not to the right\n    return False\n","name":"program_690","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there any ships on column 8 down?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in column 8,\n    otherwise returns False.\n    \"\"\"\n    col_idx = 7  # zero-based index for column 8\n    # A tile is an unrevealed ship if partial_board is -1 (hidden)\n    # and true_board is > 0 (one of the ships).\n    hidden_tiles_in_col = (partial_board[:, col_idx] == -1)\n    ship_tiles_in_col   = (true_board[:, col_idx]   > 0)\n    return bool(np.any(hidden_tiles_in_col & ship_tiles_in_col))\n","name":"program_691","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Should i Start from the middle?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in the central 2x2 region of the board, False otherwise.\n    This tells the Captain whether starting from the middle\n    is likely to yield a hit.\n    \"\"\"\n    n = true_board.shape[0]\n    # for an even-sized board, the \"middle\" 2\u00d72 block is at indices n\/\/2-1 and n\/\/2\n    mid1 = n \/\/ 2 - 1\n    mid2 = n \/\/ 2\n    # slice out the 2\u00d72 central block\n    true_center = true_board[mid1:mid2+1, mid1:mid2+1]\n    partial_center = partial_board[mid1:mid2+1, mid1:mid2+1]\n    # check for any unrevealed ship cell in that block\n    return np.any((true_center > 0) & (partial_center == -1))\n","name":"program_692","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"At the bottom?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there are any unrevealed ship tiles in the bottom half\n    of the board (rows indexed >= n_rows\/\/2), otherwise False.\n    \"\"\"\n    n_rows = true_board.shape[0]\n    half   = n_rows \/\/ 2\n    # Slice out the bottom half of the board\n    tb_bot = true_board[half:, :]\n    pb_bot = partial_board[half:, :]\n    # A tile is an unrevealed ship tile if true_board > 0 and partial_board == -1\n    unseen_ship_tiles = (tb_bot > 0) & (pb_bot == -1)\n    return bool(np.any(unseen_ship_tiles))\n","name":"program_693","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is red close to green?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # locate all red and green cells\n    red_cells = np.argwhere(true_board == 1)\n    green_cells = np.argwhere(true_board == 2)\n\n    # if either ship isn't on the board at all, they can't be close\n    if red_cells.size == 0 or green_cells.size == 0:\n        return False\n\n    # compute Chebyshev distances between every red\/green pair\n    # red_cells[:, None, 0] is shape (R,1), green_cells[None,:,0] is (1,G)\n    row_diff = np.abs(red_cells[:, None, 0] - green_cells[None, :, 0])\n    col_diff = np.abs(red_cells[:, None, 1] - green_cells[None, :, 1])\n    cheb_dist = np.maximum(row_diff, col_diff)\n\n    # if any distance \u2264 1, they touch (are \"close\")\n    return bool(np.any(cheb_dist <= 1))\n","name":"program_694","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the green close to orange and purple?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of each color ship\n    green_coords  = np.argwhere(true_board == 2)\n    orange_coords = np.argwhere(true_board == 4)\n    purple_coords = np.argwhere(true_board == 3)\n    \n    # Helper: are any cells in coords1 \"adjacent\" (Moore neighborhood) to any in coords2?\n    def is_adjacent(coords1, coords2):\n        for r1, c1 in coords1:\n            for r2, c2 in coords2:\n                # Chebyshev distance <= 1 => adjacent including diagonals\n                if max(abs(r1 - r2), abs(c1 - c2)) <= 1:\n                    return True\n        return False\n    \n    # Check if green is adjacent to both orange and purple\n    close_to_orange = is_adjacent(green_coords, orange_coords)\n    close_to_purple = is_adjacent(green_coords, purple_coords)\n    return close_to_orange and close_to_purple\n","name":"program_695","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships near the middle?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # assume square board\n    n = true_board.shape[0]\n    # define central region as rows\/cols n\/\/4 through n - n\/\/4 - 1\n    start = n\/\/4\n    end   = n - n\/\/4\n    # slice out the central block\n    central_true    = true_board[start:end, start:end]\n    central_partial = partial_board[start:end, start:end]\n    # a ship is represented by >0 in true_board; hidden tiles are -1 in partial_board\n    hidden_ships = (central_true > 0) & (central_partial == -1)\n    return bool(np.any(hidden_ships))\n","name":"program_696","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are any ships at the top?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Check the top row (row A, index 0) for any ship tiles (values > 0)\n    # that remain hidden (partial_board == -1).\n    top_unrevealed_ships = (true_board[0] > 0) & (partial_board[0] == -1)\n    return bool(np.any(top_unrevealed_ships))\n","name":"program_697","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships in column D across?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We interpret \"column D across\" to mean row D (since rows are lettered A\u2013H).\n    # Compute the index for row 'D' (0-based: A\u21920, B\u21921, C\u21922, D\u21923).\n    row_idx = ord('D') - ord('A')\n    \n    # Extract that row from both boards\n    true_row = true_board[row_idx, :]\n    partial_row = partial_board[row_idx, :]\n    \n    # A ship is present and still hidden if true_board cell > 0 and partial_board cell == -1\n    hidden_ship_cells = (true_row > 0) & (partial_row == -1)\n    \n    # If there is at least one hidden ship cell in row D, answer \"Yes\"; otherwise \"No\"\n    return bool(np.any(hidden_ship_cells))\n","name":"program_698","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there any ships in column B across?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map the letter 'B' to a 0-based column index (A\u21920, B\u21921, \u2026)\n    col_idx = ord('B') - ord('A')\n    \n    # A ship tile in true_board is any value > 0.\n    # A tile is still hidden to the Captain if partial_board == -1.\n    # We check if there is any position in column B where both conditions hold.\n    ships_in_B_still_hidden = (true_board[:, col_idx] > 0) & (partial_board[:, col_idx] == -1)\n    \n    return bool(np.any(ships_in_B_still_hidden))\n","name":"program_699","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there any on the bottom (H) ?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We map rows A\u2013H to indices 0\u20137, so row H corresponds to index 7.\n    row_H_index = 7\n    \n    # A ship tile in the true board is > 0.\n    # A hidden tile in the partial board is represented by -1.\n    # We want to know if there's any ship tile in row H that remains hidden.\n    hidden_ship_tiles_in_H = (true_board[row_H_index] > 0) & (partial_board[row_H_index] == -1)\n    \n    return bool(np.any(hidden_ship_tiles_in_H))\n","name":"program_700","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Should I keep moving vertically to get red?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed red\u2010ship tile (value 1)\n    immediately above or below any revealed red hit on the partial_board.\n    Otherwise returns False.\n    \"\"\"\n    # Find all coordinates of revealed red hits on the partial board\n    red_hits = np.argwhere(partial_board == 1)\n    \n    # For each red hit, check the cell above and below\n    for i, j in red_hits:\n        for di in (-1, 1):\n            ni = i + di\n            # Check bounds\n            if 0 <= ni < true_board.shape[0]:\n                # If the true board has a red tile here and it's still hidden in partial_board\n                if true_board[ni, j] == 1 and partial_board[ni, j] == -1:\n                    return True\n    return False\n","name":"program_701","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the orange ship vertical","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the orange ship (labeled 4)\n    positions = np.argwhere(true_board == 4)\n    # Separate into row and column indices\n    rows, cols = positions[:, 0], positions[:, 1]\n    # The ship is vertical if all columns are the same and there is more than one row\n    return len(set(cols)) == 1 and len(set(rows)) > 1\n","name":"program_702","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the red ship vertical","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the red ship (value 1)\n    red_rows, red_cols = np.where(true_board == 1)\n    # The ship is vertical if it occupies more than one row but exactly one column\n    return (np.unique(red_rows).size > 1) and (np.unique(red_cols).size == 1)\n","name":"program_703","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are any touching the corners?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one still\u2010hidden ship tile\n    in any of the four corner positions of the board.\n    Corner indices: (0,0), (0, width-1), (height-1, 0), (height-1, width-1).\n    \"\"\"\n    h, w = true_board.shape\n    corners = [(0, 0), (0, w-1), (h-1, 0), (h-1, w-1)]\n    for r, c in corners:\n        # partial_board == -1 means hidden; true_board > 0 means ship\n        if partial_board[r, c] == -1 and true_board[r, c] > 0:\n            return True\n    return False\n","name":"program_704","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the orange ship horizontal","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the orange ship (value 4) on the true board\n    positions = np.argwhere(true_board == 4)\n    # Extract the row indices\n    rows = positions[:, 0]\n    # If all row indices are the same, the ship is horizontal\n    return np.all(rows == rows[0])\n","name":"program_705","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are there some on the right side?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the halfway point of the columns (right side = columns >= half)\n    n_cols = partial_board.shape[1]\n    half = n_cols \/\/ 2\n\n    # Build a mask for columns on the right half\n    right_cols = np.arange(n_cols) >= half\n    right_mask = np.broadcast_to(right_cols, partial_board.shape)\n\n    # Mask for tiles that are ships in the true board but still hidden in the partial board\n    hidden_ship_mask = (true_board != 0) & (partial_board == -1)\n\n    # Check if any such tile lies on the right side\n    return bool(np.any(hidden_ship_mask & right_mask))\n","name":"program_706","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the purple ship vertical","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the purple ship (encoded as 3)\n    coords = np.argwhere(true_board == 3)\n    # If there are fewer than 2 tiles, orientation is undefined (treat as not vertical)\n    if coords.shape[0] < 2:\n        return False\n    # Split into row indices and column indices\n    rows, cols = coords[:, 0], coords[:, 1]\n    # The ship is vertical if all columns are the same and there is more than one distinct row\n    return (len(np.unique(cols)) == 1) and (len(np.unique(rows)) > 1)\n","name":"program_707","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there ships in row h","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the 0\u2010based index for row 'H'\n    row_index = ord('H') - ord('A')  # 'A'\u21920, 'B'\u21921, \u2026, 'H'\u21927\n\n    # A ship tile is any value > 0 in true_board\n    # An unrevealed tile is -1 in partial_board\n    # We want to know if there are any ship tiles in row H\n    # that remain hidden to the Captain\n    mask_unrevealed_ship = (true_board[row_index] > 0) & (partial_board[row_index] == -1)\n\n    return bool(np.any(mask_unrevealed_ship))\n","name":"program_708","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any ships in the left upper quadrant?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there are any unrevealed ship tiles in the upper-left quadrant\n    of the board, otherwise False.\n    \"\"\"\n    # Determine the midpoint to split into quadrants\n    mid_row = true_board.shape[0] \/\/ 2\n    mid_col = true_board.shape[1] \/\/ 2\n\n    # Extract the upper-left quadrant\n    ul_true = true_board[:mid_row, :mid_col]\n    ul_partial = partial_board[:mid_row, :mid_col]\n\n    # A ship tile is indicated by >0 in true_board,\n    # and an unrevealed tile is indicated by -1 in partial_board.\n    # If there is any position satisfying both, return True.\n    return bool(np.any((ul_true > 0) & (ul_partial == -1)))\n","name":"program_709","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the orange ship vertical","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # find all (row, col) indices where the orange ship (4) is located\n    positions = np.argwhere(true_board == 4)\n    # if we didn't find any orange tiles, we cannot say it's vertical\n    if positions.size == 0:\n        return False\n    # extract just the column indices\n    cols = positions[:, 1]\n    # if there's exactly one unique column among them, it's vertical\n    return np.unique(cols).size == 1\n","name":"program_710","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are any ships touching the purple ship","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if any other ship (i.e., any non-zero, non-purple tile) \n    is adjacent (including diagonals) to any purple-ship tile.\n    \"\"\"\n    # Identify all the coordinates of the purple ship (value == 3)\n    purple_coords = np.argwhere(true_board == 3)\n    # Define the eight possible neighbor offsets\n    neighbors = [(-1, -1), (-1, 0), (-1, 1),\n                 ( 0, -1),          ( 0, 1),\n                 ( 1, -1), ( 1, 0), ( 1, 1)]\n    rows, cols = true_board.shape\n\n    for (r, c) in purple_coords:\n        for dr, dc in neighbors:\n            nr, nc = r + dr, c + dc\n            # Check bounds\n            if 0 <= nr < rows and 0 <= nc < cols:\n                val = true_board[nr, nc]\n                # If it's not water (0) and not purple (3), it's another ship\n                if val != 0 and val != 3:\n                    return True\n    return False\n","name":"program_711","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are any tiles touching the bottom right edges","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there are any *unrevealed* ship tiles touching\n    the bottom edge or the right edge of the board.\n    \"\"\"\n    # Identify ship tiles on the bottom row that are still hidden\n    bottom_row_hidden_ship = (true_board[-1, :] > 0) & (partial_board[-1, :] == -1)\n    # Identify ship tiles on the rightmost column that are still hidden\n    right_col_hidden_ship = (true_board[:, -1] > 0) & (partial_board[:, -1] == -1)\n    \n    # If any such tile exists on either edge, answer is True\n    return bool(np.any(bottom_row_hidden_ship) or np.any(right_col_hidden_ship))\n","name":"program_712","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"any ships touching column 5","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Column 5 corresponds to index 4 (0-based indexing)\n    col_idx = 4\n    \n    # A ship tile is any true_board entry > 0. A hidden tile in partial_board is -1.\n    # We want to know if there is any tile in column 5 that is a ship in true_board\n    # but still hidden in partial_board.\n    hidden_ship_in_col = (true_board[:, col_idx] > 0) & (partial_board[:, col_idx] == -1)\n    \n    return bool(hidden_ship_in_col.any())\n","name":"program_713","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"any ships touching row G","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one *unrevealed* ship tile in row G itself\n    or in the rows immediately above or below it (F, G or H). Otherwise returns False.\n    \"\"\"\n    # Row G is the 7th row of an 8\u00d78 board (0-based index 6).\n    row_g_index = 6\n\n    # Create a mask of rows that are row G or adjacent (F or H).\n    # rows will be a column vector [[0], [1], ..., [7]]\n    rows = np.arange(true_board.shape[0])[:, None]\n    adjacent_to_g = np.abs(rows - row_g_index) <= 1\n\n    # Mask of where there's a ship in the true board (>0) and still hidden in partial_board (-1).\n    ship_tiles = true_board > 0\n    hidden_tiles = partial_board == -1\n\n    # Combine masks: same shape as board. Then check if any such tile exists.\n    relevant_tiles = adjacent_to_g & ship_tiles & hidden_tiles\n    return bool(np.any(relevant_tiles))\n","name":"program_714","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"any ships touching column 8","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one ship tile in column 8 (index 7)\n    that has not yet been revealed on the partial_board.\n    Otherwise, returns False.\n    \"\"\"\n    # Column 8 corresponds to index 7\n    col_idx = 7\n    \n    # Identify ship tiles in the true board\n    is_ship = true_board[:, col_idx] > 0\n    \n    # Identify which of those tiles remain hidden to the captain\n    is_hidden = partial_board[:, col_idx] == -1\n    \n    # If any tile is both a ship and hidden, answer is Yes\n    return bool(np.any(is_ship & is_hidden))\n","name":"program_715","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"any ships touching row D","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We interpret \"touching row D\" as occupying row D.\n    # Compute the row index for 'D'\n    row_idx = ord('D') - ord('A')\n    # A ship tile is represented by a value > 0 in true_board,\n    # and unrevealed tiles are == -1 in partial_board.\n    unrevealed_ship_tiles = (true_board[row_idx] > 0) & (partial_board[row_idx] == -1)\n    # If any such tile exists, answer \"Yes\" (True), otherwise \"No\" (False).\n    return bool(np.any(unrevealed_ship_tiles))\n","name":"program_716","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any tiles in the center area","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines whether there are any unrevealed ship tiles in the \"center area\"\n    of an 8x8 Battleship grid. Here we define the center area to be rows C\u2013F\n    (indices 2\u20135) and columns 3\u20136 (indices 2\u20135), inclusive.\n\n    Args:\n        true_board (np.ndarray): The full 8x8 board with values:\n                                 0 = water, 1\u20134 = ship IDs.\n        partial_board (np.ndarray): The current 8x8 board state visible to\n                                    the Captain, with hidden tiles marked -1.\n\n    Returns:\n        bool: True if there is at least one ship tile in the center region\n              that remains hidden, False otherwise.\n    \"\"\"\n    # Define row indices 2,3,4,5 (C, D, E, F) and column indices 2,3,4,5 (3,4,5,6)\n    r_start, r_end = 2, 6\n    c_start, c_end = 2, 6\n\n    # Extract the center subarrays from both boards\n    true_center = true_board[r_start:r_end, c_start:c_end]\n    partial_center = partial_board[r_start:r_end, c_start:c_end]\n\n    # A ship tile is any value > 0 in true_board.\n    # A hidden tile is marked -1 in partial_board.\n    # We check if there exists any position in the center where\n    # true_board > 0 AND partial_board == -1.\n    hidden_ship_mask = (true_center > 0) & (partial_center == -1)\n    \n    return bool(np.any(hidden_ship_mask))\n","name":"program_717","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"any tiles touches the left edge","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Check the leftmost column (index 0) for any hidden ship tiles\n    left_true = true_board[:, 0]\n    left_partial = partial_board[:, 0]\n    # A hidden ship tile is one where partial_board == -1 and true_board > 0\n    hidden_ship_on_left = (left_partial == -1) & (left_true > 0)\n    return bool(np.any(hidden_ship_on_left))\n","name":"program_718","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is ship on the left side","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in the left half of the board (columns 1 through 4), otherwise False.\n    \"\"\"\n    # determine the midpoint for column splitting (left vs. right)\n    n_cols = true_board.shape[1]\n    midpoint = n_cols \/\/ 2  # for an 8\u00d78 board this is 4\n\n    # slice out the left half of both boards\n    true_left  = true_board[:, :midpoint]\n    part_left  = partial_board[:, :midpoint]\n\n    # an unrevealed ship tile is one where:\n    #  - true_board > 0  (a ship)\n    #  - partial_board == -1  (still hidden)\n    mask_unrevealed_ships = (true_left > 0) & (part_left == -1)\n\n    # if any such tile exists, answer is Yes (True)\n    return bool(np.any(mask_unrevealed_ships))\n","name":"program_719","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any tiles touching the blue tiles already selected?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if any revealed water tile (0) on the partial_board\n    touches (in any of the eight directions) at least one hidden tile (-1).\n    Otherwise returns False.\n    \"\"\"\n    nrows, ncols = partial_board.shape\n    # find all coordinates of revealed water tiles\n    water_positions = np.argwhere(partial_board == 0)\n    \n    # for each water tile, check its neighbors\n    for r, c in water_positions:\n        for dr in (-1, 0, 1):\n            for dc in (-1, 0, 1):\n                if dr == 0 and dc == 0:\n                    continue\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < nrows and 0 <= nc < ncols:\n                    if partial_board[nr, nc] == -1:\n                        return True\n    return False\n","name":"program_720","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there any tiles in the top right corner","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one ship tile in the 'top right corner'\u2014\n    defined here as the 2\u00d72 block in rows A\u2013B and columns 7\u20138\u2014\n    otherwise returns False.\n    \"\"\"\n    # Rows A, B are indices 0 and 1; columns 7, 8 are indices 6 and 7.\n    top_right = true_board[0:2, 6:8]\n    return np.any(top_right > 0)\n","name":"program_721","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"am i close?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # find all revealed ship\u2010tiles\n    ship_hits = np.argwhere(partial_board > 0)\n    # directions: up, down, left, right\n    directions = [(-1,0),(1,0),(0,-1),(0,1)]\n    rows, cols = partial_board.shape\n    \n    for i, j in ship_hits:\n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < rows and 0 <= nj < cols:\n                # if that neighbor is hidden in partial_board\n                # but actually a ship in true_board, then you're close\n                if partial_board[ni, nj] == -1 and true_board[ni, nj] > 0:\n                    return True\n    return False\n","name":"program_722","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"should I go left?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # find all revealed ship cells in the partial board\n    # (any cell > 0 is a revealed ship cell)\n    hits = np.argwhere(partial_board > 0)\n    for r, c in hits:\n        # check one column to the left\n        if c - 1 >= 0:\n            # only consider it if it is still hidden in the partial\n            if partial_board[r, c - 1] == -1:\n                # if that hidden cell really is a ship in the true board, \n                # then going left will hit something\n                if true_board[r, c - 1] > 0:\n                    return True\n    return False\n","name":"program_723","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"down is yes, no is up, next move?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all revealed ship\u2010hits (cells where partial_board>0\n    # and agrees with true_board)\n    hits = np.argwhere((partial_board > 0) & (partial_board == true_board))\n    if hits.size == 0:\n        # No hits at all \u2013 default to \u201cno\u201d\n        return False\n\n    # Pick the hit with the largest row index (bottommost hit)\n    # This heuristically corresponds to the most recent focus\n    i, j = hits[np.argmax(hits[:, 0])]\n\n    # Lookup ship id at (i,j)\n    ship_id = true_board[i, j]\n    nrows, ncols = true_board.shape\n\n    # Compute \u201cdown\u201d coordinate\n    down_i = i + 1\n    # If down is on board and matches the same ship, answer Yes\n    if down_i < nrows and true_board[down_i, j] == ship_id:\n        return True\n    else:\n        # Otherwise go up (or off\u2013board) \u21d2 answer No\n        return False\n","name":"program_724","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"keep going same direction?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all currently revealed ship\u2010hits\n    hits = np.argwhere(partial_board > 0)\n    # If fewer than 2 hits, we cannot infer a direction \u2192 answer \u201cNo\u201d\n    if hits.shape[0] < 2:\n        return False\n\n    # Check if the hits line up horizontally or vertically\n    if np.all(hits[:, 0] == hits[0, 0]):\n        # all on same row \u2192 horizontal\n        axis = 1\n    elif np.all(hits[:, 1] == hits[0, 1]):\n        # all on same column \u2192 vertical\n        axis = 0\n    else:\n        # If not perfectly aligned, try to find any adjacent pair\n        pair = None\n        for i in range(len(hits)):\n            for j in range(i + 1, len(hits)):\n                if abs(hits[i, 0] - hits[j, 0]) + abs(hits[i, 1] - hits[j, 1]) == 1:\n                    pair = (hits[i], hits[j])\n                    break\n            if pair is not None:\n                break\n        if pair is None:\n            return False\n        # Work with just that adjacent pair\n        hits = np.array(pair)\n        axis = 0 if hits[0, 1] == hits[1, 1] else 1\n\n    # Sort the hits along the inferred axis and pick the two ends\n    hits = hits[np.argsort(hits[:, axis])]\n    endpoint1, endpoint2 = hits[0], hits[-1]\n\n    # Determine the ship type from one of the endpoints\n    ship_id = true_board[endpoint1[0], endpoint1[1]]\n\n    # Compute the unit step from endpoint1 \u2192 endpoint2\n    delta = endpoint2 - endpoint1\n    delta = delta \/\/ np.max(np.abs(delta))\n\n    # The \"same direction\" move is just one more step past endpoint2\n    next_r, next_c = endpoint2 + delta\n\n    # If that next cell is on-board, still hidden, and truly part of the same ship \u2192 Yes\n    if (0 <= next_r < partial_board.shape[0] and\n        0 <= next_c < partial_board.shape[1] and\n        partial_board[next_r, next_c] == -1 and\n        true_board[next_r, next_c] == ship_id):\n        return True\n\n    # Otherwise \u2192 No\n    return False\n","name":"program_725","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"up = yes ans down = no, whats the best move?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the best next probe is 'up' (north),\n    False if it is 'down' (south).\n    \"\"\"\n    rows, cols = partial_board.shape\n\n    # Scan for any revealed ship tile\n    for i in range(rows):\n        for j in range(cols):\n            val = partial_board[i, j]\n            if val > 0:\n                up_match = False\n                down_match = False\n\n                # Check north\n                if i - 1 >= 0 and partial_board[i-1, j] == -1 and true_board[i-1, j] == val:\n                    up_match = True\n\n                # Check south\n                if i + 1 < rows and partial_board[i+1, j] == -1 and true_board[i+1, j] == val:\n                    down_match = True\n\n                # If only one direction has a matching hidden tile, choose it\n                if up_match and not down_match:\n                    return True\n                if down_match and not up_match:\n                    return False\n                # If both match (or neither), default to up\n                if up_match and down_match:\n                    return True\n\n    # If we found no single\u2010hit or no clear direction, default to up\n    return True\n","name":"program_726","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"row 6 is yes, row 8 is no, next best move?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    The Captain is asking to choose between row 6 (index 5) on a 'yes' response\n    and row 8 (index 7) on a 'no' response. We pick the row with the greater\n    number of still\u2010hidden ship segments. If row 6 has at least as many hidden\n    ship tiles as row 8, return True (yes); otherwise return False (no).\n    \"\"\"\n    # A mask of where there is a ship on the true board AND that tile is still hidden\n    hidden_ship_mask = (true_board > 0) & (partial_board == -1)\n\n    # Count hidden ship tiles in row 6 (index 5) and row 8 (index 7)\n    count_row6 = np.count_nonzero(hidden_ship_mask[5])\n    count_row8 = np.count_nonzero(hidden_ship_mask[7])\n\n    # Return True if row 6 is at least as promising as row 8, else False\n    return count_row6 >= count_row8\n","name":"program_727","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"yes or no?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is at least one ship tile on the true_board\n    that remains hidden on the partial_board; otherwise False.\n    \"\"\"\n    # A ship tile is any cell > 0 in true_board.\n    ship_mask = true_board > 0\n    # A hidden cell is marked -1 in partial_board.\n    hidden_mask = partial_board == -1\n    # If any hidden cell corresponds to a ship, answer \"Yes\" (True).\n    return bool(np.any(ship_mask & hidden_mask))\n","name":"program_728","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"again?","solution":"\nimport numpy as np\nfrom collections import deque\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # find all revealed ship\u2010hits (>0) in the partial board\n    hits = np.argwhere(partial_board > 0)\n    if hits.size == 0:\n        # no hits at all \u2192 nothing to continue\n        return False\n\n    # build connected clusters of hits (4\u2010way adjacency)\n    visited = set()\n    clusters = []\n    for r, c in map(tuple, hits):\n        if (r, c) in visited:\n            continue\n        val = partial_board[r, c]\n        queue = deque([(r, c)])\n        visited.add((r, c))\n        cluster = [(r, c)]\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in ((1,0),(-1,0),(0,1),(0,-1)):\n                nx, ny = x+dx, y+dy\n                if (0 <= nx < partial_board.shape[0] and\n                    0 <= ny < partial_board.shape[1] and\n                    (nx, ny) not in visited and\n                    partial_board[nx, ny] == val):\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n                    cluster.append((nx, ny))\n        clusters.append(cluster)\n\n    # pick the largest cluster (we assume that's the current target)\n    cluster = max(clusters, key=len)\n    rows = [r for r, c in cluster]\n    cols = [c for r, c in cluster]\n\n    # if vertical (same column), look \"up\" off the top end\n    if len(set(cols)) == 1:\n        col = cols[0]\n        top_row = min(rows)\n        nr = top_row - 1\n        if nr >= 0:\n            return (partial_board[nr, col] == -1 and true_board[nr, col] > 0)\n        else:\n            return False\n\n    # if horizontal (same row), look \"left\" off the left end\n    if len(set(rows)) == 1:\n        row = rows[0]\n        left_col = min(cols)\n        nc = left_col - 1\n        if nc >= 0:\n            return (partial_board[row, nc] == -1 and true_board[row, nc] > 0)\n        else:\n            return False\n\n    # if it's just a single hit (no orientation yet), we can't \"go again\"\n    return False\n","name":"program_729","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are all remaining ships horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if all ships that still have unrevealed tiles are oriented horizontally,\n    False otherwise.\n    \"\"\"\n    # Ship IDs on the board\n    ship_ids = [1, 2, 3, 4]\n    \n    for ship_id in ship_ids:\n        # Mask of all tiles belonging to this ship\n        ship_mask = (true_board == ship_id)\n        # Mask of that ship's tiles which are still unrevealed\n        unrevealed_mask = ship_mask & (partial_board == -1)\n        \n        # If this ship has any unrevealed tiles, check its orientation\n        if np.any(unrevealed_mask):\n            # Get the full set of coordinates for this ship\n            coords = np.argwhere(ship_mask)\n            rows, cols = coords[:, 0], coords[:, 1]\n            \n            # If not all in the same row, it's vertical (or not purely horizontal)\n            if not np.all(rows == rows[0]):\n                return False\n    \n    # If we never found a non-horizontal ship among the unrevealed ones\n    return True\n","name":"program_730","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"the letter a - d is yes, e-h is no, what's the best area to hit?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there are more unrevealed ship tiles in rows A-D (indices 0-3)\n    than in rows E-H (indices 4-7), otherwise False.\n    \"\"\"\n    # A tile is an unrevealed ship if partial_board == -1 and true_board > 0\n    hidden_ships = (partial_board == -1) & (true_board > 0)\n\n    # Count hidden ship tiles in rows A-D vs E-H\n    count_AD = hidden_ships[:4, :].sum()\n    count_EH = hidden_ships[4:, :].sum()\n\n    # If more hidden in A-D, answer \"yes\" (True), else \"no\" (False).\n    return count_AD > count_EH\n","name":"program_731","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"yes = left side , no = right side, whats next best move?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there are more unrevealed ship segments on the left half\n    (columns 0\u20133) than on the right half (columns 4\u20137), otherwise False.\n    \"\"\"\n    # Identify unrevealed ship tiles\n    hidden_ship_tiles = (partial_board == -1) & (true_board != 0)\n\n    # Split the board in half by columns\n    n_cols = partial_board.shape[1]\n    mid = n_cols \/\/ 2  # 8\/\/2 == 4\n\n    left_count = hidden_ship_tiles[:, :mid].sum()\n    right_count = hidden_ship_tiles[:, mid:].sum()\n\n    # yes = left side, no = right side\n    return bool(left_count > right_count)\n","name":"program_732","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Click left?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Decide whether the next click is more likely to hit a ship on the left half\n    of the board (columns 1..n\/2) versus the right half (columns n\/2+1..n).\n    We compare the *density* of still\u2010hidden ship cells in each half.\n    \"\"\"\n    n_cols = partial_board.shape[1]\n    half = n_cols \/\/ 2\n\n    # Mask of hidden cells in each half\n    left_hidden  = (partial_board[:, :half] == -1)\n    right_hidden = (partial_board[:, half:] == -1)\n\n    # Among those hidden cells, which are actually ships?\n    left_ship_hidden  = (true_board[:, :half] > 0) & left_hidden\n    right_ship_hidden = (true_board[:, half:] > 0) & right_hidden\n\n    # Totals\n    hidden_left  = int(left_hidden.sum())\n    hidden_right = int(right_hidden.sum())\n    ships_left   = int(left_ship_hidden.sum())\n    ships_right  = int(right_ship_hidden.sum())\n\n    # If one side has no hidden squares, prefer the other side if it has ships\n    if hidden_left == 0 and hidden_right == 0:\n        # nothing left anywhere\n        return False\n    if hidden_left == 0:\n        return ships_right > 0\n    if hidden_right == 0:\n        return ships_left > 0\n\n    # Compare densities: ships_left\/hidden_left vs ships_right\/hidden_right\n    # To avoid floating point, compare cross\u2010product\n    return (ships_left * hidden_right) > (ships_right * hidden_left)\n","name":"program_733","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the red ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates where the true board has a red ship (value == 1)\n    coords = np.argwhere(true_board == 1)\n    # If all those coordinates share the same column index, it's vertical\n    # (i.e. no column variation)\n    cols = coords[:, 1]\n    return bool(np.all(cols == cols[0]))\n","name":"program_734","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"left side of board?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is at least one unrevealed ship tile\n    on the left half of the board (columns 1 through N\/2), else False.\n    \"\"\"\n    # Identify hidden cells in the partial board\n    hidden = (partial_board == -1)\n    # Identify actual ship cells on the true board\n    ship_cells = (true_board > 0)\n    # Combine to find unrevealed ship cells\n    unrevealed_ships = hidden & ship_cells\n    \n    # Determine the midpoint column index for the left half\n    n_cols = true_board.shape[1]\n    mid = n_cols \/\/ 2\n    \n    # Check if any unrevealed ship lies in the left half (columns 0 through mid-1)\n    return np.any(unrevealed_ships[:, :mid])\n","name":"program_735","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"should I keep clicking right for red?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether clicking to the right of any currently revealed red hit\n    will uncover another red ship segment.\n    \"\"\"\n    # Find all revealed red hits in the partial board\n    red_hits = np.argwhere(partial_board == 1)\n    \n    # For each revealed red hit, check the tile immediately to its right\n    n_cols = true_board.shape[1]\n    for row, col in red_hits:\n        right_col = col + 1\n        if right_col < n_cols:\n            # If that tile is hidden in partial_board and is red in true_board,\n            # then clicking right will find another red segment\n            if partial_board[row, right_col] == -1 and true_board[row, right_col] == 1:\n                return True\n    \n    # No adjacent hidden red segment to the right of any revealed hit\n    return False\n","name":"program_736","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is green horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the green ship (value 2) on the true board\n    coords = np.argwhere(true_board == 2)\n    if coords.size == 0:\n        # No green ship found (shouldn't happen in a valid game), default to False\n        return False\n\n    # coords is an array of shape (n_tiles, 2), where each row is [row_index, col_index].\n    # If all row indices are the same, the ship is horizontal.\n    row_indices = coords[:, 0]\n    return np.all(row_indices == row_indices[0])\n","name":"program_737","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Click up?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the next click for the ship currently being hunted\n    should be 'up' from its known hits.\n\n    We identify the ship type that still has hidden segments by looking\n    for a ship ID t where (true_board == t) and (partial_board == -1).\n    Then we compare the row indices of its hidden vs. revealed segments:\n    if all hidden\u2010segment rows are strictly less (i.e. 'above') all\n    revealed\u2010segment rows, we answer True (click up); otherwise False.\n    \"\"\"\n    # consider ship IDs from 1 to 4\n    for t in range(1, 5):\n        # mask of true positions of ship t that are still hidden\n        hidden_mask = (true_board == t) & (partial_board == -1)\n        if not np.any(hidden_mask):\n            continue  # no hidden parts of this ship\n\n        # mask of true positions of ship t that have been revealed\n        revealed_mask = (true_board == t) & (partial_board == t)\n        if not np.any(revealed_mask):\n            continue  # haven't found any part of this ship yet\n\n        # get coordinates\n        hidden_coords = np.argwhere(hidden_mask)\n        revealed_coords = np.argwhere(revealed_mask)\n\n        # check if every hidden segment is above every revealed segment\n        # (row index smaller means 'up')\n        for h in hidden_coords:\n            for r in revealed_coords:\n                if not (h[0] < r[0]):\n                    return False\n        return True\n\n    # if no ship with hidden parts is found, default to False\n    return False\n","name":"program_738","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is yellow horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine if the 'yellow' ship is placed horizontally on the board.\n    Here we assume that 'yellow' corresponds to the value 4 in true_board\n    (same as the 'orange' ship in the provided encoding).\n    \"\"\"\n    # Find all coordinates of the ship with value 4\n    coords = np.argwhere(true_board == 4)\n    \n    # If fewer than 2 tiles, cannot form a ship \u2192 not horizontal\n    if coords.shape[0] < 2:\n        return False\n    \n    # Separate into row indices and column indices\n    rows = coords[:, 0]\n    cols = coords[:, 1]\n    \n    # Ship is horizontal if all row indices are identical\n    return np.all(rows == rows[0])\n","name":"program_739","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Up for yellow?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine which ship(s) have been partially revealed but not fully sunk.\n    # We look for any ship id X such that:\n    #  - partial_board contains at least one X (we've hit it)\n    #  - true_board contains more X than partial_board (there are hidden parts left)\n    ship_ids = set(true_board.flatten()) & set(partial_board.flatten())\n    ship_ids.discard(0)  # remove water\n    for X in ship_ids:\n        total_tiles = np.sum(true_board == X)\n        revealed_tiles = np.sum(partial_board == X)\n        # skip ships that are either not hit at all or already fully found\n        if revealed_tiles == 0 or revealed_tiles == total_tiles:\n            continue\n        # For each revealed part of ship X, check the tile directly above\n        for i, j in zip(*np.where(partial_board == X)):\n            ni = i - 1\n            if ni >= 0:\n                # If that tile is still hidden and actually contains X in the true board,\n                # then \"Up for X?\" is a valid yes.\n                if partial_board[ni, j] == -1 and true_board[ni, j] == X:\n                    return True\n    return False\n","name":"program_740","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Should I click top half of the board?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in the top half of the board,\n    otherwise returns False.\n    \"\"\"\n    # Determine how many rows constitute the \"top half\"\n    n_rows = true_board.shape[0]\n    half = n_rows \/\/ 2\n\n    # Slice out the top half of both boards\n    top_true = true_board[:half, :]\n    top_partial = partial_board[:half, :]\n\n    # A ship tile is indicated by a positive number in true_board,\n    # and an unrevealed tile is indicated by -1 in partial_board.\n    # We look for any position in the top half that satisfies both conditions.\n    mask_unrevealed_ship = (top_true > 0) & (top_partial == -1)\n\n    return bool(np.any(mask_unrevealed_ship))\n","name":"program_741","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"1-4 = yes, 5-8 = no","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in columns 1\u20134 (indices 0\u20133),\n    otherwise returns False.\n    \"\"\"\n    # A mask of unrevealed ship tiles everywhere on the board\n    unrevealed_ships = (true_board > 0) & (partial_board == -1)\n    \n    # Check only columns 0 through 3 (which correspond to columns 1\u20134)\n    return np.any(unrevealed_ships[:, :4])\n","name":"program_742","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"I feel like that the bottom left lol, down and to the right?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines whether there is any still-hidden ship tile\n    in the bottom-left quadrant of the board.\n\n    Bottom-left quadrant is defined as the last half of the rows\n    and the first half of the columns.\n    \"\"\"\n    # dimensions\n    n_rows, n_cols = true_board.shape\n\n    # define bottom-left quadrant mask\n    row_mid = n_rows \/\/ 2\n    col_mid = n_cols \/\/ 2\n    bottom_left_mask = np.zeros_like(true_board, dtype=bool)\n    bottom_left_mask[row_mid:, :col_mid] = True\n\n    # find still-hidden ship tiles\n    hidden_ship_tiles = (true_board > 0) & (partial_board == -1)\n\n    # is there any hidden ship tile in the bottom-left quadrant?\n    return bool(np.any(hidden_ship_tiles & bottom_left_mask))\n","name":"program_743","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the partially\u2010hit ship on the board is oriented horizontally.\n    \n    Strategy:\n    1. Locate all revealed ship\u2010tiles in partial_board (values > 0).\n    2. If there are no hits yet, we cannot infer orientation; return False.\n    3. Take the first hit\u2010coordinate, look up its ship\u2010type in true_board.\n    4. Find all coordinates of that ship\u2010type on the true_board.\n    5. If all of those coordinates share the same row index, the ship is horizontal.\n       Otherwise it is vertical.\n    \"\"\"\n    # 1) Find all revealed ship tiles\n    hit_indices = np.argwhere(partial_board > 0)\n    \n    # 2) If no hits, default to False\n    if hit_indices.shape[0] == 0:\n        return False\n    \n    # 3) Look up the ship type at the first revealed tile\n    r, c = hit_indices[0]\n    ship_type = true_board[r, c]\n    \n    # 4) Gather all coordinates of that ship on the true board\n    ship_coords = np.argwhere(true_board == ship_type)\n    rows = ship_coords[:, 0]\n    \n    # 5) Horizontal if all row indices are identical\n    return np.unique(rows).size == 1\n","name":"program_744","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"they bunched together?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if any two distinct ships on the true_board have cells that\n    touch each other (including diagonally), i.e. are \"bunched together\".\n    Otherwise return False.\n    \"\"\"\n    # Find all ship IDs (positive integers > 0)\n    ship_ids = np.unique(true_board)\n    ship_ids = ship_ids[ship_ids > 0]\n\n    # For each pair of ships, check if any cell of one is adjacent to any cell of the other\n    for i in range(len(ship_ids)):\n        for j in range(i + 1, len(ship_ids)):\n            id1, id2 = ship_ids[i], ship_ids[j]\n            coords1 = np.argwhere(true_board == id1)\n            coords2 = np.argwhere(true_board == id2)\n            for x1, y1 in coords1:\n                # Compute Chebyshev distance to every cell of the second ship\n                # If any distance is exactly 1, they're touching\n                dists = np.maximum(np.abs(coords2[:, 0] - x1),\n                                   np.abs(coords2[:, 1] - y1))\n                if np.any(dists == 1):\n                    return True\n    return False\n","name":"program_745","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"one in the bottom left corner?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines whether there is a ship tile in the bottom\u2010left corner (row H, column 1)\n    that is not yet revealed on the partial board.\n    \"\"\"\n    # Compute the index for the bottom row (H) and leftmost column (1)\n    bottom_row = true_board.shape[0] - 1  # H -> index 7 for an 8\u00d78\n    left_col = 0                         # 1 -> index 0\n\n    # Check the true board for a ship in that corner\n    has_ship = true_board[bottom_row, left_col] != 0\n\n    return bool(has_ship)\n","name":"program_746","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"upper left still?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed ship tile in the upper-left quadrant\n    of the board, False otherwise.\n    \"\"\"\n    # Determine the halfway point for rows and columns\n    n_rows, n_cols = true_board.shape\n    mid_row = n_rows \/\/ 2\n    mid_col = n_cols \/\/ 2\n\n    # Extract the upper-left quadrant\n    true_ul = true_board[:mid_row, :mid_col]\n    partial_ul = partial_board[:mid_row, :mid_col]\n\n    # A tile is an unrevealed ship tile if:\n    #   - true_board > 0 (it is part of a ship)\n    #   - partial_board == -1 (it is still hidden)\n    unrevealed_ship_mask = (true_ul > 0) & (partial_ul == -1)\n\n    # If any such tiles exist, answer \"Yes\" (True), else \"No\" (False)\n    return bool(np.any(unrevealed_ship_mask))\n","name":"program_747","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"up?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Answer the question \"up?\" by checking if there is any revealed\n    ship tile in partial_board that has a hidden ship tile directly\n    above it in true_board.\n    \"\"\"\n    rows, cols = true_board.shape\n\n    for i in range(1, rows):\n        for j in range(cols):\n            # Is (i, j) a revealed ship tile?\n            if partial_board[i, j] > 0:\n                # Is the tile above hidden, and is it in fact a ship in true_board?\n                if partial_board[i - 1, j] == -1 and true_board[i - 1, j] > 0:\n                    return True\n\n    return False\n","name":"program_748","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"any more in bottom right?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Define bottom-right quadrant: rows E-H (indices 4-7), columns 5-8 (indices 4-7)\n    br_true = true_board[4:8, 4:8]\n    br_partial = partial_board[4:8, 4:8]\n    \n    # A tile is an unrevealed ship if true_board>0 and partial_board is still hidden (-1)\n    unrevealed_ship_mask = (br_true > 0) & (br_partial == -1)\n    \n    # Return True if any such tile exists\n    return bool(np.any(unrevealed_ship_mask))\n","name":"program_749","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find any revealed ship tile in the partial board\n    hits = np.argwhere(partial_board > 0)\n    if hits.size == 0:\n        # No ship has been hit yet, so we cannot speak to any orientation\n        return False\n\n    # Get the first revealed hit and its ship code\n    i, j = hits[0]\n    ship_code = true_board[i, j]\n\n    # Gather all coordinates of that ship on the true board\n    ship_coords = np.argwhere(true_board == ship_code)\n\n    # If all column indices are the same, the ship is vertical\n    cols = ship_coords[:, 1]\n    return np.all(cols == cols[0])\n","name":"program_750","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"top left quadrant?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Define the top-left quadrant as rows 0\u20133 and columns 0\u20133\n    tl_true = true_board[0:4, 0:4]\n    tl_partial = partial_board[0:4, 0:4]\n\n    # A tile is an unrevealed ship if it's hidden in partial_board (== -1)\n    # and contains a ship in true_board (> 0).\n    unrevealed_ship_mask = (tl_partial == -1) & (tl_true > 0)\n\n    # If there's any such tile, the answer is \"Yes\" (True), otherwise \"No\" (False).\n    return bool(np.any(unrevealed_ship_mask))\n","name":"program_751","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"right?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile immediately\n    to the right of any revealed ship tile on the partial board.\n    \"\"\"\n    rows, cols = partial_board.shape\n    for i in range(rows):\n        for j in range(cols - 1):\n            # if (i, j) is a revealed ship and (i, j+1) is hidden but a ship on the true board\n            if partial_board[i, j] > 0 and partial_board[i, j+1] == -1 and true_board[i, j+1] > 0:\n                return True\n    return False\n","name":"program_752","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it in 1 or 2?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Columns 1 or 2 correspond to array indices 0 or 1\n    cols = [0, 1]\n    # A hidden ship tile is one where true_board>0 and partial_board==-1\n    hidden_ship_mask = (true_board > 0) & (partial_board == -1)\n    # Check if any such hidden ship tile lies in column 0 or 1\n    return bool(np.any(hidden_ship_mask[:, cols]))\n","name":"program_753","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"in c or d?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows C and D correspond to indices 2 and 3 (0-based indexing)\n    rows = [2, 3]\n    # Extract the relevant slices\n    true_slice = true_board[rows, :]\n    partial_slice = partial_board[rows, :]\n    # A tile is an unrevealed ship if it's hidden in partial (-1) and > 0 in true\n    unrevealed_ships = (partial_slice == -1) & (true_slice > 0)\n    return bool(np.any(unrevealed_ships))\n","name":"program_754","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"keep right?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # 1. Gather all revealed ship\u2010hits (partial_board > 0)\n    hit_positions = set(zip(*np.where(partial_board > 0)))\n    \n    # 2. Split them into connected clusters (4\u2010way adjacency)\n    clusters = []\n    while hit_positions:\n        start = hit_positions.pop()\n        stack = [start]\n        cluster = {start}\n        while stack:\n            i, j = stack.pop()\n            for di, dj in [(1,0),(-1,0),(0,1),(0,-1)]:\n                nbr = (i+di, j+dj)\n                if nbr in hit_positions:\n                    hit_positions.remove(nbr)\n                    stack.append(nbr)\n                    cluster.add(nbr)\n        clusters.append(cluster)\n    \n    if not clusters:\n        # No hits at all \u2013 captain wouldn't ask \"keep right?\"\n        return False\n    \n    # 3. Focus on the largest cluster (the current target)\n    cluster = max(clusters, key=len)\n    rows = [i for i, j in cluster]\n    cols = [j for i, j in cluster]\n    \n    # 4. Check if they lie in a single row (horizontal orientation)\n    if len(set(rows)) == 1:\n        r = rows[0]\n        # find the rightmost revealed column\n        c_max = max(cols)\n        c_next = c_max + 1\n        # 5. If the next cell to the right is still hidden in partial\n        #    but contains a ship in true_board, answer YES\n        if (0 <= c_next < partial_board.shape[1] and\n            partial_board[r, c_next] == -1 and\n            true_board[r, c_next] > 0):\n            return True\n    \n    # In all other cases, answer NO\n    return False\n","name":"program_755","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the ship currently being targeted (i.e. one\n    with at least one hit in partial_board but not yet fully revealed)\n    is oriented vertically.\n\n    Returns True if vertical, False if horizontal.\n    \"\"\"\n    targeted_id = None\n    max_hits = 0\n\n    # Find which ship is partially discovered:\n    # - has at least 1 hit in partial_board\n    # - not all of its tiles are revealed yet\n    # If there are multiple, pick the one with the most hits so far.\n    for ship_id in (1, 2, 3, 4):\n        hits = np.count_nonzero(partial_board == ship_id)\n        total = np.count_nonzero(true_board == ship_id)\n        if hits > 0 and hits < total and hits > max_hits:\n            max_hits = hits\n            targeted_id = ship_id\n\n    # If we didn't find a partially discovered ship, we cannot answer.\n    if targeted_id is None:\n        return False\n\n    # Get the true-board coordinates of that ship\n    coords = np.argwhere(true_board == targeted_id)\n    rows, cols = coords[:, 0], coords[:, 1]\n\n    # If all columns are the same, it's vertical\n    if np.all(cols == cols[0]):\n        return True\n    # If all rows are the same, it's horizontal\n    elif np.all(rows == rows[0]):\n        return False\n    # Otherwise, ambiguous (in practice this shouldn't happen in standard Battleship)\n    return False\n","name":"program_756","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"down?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # 1) Find the \"active\" ship: one with hits in partial_board but not fully revealed.\n    #    We assume ship\u2010IDs are 1,2,3,4.\n    for ship_id in (1, 2, 3, 4):\n        hit_positions = np.argwhere(partial_board == ship_id)\n        if hit_positions.size == 0:\n            continue\n        total_on_true = np.count_nonzero(true_board == ship_id)\n        if hit_positions.shape[0] < total_on_true:\n            # This is the unsunk ship we are chasing.\n            break\n    else:\n        # No unsunk hits found \u21d2 nothing to go down from.\n        return False\n\n    # 2) Pick the bottommost known hit (largest row index).\n    #    That is our \"last_hit\" for a vertical probe.\n    last_hit = hit_positions[np.argmax(hit_positions[:, 0])]\n    r, c = last_hit\n\n    # 3) Compute the cell immediately down (row+1).\n    down_r = r + 1\n    if down_r > true_board.shape[0] - 1:\n        return False\n\n    # 4) Answer \"Yes\" iff:\n    #    a) true_board[down_r, c] is part of the same ship_id\n    #    b) partial_board[down_r, c] is still hidden (-1)\n    return (true_board[down_r, c] == ship_id) and (partial_board[down_r, c] == -1)\n","name":"program_757","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"bottom right?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Define bottom-right quadrant: rows E\u2013H (indices 4\u20137) and columns 5\u20138 (indices 4\u20137)\n    tr = true_board[4:8, 4:8]\n    pr = partial_board[4:8, 4:8]\n    # If there's any hidden ship tile in that quadrant, answer \"Yes\"\n    return bool(np.any((tr > 0) & (pr == -1)))\n","name":"program_758","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it in 7 or 8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in column 7 or 8\n    (1-based indexing), otherwise False.\n    \"\"\"\n    # A mask of all hidden tiles\n    hidden = (partial_board == -1)\n    # A mask of all ship tiles\n    ship   = (true_board > 0)\n    # Combined mask of unrevealed ship tiles\n    hidden_ship = hidden & ship\n    # Check columns 7 and 8 \u2192 0-based cols 6 and 7\n    # hidden_ship[:, 6:] slices columns 6 and 7\n    return bool(hidden_ship[:, 6:].any())\n","name":"program_759","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"anything on rows 1&2 hit yes, no for 3,4","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one ship tile in rows 1 & 2 (i.e. indices 0 and 1)\n    that is still hidden to the Captain. Otherwise returns False.\n    \"\"\"\n    # Build a mask of all hidden ship cells\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n    # Restrict to rows 0 and 1 (which correspond to rows \u201c1 & 2\u201d in the Captain\u2019s phrasing)\n    return bool(np.any(hidden_ships[0:2, :]))\n","name":"program_760","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"5,6 yes, 7,8 no","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    The Captain's statement is:\n      - There are ships (unrevealed) in rows 5 & 6\n      - There are no ships (unrevealed) in rows 7 & 8\n\n    We check for any hidden ship tiles (true_board > 0 and partial_board == -1)\n    in those row ranges and then verify the Captain's claim.\n    \"\"\"\n    # Mask of unrevealed ship tiles\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n\n    # Rows 5 & 6 correspond to indices 4 and 5 (0-based)\n    has_in_5_6 = np.any(hidden_ships[4:6, :])\n\n    # Rows 7 & 8 correspond to indices 6 and 7 (0-based)\n    has_in_7_8 = np.any(hidden_ships[6:8, :])\n\n    # The Captain said \u201c5,6 yes\u201d (so has_in_5_6 must be True)\n    # and \u201c7,8 no\u201d (so has_in_7_8 must be False).\n    return has_in_5_6 and not has_in_7_8\n","name":"program_761","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"both 3, and 4?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one still-hidden ship tile in BOTH\n    row 3 and row 4 (1-based), i.e. in true_board rows indexed 2 and 3\n    (0-based), and False otherwise.\n    \"\"\"\n    # Convert 1-based rows 3 & 4 to 0-based indices\n    rows_to_check = [2, 3]\n    \n    for r in rows_to_check:\n        # A position is a still-hidden ship tile if:\n        #   true_board[r, c] > 0    (there is a ship)\n        # and partial_board[r, c] == -1 (still hidden)\n        unrevealed_ship = (true_board[r, :] > 0) & (partial_board[r, :] == -1)\n        if not np.any(unrevealed_ship):\n            # If either row has no unrevealed ship tiles, the answer is No\n            return False\n\n    # Both rows have at least one unrevealed ship tile\n    return True\n","name":"program_762","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"upper yes, lower no","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A mask of tiles that are ship parts in the true board but still hidden to the captain\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n    # Upper half: rows A\u2013D \u2192 indices 0\u20133\n    upper_has = hidden_ships[:4, :].any()\n    # Lower half: rows E\u2013H \u2192 indices 4\u20137\n    lower_has = hidden_ships[4:, :].any()\n    # Return True if there is at least one hidden ship tile in the upper half\n    # and zero hidden ship tiles in the lower half\n    return upper_has and not lower_has\n","name":"program_763","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"left?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is an unrevealed ship segment immediately to the left\n    of the currently targeted horizontal ship (i.e. a ship with >=2 revealed\n    hits in the same row). If no such multi\u2010hit target exists, check all\n    revealed hits for an unrevealed ship square to their left.\n    \"\"\"\n    # 1) Group revealed ship\u2010hits by ship ID\n    hits = {}  # ship_id -> list of (r,c)\n    rows, cols = partial_board.shape\n    for r in range(rows):\n        for c in range(cols):\n            pid = partial_board[r, c]\n            if pid > 0:\n                hits.setdefault(pid, []).append((r, c))\n\n    # 2) Look for a ship with >=2 hits on the same row (horizontal target)\n    for ship_id, coords in hits.items():\n        if len(coords) >= 2:\n            # check if they lie on the same row\n            rows_of_hits = {r for r, _ in coords}\n            if len(rows_of_hits) == 1:\n                r = rows_of_hits.pop()\n                # find leftmost hit\n                min_c = min(c for _, c in coords)\n                # see if to the left is an unrevealed ship\n                if min_c > 0:\n                    if partial_board[r, min_c - 1] == -1 and true_board[r, min_c - 1] > 0:\n                        return True\n                    else:\n                        return False\n                else:\n                    return False\n\n    # 3) Fallback: any revealed hit with an unrevealed ship immediately to its left?\n    for r in range(rows):\n        for c in range(cols):\n            if partial_board[r, c] > 0:\n                if c > 0 and partial_board[r, c - 1] == -1 and true_board[r, c - 1] > 0:\n                    return True\n\n    return False\n","name":"program_764","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"e4 yes, b4 no","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert row letters to 0-based indices\n    def row_idx(letter: str) -> int:\n        return ord(letter.upper()) - ord('A')\n    # Convert column numbers (strings or ints) to 0-based indices\n    def col_idx(num) -> int:\n        return int(num) - 1\n\n    # Coordinates E4 and B4\n    r1, c1 = row_idx('E'), col_idx(4)\n    r2, c2 = row_idx('B'), col_idx(4)\n\n    # Check for unrevealed ship tiles at each coordinate\n    has_ship_e4 = (true_board[r1, c1] > 0) and (partial_board[r1, c1] == -1)\n    has_ship_b4 = (true_board[r2, c2] > 0) and (partial_board[r2, c2] == -1)\n\n    # The Captain asked if both E4 and B4 contain ships\n    return bool(has_ship_e4 and has_ship_b4)\n","name":"program_765","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"C?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines if there are any unrevealed ship tiles in row C.\n    \n    Row indices: A=0, B=1, C=2, ..., H=7.\n    A tile is considered \"unrevealed\" if partial_board == -1.\n    A ship tile in the true_board is indicated by values > 0.\n    \"\"\"\n    # row index for 'C'\n    row_idx = 2\n    \n    # mask of true ship tiles in row C\n    ship_tiles = true_board[row_idx, :] > 0\n    \n    # mask of still-hidden tiles in row C\n    hidden_tiles = partial_board[row_idx, :] == -1\n    \n    # if any tile is both a ship and still hidden, answer is Yes\n    return bool(np.any(ship_tiles & hidden_tiles))\n","name":"program_766","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"nice job. more ships in upper?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the halfway point of the board (upper half = first floor(n\/2) rows)\n    n_rows = true_board.shape[0]\n    top_half = n_rows \/\/ 2\n\n    # Slice the upper half of both boards\n    true_top = true_board[:top_half, :]\n    partial_top = partial_board[:top_half, :]\n\n    # An unrevealed ship tile is where true_board > 0 but partial_board == -1\n    unrevealed_ship_in_top = (true_top > 0) & (partial_top == -1)\n\n    # If any such tile exists, answer \"Yes\" (True), otherwise \"No\" (False)\n    return bool(np.any(unrevealed_ship_in_top))\n","name":"program_767","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"top left?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one hidden ship tile\n    in the top-left quadrant of the board, False otherwise.\n    \"\"\"\n    # Determine board dimensions\n    nrows, ncols = true_board.shape\n    \n    # Define the top-left quadrant (first half of rows and first half of columns)\n    row_slice = slice(0, nrows \/\/ 2)\n    col_slice = slice(0, ncols \/\/ 2)\n    \n    # Extract the corresponding subarrays\n    true_sub    = true_board[row_slice, col_slice]\n    partial_sub = partial_board[row_slice, col_slice]\n    \n    # A hidden ship tile is one where true_board > 0 but partial_board is still -1\n    hidden_ships_in_tl = (true_sub > 0) & (partial_sub == -1)\n    \n    # If any such tile exists, answer \"Yes\" (True), otherwise \"No\" (False)\n    return np.any(hidden_ships_in_tl)\n","name":"program_768","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"bottom left?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there are any unrevealed ship tiles in the bottom\u2010left quadrant\n    of the board, False otherwise.\n    We define the bottom\u2010left quadrant as the rows from half the board to the end,\n    and the columns from 0 to half the board.\n    \"\"\"\n    n_rows, n_cols = true_board.shape\n    # split points\n    half_row = n_rows \/\/ 2\n    half_col = n_cols \/\/ 2\n\n    # extract bottom\u2010left region\n    true_region = true_board[half_row:, :half_col]\n    partial_region = partial_board[half_row:, :half_col]\n\n    # A ship tile is > 0 in true_board, but still hidden in partial_board (== -1)\n    hidden_ship_mask = (true_region > 0) & (partial_region == -1)\n    return np.any(hidden_ship_mask)\n","name":"program_769","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"in either 5 or 6?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one still\u2010hidden ship tile in\n    column 5 or column 6 (0\u2010indexed columns 4 or 5), otherwise False.\n    \"\"\"\n    # Columns 5 and 6 correspond to indices 4 and 5\n    cols = [4, 5]\n    # Take those two columns from both boards\n    ships_in_cols = true_board[:, cols]\n    hidden_mask = partial_board[:, cols] == -1\n    # A ship is an entry > 0; we only care about tiles still hidden\n    return np.any((ships_in_cols > 0) & hidden_mask)\n","name":"program_770","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"1 or 2?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # The question \"1 or 2?\" refers to columns 1 or 2 (zero\u2010based indices 0 and 1).\n    # We return True if there is any ship tile in those columns that remains hidden.\n    cols = [0, 1]\n    # Identify ship positions in columns 0 or 1\n    ship_positions = true_board[:, cols] > 0\n    # Identify which of those positions are still hidden in the captain's view\n    still_hidden = partial_board[:, cols] == -1\n    # If any tile is both a ship and still hidden, answer \"Yes\"\n    return bool(np.any(ship_positions & still_hidden))\n","name":"program_771","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"1 or 2?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines whether there is any unrevealed ship tile (\u2018true_board\u2019 > 0\n    and \u2018partial_board\u2019 == -1) in column 1 or column 2 (1-based).\n    \"\"\"\n    # Mask of all tiles that are ships in the true board but still hidden\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n    \n    # Columns 1 and 2 correspond to indices 0 and 1\n    return bool(np.any(hidden_ships[:, 0:2]))\n","name":"program_772","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the ship associated with any revealed hit on the partial_board\n    extends vertically (i.e., has at least one hidden segment directly above or below\n    the hit of the same ship on the true_board).\n    \"\"\"\n    # Find all revealed ship tiles (hits) on the partial board\n    hit_positions = np.argwhere(partial_board > 0)\n    \n    n_rows, n_cols = true_board.shape\n    \n    for (r, c) in hit_positions:\n        ship_id = true_board[r, c]\n        \n        # Check directly above\n        if r - 1 >= 0:\n            if partial_board[r - 1, c] == -1 and true_board[r - 1, c] == ship_id:\n                return True\n        \n        # Check directly below\n        if r + 1 < n_rows:\n            if partial_board[r + 1, c] == -1 and true_board[r + 1, c] == ship_id:\n                return True\n    \n    # No matching hidden segments found vertically for any revealed hit\n    return False\n","name":"program_773","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"right?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines if there is an unrevealed ship tile immediately to the right\n    of the current contiguous run of revealed hits (i.e., answers \"right?\").\n    \"\"\"\n    # Identify all revealed ship hits on the partial board\n    hits = partial_board > 0\n\n    # If no hits have been revealed yet, there's nothing to check on the right\n    if not hits.any():\n        return False\n\n    n_rows, n_cols = true_board.shape\n\n    # For each row that has at least one hit...\n    for r in range(n_rows):\n        hit_cols = np.where(hits[r])[0]\n        if hit_cols.size == 0:\n            continue\n\n        # Find the rightmost hit in this row\n        rightmost = hit_cols.max()\n\n        # Check the tile immediately to the right of that hit\n        if rightmost + 1 < n_cols:\n            # It's a ship on the true board and still hidden on the partial board\n            if true_board[r, rightmost + 1] > 0 and partial_board[r, rightmost + 1] == -1:\n                return True\n\n    return False\n","name":"program_774","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"bottom right?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in the bottom\u2010right quadrant of the board, False otherwise.\n    We treat \"bottom right\" as the subarray of rows m\/\/2: and cols n\/\/2:\n    for an m\u00d7n board.\n    \"\"\"\n    m, n = true_board.shape\n    r0, c0 = m \/\/ 2, n \/\/ 2\n    \n    # extract bottom\u2010right quadrants\n    br_true    = true_board[r0:, c0:]\n    br_partial = partial_board[r0:, c0:]\n    \n    # an unrevealed ship tile is where true_board>0 but partial_board==-1\n    unrevealed_ship = (br_true > 0) & (br_partial == -1)\n    \n    return bool(unrevealed_ship.any())\n","name":"program_775","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"any more in upper right?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Define the \"upper right\" as the top half of rows and the right half of columns.\n    n_rows, n_cols = true_board.shape\n    row_mid = n_rows \/\/ 2\n    col_mid = n_cols \/\/ 2\n\n    # Extract the upper\u2010right quadrant from both boards\n    true_quadrant = true_board[:row_mid, col_mid:]\n    partial_quadrant = partial_board[:row_mid, col_mid:]\n\n    # A tile contains an unrevealed ship if true_board > 0 but partial_board == -1\n    unrevealed_ships = (true_quadrant > 0) & (partial_quadrant == -1)\n    return np.any(unrevealed_ships)\n","name":"program_776","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"7 or 8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in column 7 or 8.\n    Columns are 1-indexed for the players, so these correspond to indices 6 and 7.\n    \"\"\"\n    # Create a mask of all unrevealed ship tiles\n    unrevealed_ships = (true_board > 0) & (partial_board == -1)\n    # Check columns 7 and 8 (zero\u2010based indices 6 and 7)\n    return bool(np.any(unrevealed_ships[:, 6:8]))\n","name":"program_777","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is at least one unrevealed ship (in true_board but still -1 in partial_board)\n    whose remaining hidden cells form a vertical line; otherwise return False.\n    \"\"\"\n    # mask of still\u2010hidden ship cells\n    hidden_ship = (true_board > 0) & (partial_board == -1)\n    nrows, ncols = true_board.shape\n\n    # gather all coordinates of hidden ship parts\n    coords = list(zip(*np.where(hidden_ship)))\n    visited = set()\n    \n    # helper to collect a connected cluster via DFS\n    def collect_cluster(start):\n        stack = [start]\n        cluster = []\n        visited.add(start)\n        while stack:\n            r, c = stack.pop()\n            cluster.append((r, c))\n            for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):\n                nr, nc = r+dr, c+dc\n                if (0 <= nr < nrows and 0 <= nc < ncols\n                    and hidden_ship[nr, nc]\n                    and (nr, nc) not in visited):\n                    visited.add((nr, nc))\n                    stack.append((nr, nc))\n        return cluster\n\n    # build clusters and check orientation\n    for coord in coords:\n        if coord in visited:\n            continue\n        cluster = collect_cluster(coord)\n        if len(cluster) > 1:\n            rows = {r for r, _ in cluster}\n            cols = {c for _, c in cluster}\n            # if all cells share the same column, it's vertical\n            if len(cols) == 1:\n                return True\n\n    return False\n","name":"program_778","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"A or B?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in row A or B (indices 0 or 1), otherwise False.\n    \"\"\"\n    # A or B corresponds to row indices 0 and 1\n    # A tile is unrevealed if partial_board == -1\n    # A tile is a ship tile if true_board > 0\n    unrevealed_ship_tiles = (true_board > 0) & (partial_board == -1)\n    # Check rows 0 and 1\n    return bool(unrevealed_ship_tiles[0:2, :].any())\n","name":"program_779","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship in row B?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row B corresponds to index 1 (0-based indexing)\n    row_index = 1\n    \n    # Extract the true and partial rows\n    true_row = true_board[row_index, :]\n    partial_row = partial_board[row_index, :]\n    \n    # A ship tile is indicated by a value > 0 in true_board.\n    # We only care about those ship tiles that are still hidden (partial_board == -1).\n    unrevealed_ship_tiles = (true_row > 0) & (partial_row == -1)\n    \n    # If there is at least one unrevealed ship tile in row B, return True\n    return bool(np.any(unrevealed_ship_tiles))\n","name":"program_780","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any ships from on G + Odd#?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the row index for 'G' (0-based: A\u21920, B\u21921, \u2026, G\u21926)\n    row_g = ord('G') - ord('A')\n    # Build a mask for odd-numbered columns (1-based odd \u2192 indices 0, 2, 4, 6)\n    odd_cols = np.arange(true_board.shape[1])[::2]\n    # Check for any ship tile in row G at those odd columns that is still hidden\n    unseen_ships = (true_board[row_g, odd_cols] > 0) & (partial_board[row_g, odd_cols] == -1)\n    return bool(np.any(unseen_ships))\n","name":"program_781","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Even # = Yes. Odd # = No","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    According to the Captain's instruction 'Even # = Yes. Odd # = No',\n    we interpret 'the number' as the count of still-hidden ship\u2010tiles.\n    If that count is even, we return True ('Yes'); if odd, False ('No').\n    \"\"\"\n    # A tile is a still-hidden ship\u2010tile if partial_board == -1 but true_board > 0\n    hidden_ship_tiles = np.logical_and(partial_board == -1, true_board > 0)\n    count_hidden = np.count_nonzero(hidden_ship_tiles)\n    \n    # Even count \u2192 Yes (True); Odd count \u2192 No (False)\n    return (count_hidden % 2) == 0\n","name":"program_782","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are any ships touching the border of the map?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if any ship cells (1\u20134) occupy a border position\n    (top row, bottom row, left column or right column) of the true_board.\n    \"\"\"\n    # Create a mask of the border cells\n    top_row    = true_board[0, :]\n    bottom_row = true_board[-1, :]\n    left_col   = true_board[:, 0]\n    right_col  = true_board[:, -1]\n\n    # Check if any of those border cells contain a ship (> 0)\n    return bool(\n        np.any(top_row    > 0) or\n        np.any(bottom_row > 0) or\n        np.any(left_col   > 0) or\n        np.any(right_col  > 0)\n    )\n","name":"program_783","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"1 & 3 = yes 5&7 = no","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Captain's question: \"1 & 3 = yes 5&7 = no\"\n    Interpreted as:\n      - Columns 1 and 3 (1-indexed) must each have at least one *unrevealed* ship tile.\n      - Columns 5 and 7 (1-indexed) must have *no* unrevealed ship tiles.\n    We treat \"unrevealed ship tile\" as a cell where true_board > 0 but partial_board == -1.\n    \"\"\"\n    # Build a mask of unrevealed ship positions\n    unrevealed = (true_board > 0) & (partial_board == -1)\n    \n    # Convert 1-indexed columns to 0-indexed\n    c1, c3, c5, c7 = 0, 2, 4, 6\n    \n    # Check that col1 and col3 each contain at least one unrevealed ship tile\n    cond_yes = unrevealed[:, c1].any() and unrevealed[:, c3].any()\n    # Check that col5 and col7 contain no unrevealed ship tiles\n    cond_no  = not (unrevealed[:, c5].any() or unrevealed[:, c7].any())\n    \n    return cond_yes and cond_no\n","name":"program_784","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Up\/left border = YES, Down\/Right = NO","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is any ship (any positive entry) on the top row (row 0)\n    or the leftmost column (col 0) of the true_board. Otherwise return False.\n    \n    The captain's question \"Up\/left border = YES, Down\/Right = NO\" is interpreted\n    as \"Are there any ships on the up (top) or left border?\"\n    \"\"\"\n    # A ship is indicated by any value > 0 in true_board\n    top_border_has_ship  = np.any(true_board[0, :] > 0)\n    left_border_has_ship = np.any(true_board[:, 0] > 0)\n    \n    return bool(top_border_has_ship or left_border_has_ship)\n","name":"program_785","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Up + Down = YES, UP ONLY= NO","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there exists at least one revealed ship tile in partial_board\n    which has unrevealed (hidden) tiles of the same ship both immediately above\n    and immediately below it. Otherwise returns False.\n    \"\"\"\n    # Find all positions where the captain has already hit a ship\n    hits = np.argwhere((partial_board > 0) & (true_board > 0))\n    \n    nrows, ncols = true_board.shape\n    for i, j in hits:\n        ship_id = true_board[i, j]\n        \n        # Check the tile immediately above\n        up = (\n            i - 1 >= 0\n            and partial_board[i - 1, j] == -1\n            and true_board[i - 1, j] == ship_id\n        )\n        # Check the tile immediately below\n        down = (\n            i + 1 < nrows\n            and partial_board[i + 1, j] == -1\n            and true_board[i + 1, j] == ship_id\n        )\n        \n        # If both up and down are valid hidden ship tiles, answer YES\n        if up and down:\n            return True\n    \n    # Otherwise answer NO\n    return False\n","name":"program_786","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any ship on any Letter Border on the right?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Extract the rightmost column (index -1)\n    right_edge_true = true_board[:, -1]\n    right_edge_partial = partial_board[:, -1]\n    \n    # Identify ship tiles in the true board (values 1\u20134)\n    ships_on_right = (right_edge_true > 0)\n    \n    # Of those, check which are still hidden in the partial board (-1)\n    hidden_ships_on_right = ships_on_right & (right_edge_partial == -1)\n    \n    # If any such tile exists, return True (yes), otherwise False (no)\n    return bool(np.any(hidden_ships_on_right))\n","name":"program_787","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Which has more ships? E-H = Yes, A-D = NO","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify all ship tiles on the true board\n    ship_tiles = true_board > 0\n    \n    # Of those, find which are still hidden in the partial board\n    unrevealed_ships = ship_tiles & (partial_board == -1)\n    \n    # Rows A\u2013D correspond to indices 0\u20133, E\u2013H to 4\u20137\n    ships_AD = unrevealed_ships[:4, :].sum()\n    ships_EH = unrevealed_ships[4:, :].sum()\n    \n    # Return True if E\u2013H has more remaining ship tiles, else False\n    return bool(ships_EH > ships_AD)\n","name":"program_788","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Choose whicher has more ships. Even = Yes Odd =No","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether even\u2010numbered rows (B, D, F, H) contain more ship segments\n    than odd\u2010numbered rows (A, C, E, G). Return True if even > odd, otherwise False.\n    \"\"\"\n    # In the board arrays, rows are zero\u2010indexed: A=0, B=1, C=2, ..., H=7.\n    # \"Even\" rows correspond to indices 1,3,5,7; \"Odd\" rows to 0,2,4,6.\n    even_count = np.count_nonzero(true_board[1::2] > 0)\n    odd_count  = np.count_nonzero(true_board[0::2] > 0)\n    return even_count > odd_count\n","name":"program_789","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is choosing F3 a hit?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the tile F3 contains part of any ship on the true_board,\n    otherwise returns False.\n    \"\"\"\n    # Map row letter 'F' to its 0-based index: 'A'->0, 'B'->1, ..., 'H'->7\n    row_index = ord('F') - ord('A')  # F->5\n    col_index = 3 - 1                # Column 3 -> index 2 (0-based)\n    \n    # A ship tile is indicated by a positive integer (>0)\n    return true_board[row_index, col_index] > 0\n","name":"program_790","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Horizontal = Yes, Vertical = NO","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True (Yes) if there exists at least one ship whose orientation is\n    horizontal and that still has at least one hidden tile (-1) in the partial_board.\n    Otherwise returns False (No), which corresponds to 'all remaining hidden ships\n    (if any) being vertical or there being no hidden ships at all.\n    \"\"\"\n    # Find all ship IDs (1,2,3,4) present on the true board\n    ship_ids = {sid for sid in np.unique(true_board) if sid != 0}\n\n    for sid in ship_ids:\n        # get the coordinates (row, col) of every cell of ship sid\n        coords = np.argwhere(true_board == sid)\n        if coords.size == 0:\n            continue\n\n        # determine orientation: horizontal if all rows are the same\n        rows = coords[:, 0]\n        cols = coords[:, 1]\n        if rows.max() == rows.min():\n            # this ship is horizontal; check if any of its cells is still hidden\n            for r, c in coords:\n                if partial_board[r, c] == -1:\n                    return True\n\n    # no horizontal ship has unrevealed tiles\n    return False\n","name":"program_791","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Last ship A-D?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the remaining (last undiscovered) ship lies entirely within rows A\u2013D.\n    Rows A\u2013D correspond to indices 0\u20133 in the numpy array.\n    \"\"\"\n\n    # 1) Find all ship tiles that are still hidden\n    #    A hidden ship tile is one where partial_board is -1 and true_board > 0\n    hidden_ship_mask = (partial_board == -1) & (true_board > 0)\n\n    # 2) Identify which ship IDs have hidden tiles\n    ship_ids_with_hidden = np.unique(true_board[hidden_ship_mask])\n    # If there's no hidden ship tile, there is no 'last ship' to locate\n    if ship_ids_with_hidden.size == 0:\n        return False\n\n    # 3) We assume there's exactly one ship still undiscovered; take its ID\n    last_ship_id = ship_ids_with_hidden[0]\n\n    # 4) Get the row indices of all tiles belonging to that ship\n    coords = np.argwhere(true_board == last_ship_id)\n    rows = coords[:, 0]  # row indices (0-based, so 0=A, 1=B, \u2026, 7=H)\n\n    # 5) Check if all those rows are in the range 0\u20133 (i.e., A\u2013D)\n    return np.all(rows <= 3)\n","name":"program_792","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"1-4?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship cell\n    in columns 1 through 4 (inclusive), otherwise False.\n    \"\"\"\n    # Create a mask of all ship cells on the true board\n    ship_cells = true_board > 0\n    # Create a mask of all cells still hidden to the captain\n    hidden_cells = partial_board == -1\n    # Combine masks to find unrevealed ship cells\n    unrevealed_ships = ship_cells & hidden_cells\n    # Check only columns 1-4 (indices 0-3)\n    cols_1_to_4 = unrevealed_ships[:, :4]\n    # If any of those are True, there is an unrevealed ship in columns 1-4\n    return bool(np.any(cols_1_to_4))\n","name":"program_793","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"A-d yes e-h no","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one still\u2010hidden ship tile in rows A\u2013D\n    and no still\u2010hidden ship tiles in rows E\u2013H. Otherwise returns False.\n    \"\"\"\n    # A\u2013D correspond to rows 0\u20133, E\u2013H to rows 4\u20137\n    # A hidden ship tile is where true_board != 0 but partial_board == -1\n    hidden_ships = (true_board != 0) & (partial_board == -1)\n\n    any_in_AD = np.any(hidden_ships[:4, :])\n    any_in_EH = np.any(hidden_ships[4:, :])\n\n    # We check the proposition \"ships in A\u2013D AND no ships in E\u2013H\"\n    return bool(any_in_AD and not any_in_EH)\n","name":"program_794","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any ships on 6-8?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We interpret \"6-8\" as columns 6, 7, and 8 (1-based indexing).\n    # Convert to 0-based: columns 5, 6, 7.\n    # Check for any unrevealed ship tiles in those columns.\n    cols = slice(5, 8)\n    # True where there's a ship on the true board\n    ship_mask = true_board[:, cols] > 0\n    # True where the captain has not yet revealed the tile\n    hidden_mask = partial_board[:, cols] == -1\n    # If any position is both a ship and hidden, answer is True\n    return bool(np.any(ship_mask & hidden_mask))\n","name":"program_795","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any ships on A-D?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows A\u2013D correspond to indices 0\u20133.\n    # A ship tile is any true_board cell > 0.\n    # A tile is still hidden if partial_board == -1.\n    # We want to know if there exists any hidden ship tile in rows A\u2013D.\n    \n    # Slice out rows A\u2013D\n    true_slice = true_board[0:4, :]\n    partial_slice = partial_board[0:4, :]\n    \n    # Boolean mask for ship tiles in the true board\n    ships = true_slice > 0\n    # Boolean mask for hidden tiles in the partial board\n    hidden = partial_slice == -1\n    \n    # If there's any position that is both a ship and still hidden, answer is True\n    return bool(np.any(ships & hidden))\n","name":"program_796","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Top half yes bottom half no","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the halfway point of the board (top half vs. bottom half)\n    half = true_board.shape[0] \/\/ 2  # For an 8\u00d78 board, half == 4\n    \n    # Slice out the top half of both boards (rows A\u2013D)\n    top_true = true_board[:half, :]\n    top_partial = partial_board[:half, :]\n    \n    # A ship tile is \u201cunrevealed\u201d if true_board > 0 but partial_board == -1\n    unrevealed_in_top = (top_true > 0) & (top_partial == -1)\n    \n    # If any such tiles exist, answer \u201cYes\u201d (True); otherwise \u201cNo\u201d (False)\n    return bool(np.any(unrevealed_in_top))\n","name":"program_797","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"1-4= yes 5-8= no","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship\u2010tile in columns 1\u20134,\n    i.e. indices 0\u20133, otherwise False.\n    \"\"\"\n    # mask of all ship cells (true_board > 0)\n    ship_mask = true_board > 0\n    # mask of still-hidden cells (partial_board == -1)\n    hidden_mask = partial_board == -1\n    # look only in cols 0..3\n    region_mask = ship_mask[:, 0:4] & hidden_mask[:, 0:4]\n    # if any True, we answer \"Yes\"\n    return bool(np.any(region_mask))\n","name":"program_798","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Ab yes cd no","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Captain asked: \"Ab yes cd no\"\n    Return True if there are any unrevealed ship tiles in rows A\u2013B (indices 0 and 1),\n    otherwise False.\n    \"\"\"\n    # Identify positions in rows A (0) and B (1)\n    rows_ab = slice(0, 2)\n    # A ship tile in true_board is > 0. A hidden tile in partial_board is -1.\n    unrevealed_ab = (true_board[rows_ab, :] > 0) & (partial_board[rows_ab, :] == -1)\n    return bool(np.any(unrevealed_ab))\n","name":"program_799","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"B2 hit?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # The Captain asked: \"B2 hit?\" \n    # Map row 'B' -> index 1, column 2 -> index 1 (0-based)\n    row_idx = ord('B') - ord('A')\n    col_idx = 2 - 1\n    \n    # A \"hit\" means there's a ship on true_board at that location.\n    # Ship cells are labeled 1\u20134; water is 0.\n    return true_board[row_idx, col_idx] > 0\n","name":"program_800","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Ab=yes cd=no","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is at least one unrevealed ship\u2010tile\n    in rows A or B (rows 0 and 1 in a 0\u2010indexed numpy array).\n    \"\"\"\n    # A tile is unrevealed if partial_board == -1\n    hidden = (partial_board == -1)\n    # A tile contains a ship if true_board > 0\n    ship = (true_board > 0)\n    # An unrevealed ship tile is one where both conditions hold\n    unrevealed_ship = hidden & ship\n    # Check rows A and B (indices 0 and 1)\n    return unrevealed_ship[0:2, :].any()\n","name":"program_801","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Odd yes even no","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    on an odd-numbered column (1, 3, 5, 7), otherwise False.\n    Columns are 1-indexed in the game but 0-indexed in the array,\n    so odd game-columns correspond to array indices 0,2,4,6.\n    \"\"\"\n    # Boolean mask of all unrevealed ship positions\n    unrevealed_ships = (true_board > 0) & (partial_board == -1)\n    \n    # Create a boolean mask for odd-numbered columns in array indexing:\n    # array cols 0,2,4,6 correspond to game cols 1,3,5,7.\n    cols = np.arange(true_board.shape[1])\n    odd_col_mask = (cols % 2 == 0)  # True for indices 0,2,4,6\n    \n    # Broadcast odd_col_mask across rows and combine\n    mask = unrevealed_ships & odd_col_mask[np.newaxis, :]\n    \n    return bool(np.any(mask))\n","name":"program_802","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Vertical yes horizontal no","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship oriented vertically\n    and no unrevealed ships oriented horizontally. Otherwise returns False.\n    \"\"\"\n    found_vertical = False\n    found_horizontal = False\n\n    # Iterate over each ship id (1\u20134)\n    for ship_id in np.unique(true_board):\n        if ship_id <= 0:\n            continue\n\n        # Mask of this ship's tiles\n        ship_mask = (true_board == ship_id)\n        # Check if any of this ship's tiles remain unrevealed\n        if np.any((partial_board == -1) & ship_mask):\n            # Get the coordinates of all tiles of this ship\n            coords = np.argwhere(ship_mask)\n            rows = coords[:, 0]\n            cols = coords[:, 1]\n            # If all tiles share the same row \u2192 horizontal\n            if np.all(rows == rows[0]):\n                found_horizontal = True\n            # If all tiles share the same column \u2192 vertical\n            if np.all(cols == cols[0]):\n                found_vertical = True\n\n    # Captain asked: vertical yes, horizontal no\n    return found_vertical and not found_horizontal\n","name":"program_803","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Odd number yes odd no","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A column is odd-numbered if its index+1 is odd, i.e., index % 2 == 0\n    # We want any unrevealed ship tile (partial_board == -1 & true_board > 0)\n    # that lies in an odd-numbered column.\n    \n    # Mask of unrevealed ship tiles\n    unrevealed_ships = (partial_board == -1) & (true_board > 0)\n    \n    # Get column indices for the board\n    _, cols = np.indices(true_board.shape)\n    \n    # Mask for odd-numbered columns (1,3,5,7,...). In 0-based indexing that's cols % 2 == 0\n    odd_columns = (cols % 2 == 0)\n    \n    # Check if any unrevealed ship tile lies in an odd column\n    return bool(np.any(unrevealed_ships & odd_columns))\n","name":"program_804","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any other ships touching the borders?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A ship\u2010tile is a cell where true_board>0.\n    # A hidden tile is a cell where partial_board==-1.\n    # We want any ship\u2010tile that is still hidden and lies on the outermost rows (0 or -1)\n    # or outermost columns (0 or -1).\n    \n    # Build mask of hidden ship\u2010tiles\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n    \n    # Extract row and col indices of those hidden ship\u2010tiles\n    rows, cols = np.nonzero(hidden_ships)\n    \n    # Check if any of them lie on a border\n    max_r, max_c = true_board.shape[0] - 1, true_board.shape[1] - 1\n    for r, c in zip(rows, cols):\n        if r == 0 or r == max_r or c == 0 or c == max_c:\n            return True\n    return False\n","name":"program_805","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Top\/bottom yes left\/right no","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify tiles that are ship pieces in the true board but still hidden to the captain\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n\n    # Check the four borders for any hidden ship tiles\n    top_edge    = hidden_ships[0, :].any()\n    bottom_edge = hidden_ships[-1, :].any()\n    left_edge   = hidden_ships[:, 0].any()\n    right_edge  = hidden_ships[:, -1].any()\n\n    # Captain's query is:\n    #   \"Top\/bottom yes\"  \u2192 at least one ship on the top or bottom border\n    # and\n    #   \"left\/right no\"   \u2192 no ships on the left or right border\n    return (top_edge or bottom_edge) and not (left_edge or right_edge)\n","name":"program_806","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Left yes right no","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A tile is an unrevealed ship if partial_board == -1 and true_board > 0\n    unrevealed_ship = (partial_board == -1) & (true_board > 0)\n    # Check the left border (column index 0 in 0-based numpy)\n    return bool(unrevealed_ship[:, 0].any())\n","name":"program_807","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are any ships in the middle? I.e ships not touching the outer 2 layers. (Border 1 and 2)","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there exists at least one ship on true_board\n    whose tiles all lie strictly within the \"middle\" region of the board,\n    i.e. not touching the outer two layers of rows or columns.\n    \"\"\"\n    # Board dimension (assume square)\n    n = true_board.shape[0]\n    # Thickness of the border layers we exclude\n    border_thickness = 2\n\n    # If the board is too small to have an interior, short\u2010circuit\n    if n <= 2 * border_thickness:\n        return False\n\n    # Valid interior row\/column indices\n    interior_rows = np.arange(border_thickness, n - border_thickness)\n    interior_cols = np.arange(border_thickness, n - border_thickness)\n\n    # Identify all ship IDs present (positive integers)\n    ship_ids = np.unique(true_board)\n    ship_ids = ship_ids[ship_ids > 0]\n\n    for s in ship_ids:\n        # Find all coordinates of that ship\n        coords = np.argwhere(true_board == s)\n        # Check if *all* of this ship's tiles lie in the interior region\n        rows_ok = np.in1d(coords[:, 0], interior_rows)\n        cols_ok = np.in1d(coords[:, 1], interior_cols)\n        if rows_ok.all() and cols_ok.all():\n            return True\n\n    return False\n","name":"program_808","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"For the middle ship. Even = Yes Odd = NO","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine the parity (even\/odd) of the unique ship that occupies\n    at least one tile in the \"middle\" region (rows 3\u20136, cols 3\u20136 zero\u2010based 2:6).\n    Return True if that ship's total length is even, False otherwise.\n    \"\"\"\n    # Define the middle region (zero\u2010based indices 2 through 5 inclusive)\n    middle_region = true_board[2:6, 2:6]\n    \n    # Find which ship IDs (1\u20134) appear in that region\n    ship_ids = np.unique(middle_region)\n    # Exclude water (0)\n    ship_ids = ship_ids[ship_ids != 0]\n    \n    # If there isn't exactly one \"middle\" ship, we cannot unambiguously answer\n    if ship_ids.size != 1:\n        return False\n    \n    middle_ship_id = ship_ids[0]\n    # Count how many tiles that ship occupies on the entire board\n    ship_length = np.count_nonzero(true_board == middle_ship_id)\n    \n    # Return True if even length, False if odd\n    return (ship_length % 2 == 0)\n","name":"program_809","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"FOCUS ON WHAT? TOP = YES BOTTOM= NO","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify all unrevealed ship\u2010tiles:\n    #   partial_board == -1 (hidden) AND true_board > 0 (a ship)\n    unrevealed = (partial_board == -1) & (true_board > 0)\n\n    # Define top half as rows A\u2013D (indices 0\u20133) and bottom half as E\u2013H (indices 4\u20137)\n    top_unrevealed = np.sum(unrevealed[:4, :])\n    bottom_unrevealed = np.sum(unrevealed[4:, :])\n\n    # Return True (YES) if there are more unrevealed ship\u2010tiles in the top half,\n    # otherwise False (NO)\n    return top_unrevealed > bottom_unrevealed\n","name":"program_810","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the ship on row G?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row G is index 6 (A\u21920, B\u21921, \u2026, G\u21926)\n    g = ord('G') - ord('A')\n    # A ship\u2010tile is >0 in true_board; hidden is == -1 in partial_board.\n    mask = (true_board[g, :] > 0) & (partial_board[g, :] == -1)\n    return bool(mask.any())\n","name":"program_811","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Does it touch the red ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # find all the red\u2010ship coordinates\n    red_coords = np.argwhere(true_board == 1)\n    # find all still\u2010hidden ship tiles except red\n    #   hidden means partial_board == -1\n    #   ship means true_board > 0\n    #   except red means true_board != 1\n    hidden_ship = (partial_board == -1) & (true_board > 0) & (true_board != 1)\n    # for each red tile, check its four orthogonal neighbors\n    H, W = true_board.shape\n    for r, c in red_coords:\n        for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):\n            rr, cc = r+dr, c+dc\n            if 0 <= rr < H and 0 <= cc < W:\n                if hidden_ship[rr, cc]:\n                    return True\n    return False\n","name":"program_812","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all currently revealed ship\u2010hits on the captain's board\n    # (partial_board > 0 means a revealed ship tile).\n    hits = np.argwhere(partial_board > 0)\n    if hits.size == 0:\n        # No hits to determine orientation\n        return False\n\n    # Take the first hit as a reference point\n    r, c = hits[0]\n    ship_id = true_board[r, c]\n\n    # Check if the same ship id appears to the left or right\n    n_cols = true_board.shape[1]\n    if c - 1 >= 0 and true_board[r, c - 1] == ship_id:\n        return True\n    if c + 1 < n_cols and true_board[r, c + 1] == ship_id:\n        return True\n\n    # Otherwise it must be vertical (or isolated), so not horizontal\n    return False\n","name":"program_813","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"1-4 yes, 5-8 no","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the remaining (unrevealed) ship tiles all lie\n    within columns 1\u20134 (i.e. 0\u20133 in zero-based indexing).\n    \n    Captains question: \"1-4 yes, 5-8 no\"\n    \"\"\"\n    # Mask of ship cells in the true board that are still hidden in the partial board\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n    \n    # If there are no hidden ship cells, we default to False (no)\n    if not np.any(hidden_ships):\n        return False\n    \n    # Get the column indices of hidden ship cells (zero-based)\n    cols = np.where(hidden_ships)[1]\n    \n    # Return True only if all hidden ship cells are in columns 0\u20133 (i.e. 1\u20134)\n    return np.all(cols < 4)\n","name":"program_814","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"touching orange?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the as\u2010yet\u2010unrevealed (target) ship is touching the orange ship.\n    We infer the target ship as the one whose total cells in partial_board\n    is strictly less than in true_board.\n    \"\"\"\n    # Ship labels\n    ORANGE_LABEL = 4\n    SHIP_LABELS = [1, 2, 3, 4]\n\n    # Identify which ship(s) have unrevealed cells\n    remaining = []\n    for lbl in SHIP_LABELS:\n        total_cells = np.count_nonzero(true_board == lbl)\n        revealed_cells = np.count_nonzero(partial_board == lbl)\n        if revealed_cells < total_cells:\n            remaining.append(lbl)\n\n    # If there's more than one remaining ship, we assume the question\n    # refers to the unique unfinished target. If none or many, we default to False.\n    if len(remaining) != 1:\n        return False\n\n    target_label = remaining[0]\n\n    # Get coordinates of the target ship's tiles and the orange ship's tiles\n    tgt_coords = list(zip(*np.where(true_board == target_label)))\n    org_coords = list(zip(*np.where(true_board == ORANGE_LABEL)))\n\n    # Check for side adjacency (Manhattan distance == 1)\n    for tr, tc in tgt_coords:\n        for or_, oc in org_coords:\n            if abs(tr - or_) + abs(tc - oc) == 1:\n                return True\n\n    return False\n","name":"program_815","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any ships on the top half?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the row index that splits top half from bottom half\n    n_rows = true_board.shape[0]\n    mid = n_rows \/\/ 2  # for 8 rows, mid = 4 (rows 0..3 are top half)\n    \n    # Slice out the top half of both boards\n    top_true = true_board[:mid, :]\n    top_partial = partial_board[:mid, :]\n    \n    # A cell contains an unrevealed ship tile if:\n    #   - true_board > 0 (there is a ship)\n    #   - partial_board == -1 (it is still hidden)\n    unrevealed_ship_in_top = (top_true > 0) & (top_partial == -1)\n    \n    # If any such tile exists, answer \"Yes\"\n    return bool(np.any(unrevealed_ship_in_top))\n","name":"program_816","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any ships on the border?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    on the outer two\u2010tile border of the board, otherwise False.\n    \"\"\"\n    # Board size (assumed square)\n    n = true_board.shape[0]\n    \n    # Build a mask for the \"outer two layers\" (rows 0,1,n-2,n-1 or cols 0,1,n-2,n-1)\n    rows, cols = np.indices((n, n))\n    border_mask = (\n        (rows < 2) | (rows >= n - 2) |\n        (cols < 2) | (cols >= n - 2)\n    )\n    \n    # Mask of hidden ship tiles:\n    #   true_board > 0   \u2192 there is a ship\n    #   partial_board == -1 \u2192 tile still hidden\n    hidden_ship_mask = (true_board > 0) & (partial_board == -1)\n    \n    # If any hidden ship tile lies on the border, answer is True\n    return bool(np.any(border_mask & hidden_ship_mask))\n","name":"program_817","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the top half ship on the border?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if all still\u2010hidden ship tiles in the top half of the board\n    lie on the 2\u2010tile\u2010thick border; False otherwise.\n    \"\"\"\n    # Dimensions\n    n_rows, n_cols = true_board.shape\n\n    # 1) Find all still-hidden ship tiles:\n    #    a ship tile in true_board is >0, and it's still hidden if partial_board == -1\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n\n    # 2) Restrict to the top half (rows 0 .. n_rows\/\/2 - 1)\n    top_half_mask = np.zeros_like(hidden_ships, dtype=bool)\n    top_half_mask[0 : (n_rows \/\/ 2), :] = True\n    top_hidden = hidden_ships & top_half_mask\n\n    # If there are no hidden ship tiles in the top half, answer is False\n    if not top_hidden.any():\n        return False\n\n    # 3) Build a 2-layer border mask\n    #    border rows are 0,1 and n_rows-2, n_rows-1\n    #    border cols are 0,1 and n_cols-2, n_cols-1\n    border_rows = np.zeros(n_rows, dtype=bool)\n    border_rows[0:2] = True\n    border_rows[-2:] = True\n\n    border_cols = np.zeros(n_cols, dtype=bool)\n    border_cols[0:2] = True\n    border_cols[-2:] = True\n\n    border_mask = border_rows[:, None] | border_cols[None, :]\n\n    # 4) Check: are any top-half hidden ship tiles off the border?\n    #    If so, return False; otherwise True\n    off_border = top_hidden & (~border_mask)\n    return not off_border.any()\n","name":"program_818","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"1-4 = YES, 5-8 = NO","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one ship\u2010tile in columns 1\u20134\n    (0\u20133 in zero\u2010based indexing) that is still hidden on the partial_board.\n    Otherwise returns False.\n    \"\"\"\n    # Mask of all hidden cells\n    hidden = (partial_board == -1)\n    # Mask of all ship cells (any of 1,2,3,4)\n    ship_cells = (true_board > 0)\n    # Restrict both masks to columns 0\u20133 (i.e. 1\u20134 in human terms)\n    region_hidden_ships = hidden[:, :4] & ship_cells[:, :4]\n    # If any position in that region is both hidden and a ship, answer Yes (True)\n    return np.any(region_hidden_ships)\n","name":"program_819","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":": Are any ships in the middle? I.e ships not touching the outer 2 layers?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one ship (not yet fully revealed)\n    whose entire set of coordinates lies strictly within the \"middle\"\n    of the board (i.e. does not touch the outer two rows or outer two columns).\n    \"\"\"\n    n_rows, n_cols = true_board.shape\n    \n    # Define the inclusive bounds of the \"middle\" region\n    # Outer two layers are rows 0,1 and rows n_rows-2,n_rows-1,\n    # and similarly columns 0,1 and n_cols-2,n_cols-1.\n    r_min, r_max = 2, n_rows - 3\n    c_min, c_max = 2, n_cols - 3\n\n    # Find all ship IDs (1..4) present on the board\n    ship_ids = np.unique(true_board)\n    ship_ids = ship_ids[ship_ids > 0]\n\n    for ship_id in ship_ids:\n        # Get the list of coordinates occupied by this ship\n        coords = np.argwhere(true_board == ship_id)\n        \n        # Check if the ship is already fully revealed on partial_board\n        # (i.e. no tile of this ship remains hidden)\n        hidden_tiles = [partial_board[tuple(pt)] == -1 for pt in coords]\n        if not any(hidden_tiles):\n            # Ship is fully discovered; skip it\n            continue\n        \n        # Check if every tile of this ship lies within the middle region\n        rows, cols = coords[:, 0], coords[:, 1]\n        if np.all((rows >= r_min) & (rows <= r_max) &\n                  (cols >= c_min) & (cols <= c_max)):\n            return True\n\n    # No remaining ship is completely inside the middle\n    return False\n","name":"program_820","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any ships touching the border?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Build a mask for the border cells\n    border = np.zeros(true_board.shape, dtype=bool)\n    border[0, :]   = True\n    border[-1, :]  = True\n    border[:, 0]   = True\n    border[:, -1]  = True\n\n    # Find ship cells that are still hidden\n    hidden_ship_cells = (true_board > 0) & (partial_board == -1)\n\n    # Are there any hidden ship cells on the border?\n    return bool(np.any(hidden_ship_cells & border))\n","name":"program_821","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"What to focus on ? Top yes bottom no","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there are more unrevealed ship tiles in the top half of the board,\n    otherwise returns False (indicating the bottom half has as many or more).\n    \"\"\"\n    # Identify all ship cells on the true board (values > 0)\n    ship_cells = true_board > 0\n    \n    # Identify which of those ship cells remain hidden on the partial board (partial == -1)\n    hidden_ship_cells = ship_cells & (partial_board == -1)\n    \n    # Split into top half and bottom half\n    rows = true_board.shape[0]\n    half = rows \/\/ 2\n    top_hidden = hidden_ship_cells[:half, :].sum()\n    bottom_hidden = hidden_ship_cells[half:, :].sum()\n    \n    # If top half has more hidden ship cells, answer \"yes\" (True), otherwise \"no\" (False)\n    return top_hidden > bottom_hidden\n","name":"program_822","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Are any of the last 2 ships touching the ones we found?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if any unrevealed ship tile (in true_board but still hidden in partial_board)\n    is edge-adjacent to any already revealed ship tile in partial_board.\n    \"\"\"\n    # positions of already revealed ships\n    found_ships = np.argwhere(partial_board > 0)\n    # mask of remaining (hidden) ship tiles\n    remaining_ships = (true_board > 0) & (partial_board == -1)\n    max_row, max_col = partial_board.shape\n\n    # for each found ship tile, check its 4 neighbors\n    for r, c in found_ships:\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < max_row and 0 <= nc < max_col:\n                if remaining_ships[nr, nc]:\n                    return True\n    return False\n","name":"program_823","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"1-4 yes 5-8 no","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A tile is an unrevealed ship\u2010tile if it is >0 in true_board\n    # but still -1 in partial_board.\n    mask_unseen_ship = (true_board > 0) & (partial_board == -1)\n\n    # Columns 1\u20134 correspond to indices 0\u20133; columns 5\u20138 to indices 4\u20137.\n    left_has_ship  = mask_unseen_ship[:, 0:4].any()\n    right_has_ship = mask_unseen_ship[:, 4:8].any()\n\n    # We answer \u201cyes\u201d to 1\u20134 (i.e. left_has_ship must be True)\n    # and \u201cno\u201d to 5\u20138 (i.e. right_has_ship must be False).\n    return left_has_ship and not right_has_ship\n","name":"program_824","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any ships on the squares a-d and 1-4","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in the sub\u2010grid defined by rows A\u2013D (0\u20133) and columns 1\u20134 (0\u20133),\n    otherwise False.\n    \"\"\"\n    # Define the region A\u2013D and 1\u20134\n    rows = slice(0, 4)   # A\u2013D \u2192 indices 0,1,2,3\n    cols = slice(0, 4)   # 1\u20134 \u2192 indices 0,1,2,3\n\n    # Extract the corresponding sub\u2010boards\n    sub_true    = true_board[rows, cols]\n    sub_partial = partial_board[rows, cols]\n\n    # A tile counts if it is still hidden on the partial board\n    # and actually contains a ship on the true board.\n    hidden_mask = (sub_partial == -1)\n    ship_mask   = (sub_true > 0)\n\n    return bool(np.any(hidden_mask & ship_mask))\n","name":"program_825","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it in the h row yes or on 1 no","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # find positions that are still hidden (-1 in partial) but contain a ship (>0 in true)\n    unrevealed_ship = (partial_board == -1) & (true_board > 0)\n    \n    # row H is index 7 (0\u2192A, 1\u2192B, \u2026, 7\u2192H)\n    if np.any(unrevealed_ship[7, :]):\n        return True   # yes, there is at least one unrevealed ship cell in row H\n    \n    # column 1 is index 0\n    if np.any(unrevealed_ship[:, 0]):\n        return False  # no, but there is at least one unrevealed ship cell in column 1\n    \n    # if neither case applies, we default to False\n    return False\n","name":"program_826","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any ships on a-d 5-8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows A-D correspond to indices 0-3, columns 5-8 correspond to indices 4-7.\n    # We check for any ship cell (true_board > 0) in that region that is still hidden (partial_board == -1).\n    region_true   = true_board[0:4, 4:8]\n    region_partial = partial_board[0:4, 4:8]\n    # True if there's at least one ship tile not yet revealed in the region\n    return bool(np.any((region_true > 0) & (region_partial == -1)))\n","name":"program_827","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Vertical yes horizontal no","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find which ship IDs have been revealed so far\n    revealed_ids = np.unique(partial_board[partial_board > 0])\n    if revealed_ids.size == 0:\n        # No ship revealed yet; cannot determine orientation\n        return False\n\n    # Assume the question refers to the first revealed ship\n    ship_id = revealed_ids[0]\n    # Get all coordinates of that ship on the true board\n    coords = np.argwhere(true_board == ship_id)\n    # Separate into row indices and column indices\n    rows, cols = coords[:, 0], coords[:, 1]\n\n    # If all column indices are the same, it's vertical\n    if np.all(cols == cols[0]):\n        return True\n    # If all row indices are the same, it's horizontal\n    else:\n        return False\n","name":"program_828","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any other ship in the border?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is at least one unrevealed ship tile\n    touching the outer border of the board (row 0, row -1, col 0, or col -1),\n    excluding any tiles already revealed in partial_board.\n    \"\"\"\n    # Build a mask of border positions\n    border_mask = np.zeros_like(true_board, dtype=bool)\n    border_mask[0, :] = True\n    border_mask[-1, :] = True\n    border_mask[:, 0] = True\n    border_mask[:, -1] = True\n\n    # Mask of all currently hidden positions\n    hidden_mask = (partial_board == -1)\n\n    # Mask of ship positions in the true board\n    ship_mask = (true_board > 0)\n\n    # Any hidden ship tile that lies on the border?\n    return np.any(border_mask & hidden_mask & ship_mask)\n","name":"program_829","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the last ship on top yes bottom no","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the only remaining (unrevealed) ship is entirely within the\n    top half of the board (rows A\u2013D, i.e. indices 0\u20133), otherwise False.\n    \"\"\"\n    # Find all positions where there's a ship in true_board but it's still hidden\n    hidden_ship_tiles = (true_board > 0) & (partial_board == -1)\n    \n    # Get their row indices\n    rows, _ = np.where(hidden_ship_tiles)\n    \n    # If no hidden ship tiles remain, answer is False by default\n    if rows.size == 0:\n        return False\n    \n    # The \u201clast ship\u201d is on the top if all its tiles lie in rows 0\u20133\n    return np.all(rows < 4)\n","name":"program_830","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"1-4 YES 5-8 NO","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Captain\u2019s question: \u201c1-4 YES 5-8 NO\u201d\n    Return True if there is at least one unrevealed ship tile in columns 1\u20134 (indices 0\u20133),\n    otherwise return False.\n    \"\"\"\n    # A tile is an unrevealed ship segment if partial_board == -1 and true_board > 0\n    unrevealed_ships = (partial_board == -1) & (true_board > 0)\n    \n    # Check columns 1\u20134 (array indices 0\u20133)\n    return bool(np.any(unrevealed_ships[:, 0:4]))\n","name":"program_831","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"A-D yes E-H no","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in rows A\u2013D (i.e. row indices 0\u20133),\n    otherwise False.\n    \"\"\"\n    # A tile is an \u00abunrevealed ship tile\u00bb if true_board > 0 but partial_board == -1\n    ship_mask    = true_board > 0\n    hidden_mask  = partial_board == -1\n    # Combine masks to find all unrevealed ship positions\n    unrevealed   = ship_mask & hidden_mask\n\n    # Restrict to rows A\u2013D, which correspond to indices 0,1,2,3\n    # If any of those positions is True, return True; else False.\n    return bool(unrevealed[:4, :].any())\n","name":"program_832","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any ships in the G ?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row G corresponds to index 6 (A=0, B=1, \u2026, G=6)\n    row_idx = 6\n\n    # A ship tile is any true_board entry > 0\n    ship_mask = true_board[row_idx, :] > 0\n    # A hidden tile is any partial_board entry == -1\n    hidden_mask = partial_board[row_idx, :] == -1\n\n    # If there is at least one tile in row G that is a ship and still hidden, answer True\n    return bool(np.any(ship_mask & hidden_mask))\n","name":"program_833","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Top middle?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines whether there is any unrevealed ship tile in the \"top half\"\n    of the central 2\u00d72 block of the 8\u00d78 board.  By convention:\n       - Rows are 0-indexed so that row D is index 3.\n       - Columns are 0-indexed so that columns 4 and 5 are indices 3 and 4.\n    The \"middle\" 2\u00d72 block is:\n        D4 (3,3), D5 (3,4)\n        E4 (4,3), E5 (4,4)\n    The \"top middle\" refers to the two cells D4 and D5.\n    We return True if any of those two positions contain a ship (value > 0\n    in true_board) and are still hidden (value == -1 in partial_board).\n    \"\"\"\n    # slice out D4, D5\n    center_top = true_board[3, 3:5]\n    hidden_mask = partial_board[3, 3:5] == -1\n    \n    # is there any hidden cell in D4 or D5 that actually has a ship?\n    return bool(np.any((center_top > 0) & hidden_mask))\n","name":"program_834","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"3-4 yes, 5-6 no","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Captain's composite query:\n      - Are there any (unrevealed) ship tiles in columns 3\u20134?\n      - Are there any (unrevealed) ship tiles in columns 5\u20136?\n    And he wants the answer: \u201c3\u20134 yes, 5\u20136 no\u201d as one combined statement.\n    We therefore return True precisely when\n      (there is at least one unrevealed ship tile in cols 3\u20134)\n      AND\n      (there are no unrevealed ship tiles in cols 5\u20136).\n    \"\"\"\n    # Build a mask of unrevealed tiles\n    unrevealed = (partial_board == -1)\n    # Slice out columns 3\u20134 (1\u2010based indices \u2192 0\u2010based 2:4) and 5\u20136 (\u2192 4:6)\n    tb_3_4 = true_board[:, 2:4]\n    tb_5_6 = true_board[:, 4:6]\n    ur_3_4 = unrevealed[:, 2:4]\n    ur_5_6 = unrevealed[:, 4:6]\n\n    # Check for any unrevealed ship tiles (>0) in each slice\n    has_ship_3_4 = np.any((tb_3_4 > 0) & ur_3_4)\n    has_ship_5_6 = np.any((tb_5_6 > 0) & ur_5_6)\n\n    # Return True if cols 3-4 contain ships AND cols 5-6 contain none\n    return has_ship_3_4 and not has_ship_5_6\n","name":"program_835","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Any more BORDER ships?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is at least one still-hidden ship tile on the\n    outer border (top row, bottom row, left column, or right column).\n    \"\"\"\n    # Identify hidden tiles where true_board has a ship (>0)\n    hidden_ship = (true_board > 0) & (partial_board == -1)\n\n    # Build a mask for the border cells\n    border_mask = np.zeros_like(hidden_ship, dtype=bool)\n    # top and bottom rows\n    border_mask[0, :] = True\n    border_mask[-1, :] = True\n    # left and right columns\n    border_mask[:, 0] = True\n    border_mask[:, -1] = True\n\n    # Check if any hidden ship tile lies on the border\n    return bool(np.any(hidden_ship & border_mask))\n","name":"program_836","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Focus Top half = YES. Focus bottom half =NO","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in the top half\n    of the board (rows A\u2013D, i.e. indices 0\u20133), False otherwise.\n    \"\"\"\n    # Extract the top half of both boards (rows 0\u20133)\n    top_true = true_board[0:4, :]\n    top_partial = partial_board[0:4, :]\n\n    # A ship tile in true_board is > 0; an unrevealed tile in partial_board is -1\n    unrevealed_ship_in_top = (top_true > 0) & (top_partial == -1)\n\n    # If any True in that mask, return True; else False\n    return np.any(unrevealed_ship_in_top)\n","name":"program_837","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"ROW C?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'C' to its 0-based index\n    row_index = ord('C') - ord('A')\n    # Identify ship tiles in the true board on row C\n    ship_tiles = true_board[row_index, :] > 0\n    # Identify which of those ship tiles are still hidden in the partial board\n    still_hidden = partial_board[row_index, :] == -1\n    # If any ship tile in row C remains hidden, answer Yes (True), else No (False)\n    return bool(np.any(ship_tiles & still_hidden))\n","name":"program_838","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"ROW G?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row G corresponds to index 6 (A=0, B=1, \u2026, G=6)\n    row_index = ord('G') - ord('A')\n    # A ship tile is any positive entry in true_board (>0).\n    # We only care about those that remain hidden in partial_board (== -1).\n    unrevealed_ships_in_G = (true_board[row_index, :] > 0) & (partial_board[row_index, :] == -1)\n    return bool(np.any(unrevealed_ships_in_G))\n","name":"program_839","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"UP = YES   DOWN =NO","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the halfway point (rows 0 to half-1 are \"UP\", half to end are \"DOWN\")\n    half = true_board.shape[0] \/\/ 2\n\n    # Slice out the upper half of the board\n    upper_true = true_board[:half, :]\n    upper_partial = partial_board[:half, :]\n\n    # A tile is an unrevealed ship if:\n    #   true_board > 0  (there is a ship)\n    #   partial_board == -1  (it is still hidden)\n    unrevealed_ship_upper = (upper_true > 0) & (upper_partial == -1)\n\n    # If there is any unrevealed ship in the upper half, answer \"Yes\"\n    return bool(np.any(unrevealed_ship_upper))\n","name":"program_840","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Focus on outer 2 layers = Yes. Focus more on middle again = no","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    n = true_board.shape[0]\n    # build a matrix of ring-indices: distance to the nearest border\n    rows = np.arange(n)[:, None]\n    cols = np.arange(n)[None, :]\n    ring = np.minimum.reduce([rows, cols, (n - 1) - rows, (n - 1) - cols])\n    # select the \u201cmiddle\u201d ring = 2\n    middle_mask = (ring == 2)\n    # find any ship\u2010cells in true_board that are still hidden in partial_board\n    unrevealed_middle = (true_board > 0) & (partial_board == -1) & middle_mask\n    return bool(np.any(unrevealed_middle))\n","name":"program_841","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"THIS IF FOR MIDDLE: Bottom left = YES, Bottom RIGHT = NO","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    The Captain is asking about the bottom\u2010left and bottom\u2010right\n    quarters of the *middle* region of the board.\n    We interpret \"middle\" on an 8\u00d78 as the central 4\u00d74 block:\n      rows C,D,E,F (indices 2..5) and cols 3,4,5,6 (indices 2..5).\n    Then:\n      - bottom\u2010left of that 4\u00d74 is rows E,F (4,5) and cols 3,4 (2,3)\n      - bottom\u2010right is rows E,F (4,5) and cols 5,6 (4,5)\n    We return True iff there is at least one *hidden* ship tile\n    in the bottom\u2010left block and *no* hidden ship tiles in the bottom\u2010right.\n    \"\"\"\n    n = true_board.shape[0]\n    # define the central 4\u00d74 region\n    mid_start = n \/\/ 4          # 8\/\/4 = 2\n    mid_size  = n \/\/ 2          # 8\/\/2 = 4\n    half      = mid_size \/\/ 2   # 4\/\/2 = 2\n\n    # bottom rows of the middle block: indices 2+2 .. 2+4 => 4..5\n    row_slice = slice(mid_start + half, mid_start + mid_size)\n    # left columns of the middle block: indices 2 .. 2+2 => 2..3\n    left_col_slice  = slice(mid_start, mid_start + half)\n    # right columns of the middle block: indices 2+2 .. 2+4 => 4..5\n    right_col_slice = slice(mid_start + half, mid_start + mid_size)\n\n    # mask of hidden ship tiles (ship>0, partial==-1)\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n\n    # any hidden ship in bottom-left of middle?\n    bl_any = np.any(hidden_ships[row_slice, left_col_slice])\n    # any hidden ship in bottom-right of middle?\n    br_any = np.any(hidden_ships[row_slice, right_col_slice])\n\n    # The Captain's statement is \"bottom-left = YES, bottom-right = NO\"\n    # Return True if that is correct, False otherwise.\n    return bl_any and not br_any\n","name":"program_842","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row E?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the index for row 'E' (0-based: A=0, B=1, \u2026, E=4)\n    row_idx = ord('E') - ord('A')\n    \n    # In that row, find tiles that are ships in the true board (value > 0)\n    # but still hidden to the captain (partial_board == -1)\n    unrevealed_ships = (true_board[row_idx, :] > 0) & (partial_board[row_idx, :] == -1)\n    \n    # If any such tile exists, answer \"Yes\" (True), otherwise \"No\" (False)\n    return bool(np.any(unrevealed_ships))\n","name":"program_843","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"FOCUS TOP?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is at least one unrevealed ship segment\n    in the top half of the board, otherwise False.\n    \"\"\"\n    # Number of rows in the board\n    n_rows = true_board.shape[0]\n    # Define top half (rows 0 through n_rows\/\/2 - 1)\n    top_half_end = n_rows \/\/ 2\n    # Extract the top half of both boards\n    tb_top = true_board[:top_half_end, :]\n    pb_top = partial_board[:top_half_end, :]\n    # A ship segment is true_board > 0; unrevealed means partial_board == -1\n    unrevealed_ship_in_top = (tb_top > 0) & (pb_top == -1)\n    # If any such segment exists, focus top (answer \"Yes\")\n    return bool(np.any(unrevealed_ship_in_top))\n","name":"program_844","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the currently targeted (but not yet sunk) ship\n    is oriented vertically.\n\n    Args:\n        true_board (np.ndarray): The full board with ship IDs (1\u20134) and water (0).\n        partial_board (np.ndarray): The captain's view with revealed ship IDs,\n                                    water (0), and hidden (-1).\n\n    Returns:\n        bool: True if the in-progress ship is vertical, False otherwise.\n    \"\"\"\n    # Iterate over each ship ID (1=Red, 2=Green, 3=Purple, 4=Orange)\n    for ship_id in (1, 2, 3, 4):\n        # Count total tiles of this ship on the true board\n        total_tiles = np.count_nonzero(true_board == ship_id)\n        # Count how many of them have already been revealed\n        revealed_tiles = np.count_nonzero(partial_board == ship_id)\n\n        # We're interested in the ship that has been hit but not fully sunk\n        if 0 < revealed_tiles < total_tiles:\n            # Get the coordinates of all tiles of this ship\n            coords = np.argwhere(true_board == ship_id)\n            # Separate row indices and column indices\n            rows = np.unique(coords[:, 0])\n            cols = np.unique(coords[:, 1])\n\n            # If all columns are the same, the ship is vertical\n            return len(cols) == 1\n\n    # No partially hit ship found (shouldn't happen in normal play)\n    return False\n","name":"program_845","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"UNDER ORANGE SHIP = YES UNDER\/NEAR PURPLE SHIP = NO","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed ship tile either\n      1) anywhere below the orange ship, or\n      2) anywhere below or immediately adjacent to the purple ship.\n    Otherwise returns False.\n    \"\"\"\n    rows, cols = true_board.shape\n\n    # 1) Check \u201cunder\u201d the orange ship (any row strictly below each orange tile)\n    orange_cells = np.argwhere(true_board == 4)\n    for r, c in orange_cells:\n        if r + 1 < rows:\n            # cells in the same column but in rows > r\n            under_true = true_board[r+1:, c] > 0\n            under_hidden = partial_board[r+1:, c] == -1\n            if np.any(under_true & under_hidden):\n                return True\n\n    # 2) Check \u201cunder or near\u201d the purple ship\n    #    - \u201cunder\u201d = any row strictly below each purple tile in the same column\n    #    - \u201cnear\u201d = any of the 8 neighboring cells (Chebyshev distance = 1)\n    purple_cells = np.argwhere(true_board == 3)\n    for r, c in purple_cells:\n        # under\n        if r + 1 < rows:\n            under_true = true_board[r+1:, c] > 0\n            under_hidden = partial_board[r+1:, c] == -1\n            if np.any(under_true & under_hidden):\n                return True\n\n        # near (8 neighbors)\n        for dr in (-1, 0, 1):\n            for dc in (-1, 0, 1):\n                if dr == 0 and dc == 0:\n                    continue\n                rr, cc = r + dr, c + dc\n                if 0 <= rr < rows and 0 <= cc < cols:\n                    if true_board[rr, cc] > 0 and partial_board[rr, cc] == -1:\n                        return True\n\n    # If neither condition holds, answer is No\n    return False\n","name":"program_846","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":": Are any ships in the middle?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship\u2010tile in the central\n    4\u00d74 \u201cmiddle\u201d region of an 8\u00d78 board.  More generally, for an N\u00d7N board,\n    we take the middle half of the rows and columns:\n      rows  N\/\/4 .. 3N\/\/4 - 1\n      cols  N\/\/4 .. 3N\/\/4 - 1\n\n    A ship\u2010tile is \u2018\u2018unrevealed\u2019\u2019 if true_board > 0 but partial_board == -1.\n    \"\"\"\n    # assume square board\n    n, m = true_board.shape\n    # define the middle half of the indices\n    r_start, r_end = n \/\/ 4, (3 * n) \/\/ 4\n    c_start, c_end = m \/\/ 4, (3 * m) \/\/ 4\n\n    # slice out the central region\n    central_true   = true_board [r_start:r_end, c_start:c_end]\n    central_partial= partial_board[r_start:r_end, c_start:c_end]\n\n    # look for any ship tiles in true_board that remain hidden in partial_board\n    mask = (central_true > 0) & (central_partial == -1)\n    return bool(np.any(mask))\n","name":"program_847","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Focus on top yes focus on bottom no","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A tile is an unrevealed ship if true_board>0 but partial_board is still hidden (-1)\n    unrevealed = (true_board > 0) & (partial_board == -1)\n\n    # Determine the halfway point of the rows\n    nrows = true_board.shape[0]\n    half = nrows \/\/ 2\n\n    # Build a mask that is True for the top half of the rows\n    top_mask = np.zeros(nrows, dtype=bool)\n    top_mask[:half] = True  # rows 0 .. half-1 are the \"top\"\n\n    # Broadcast that mask across columns and check if any unrevealed ship is in the top half\n    top_unrevealed = unrevealed & top_mask[:, None]\n    return bool(np.any(top_unrevealed))\n","name":"program_848","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all revealed ship tiles on the partial board\n    revealed_positions = np.where(partial_board > 0)\n    if len(revealed_positions[0]) == 0:\n        # No ship has been hit yet, nothing to determine\n        return False\n\n    # Assume we're asking about the ship that has been hit\n    # Get the ship ID from one of the revealed tiles\n    ship_id = partial_board[revealed_positions][0]\n\n    # Locate all positions of that ship in the true board\n    ship_cells = np.where(true_board == ship_id)\n    rows, cols = ship_cells\n\n    # If all column indices are the same and there is more than one cell, it's vertical\n    is_vertical = (len(set(cols)) == 1) and (len(set(rows)) > 1)\n    return bool(is_vertical)\n","name":"program_849","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"1-4 yes 5-8 no","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed ship tile in rows A\u2013D (indices 0\u20133),\n    False otherwise. This answers the Captain's question \"1\u20134 yes, 5\u20138 no\",\n    where rows A\u2013D correspond to 1\u20134 and E\u2013H to 5\u20138.\n    \"\"\"\n    # A ship tile is any cell where true_board > 0.\n    # An unrevealed tile on the captain's view is partial_board == -1.\n    # We restrict our check to rows 0\u20133 (A\u2013D).\n    region = slice(0, 4)  # rows A\u2013D\n    hidden_ship_tiles = (true_board[region, :] > 0) & (partial_board[region, :] == -1)\n    return bool(np.any(hidden_ship_tiles))\n","name":"program_850","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Touching the borders","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed ship tile touching the border\n    of the board (first or last row, first or last column).\n    \"\"\"\n\n    # Find all cells that are ship in true_board but still hidden in partial_board\n    unrevealed_ships = (true_board > 0) & (partial_board == -1)\n\n    # If there are no unrevealed ship tiles at all, then return False\n    if not np.any(unrevealed_ships):\n        return False\n\n    # Get the board dimensions\n    n_rows, n_cols = true_board.shape\n\n    # Get the indices of all unrevealed ship tiles\n    rows, cols = np.where(unrevealed_ships)\n\n    # Check if any of those lie on the border\n    touching_border = (\n        (rows == 0) |\n        (rows == n_rows - 1) |\n        (cols == 0) |\n        (cols == n_cols - 1)\n    )\n\n    return np.any(touching_border)\n","name":"program_851","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row A?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row 'A' to index 0\n    row_index = 0\n    # A ship tile is > 0 in true_board. We only care about unrevealed tiles in partial_board (marked -1).\n    hidden_ship_tiles = (true_board[row_index, :] > 0) & (partial_board[row_index, :] == -1)\n    # If any hidden ship tile exists in row A, answer Yes (True), else No (False).\n    return np.any(hidden_ship_tiles)\n","name":"program_852","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the ship currently being targeted (i.e. partially revealed but not yet sunk)\n    is oriented vertically in the true_board.\n    \"\"\"\n    # Find which ship IDs have at least one hit on the partial board but are not yet fully revealed.\n    # Ship IDs are positive integers (1=Red, 2=Green, 3=Purple, 4=Orange).\n    for ship_id in np.unique(partial_board):\n        if ship_id <= 0:\n            continue\n        # Count total tiles of this ship on the true board\n        total_tiles = np.count_nonzero(true_board == ship_id)\n        # Count how many of them are already revealed on the partial board\n        revealed_tiles = np.count_nonzero(partial_board == ship_id)\n        # If it's partially revealed (at least one hit, but not all), this is the ship in question\n        if 0 < revealed_tiles < total_tiles:\n            # Get the coordinates of all tiles of this ship in the true board\n            coords = np.argwhere(true_board == ship_id)\n            rows, cols = coords[:, 0], coords[:, 1]\n            # If all columns are the same and rows vary, it's vertical\n            if np.unique(cols).size == 1 and np.unique(rows).size > 1:\n                return True\n            # If all rows are the same and columns vary, it's horizontal\n            if np.unique(rows).size == 1 and np.unique(cols).size > 1:\n                return False\n            # In degenerate cases (e.g. ship length 1), default to False\n            return False\n\n    # If no partially revealed ship is found, default to False\n    return False\n","name":"program_853","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"The ships touching","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    rows, cols = true_board.shape\n    # Iterate over every cell\n    for r in range(rows):\n        for c in range(cols):\n            ship_id = true_board[r, c]\n            # only interested in ship tiles (>0)\n            if ship_id > 0:\n                # check all 8 neighbors\n                for dr in (-1, 0, 1):\n                    for dc in (-1, 0, 1):\n                        if dr == 0 and dc == 0:\n                            continue\n                        nr, nc = r + dr, c + dc\n                        if 0 <= nr < rows and 0 <= nc < cols:\n                            neighbor_id = true_board[nr, nc]\n                            # if neighbor is a ship and a different ship\n                            if neighbor_id > 0 and neighbor_id != ship_id:\n                                return True\n    return False\n","name":"program_854","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Focus on top yes focus on bottom no","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there are any unrevealed ship tiles in the top half of the board\n    (rows A\u2013D, i.e. indices 0\u20133), otherwise False.\n    \"\"\"\n    # Slice out the top half of both boards (rows 0 through 3)\n    top_true = true_board[:4, :]\n    top_partial = partial_board[:4, :]\n    # A hidden ship tile is one where true_board > 0 and partial_board == -1\n    hidden_ships_top = (top_true > 0) & (top_partial == -1)\n    return bool(np.any(hidden_ships_top))\n","name":"program_855","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Top of ship yes bottom no","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # number of rows\n    nrows = true_board.shape[0]\n    # split roughly in half; top half is rows [0 .. nrows\/\/2-1]\n    top_slice = slice(0, nrows \/\/ 2)\n    # a ship\u2010segment is true_board>0; unrevealed means partial_board == -1\n    top_unrevealed = (true_board[top_slice] > 0) & (partial_board[top_slice] == -1)\n    # if any such segment exists in the top half, answer \"yes\" (True)\n    return bool(np.any(top_unrevealed))\n","name":"program_856","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Vertical ?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine if the ship currently being probed on the partial_board\n    is oriented vertically. We do this by finding any ship ID on the\n    partial_board with more than one revealed tile and checking whether\n    those tiles all lie in the same column.\n    \"\"\"\n    # Find all revealed ship IDs\n    revealed_ids = np.unique(partial_board[partial_board > 0])\n    for ship_id in revealed_ids:\n        # Get coordinates of all revealed tiles of this ship\n        coords = np.argwhere(partial_board == ship_id)\n        if coords.shape[0] > 1:\n            # coords[:,0] are row indices, coords[:,1] are column indices\n            # If all column indices are the same, it's vertical\n            if np.all(coords[:, 1] == coords[0, 1]):\n                return True\n            else:\n                return False\n    # If there's no multi\u2010tile reveal yet, we can't conclude vertical\n    return False\n","name":"program_857","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the row even?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is at least one unrevealed ship tile on an even\u2010numbered row\n    (i.e. row 2, 4, 6, or 8), otherwise False.\n    \"\"\"\n    # A mask of all hidden ship positions:\n    #   true_board > 0   picks up ship tiles\n    #   partial_board == -1  picks up still-hidden tiles\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n    \n    if not np.any(hidden_ships):\n        # No hidden ships left at all\n        return False\n    \n    # Get the row indices (0-based) of those hidden ship cells\n    rows, _ = np.nonzero(hidden_ships)\n    \n    # Convert to 1-based row numbers and test for evenness\n    # e.g. row index 1 -> row \"2\" (even)\n    even_row_mask = ((rows + 1) % 2 == 0)\n    \n    return bool(np.any(even_row_mask))\n","name":"program_858","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"6?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in column 6 (1-based),\n    i.e. index 5 in 0-based numpy indexing.\n    \"\"\"\n    # 1) Identify ship tiles on the true board\n    ship_tiles = true_board > 0\n    \n    # 2) Identify tiles still hidden on the partial board\n    hidden_tiles = partial_board == -1\n    \n    # 3) Combine masks and look at column 6 (0-based index 5)\n    col6_mask = ship_tiles & hidden_tiles\n    return bool(np.any(col6_mask[:, 5]))\n","name":"program_859","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship at 5E?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # The Captain asked about tile 5E, i.e. row E (index 4), column 5 (index 4)\n    row_idx = 4  # E -> 0-based index 4\n    col_idx = 4  # 5 -> 0-based index 4\n    # There's a ship if the true_board at that position is nonzero\n    return true_board[row_idx, col_idx] != 0\n","name":"program_860","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship at 2B","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Captain asked: is there a ship at 2B?\n    Rows are A\u2013H (0\u20137), columns are 1\u20138 (0\u20137), so \"B2\" \u2192 row index 1, col index 1.\n    \"\"\"\n    row_idx = ord('B') - ord('A')     # 'B' \u2192 1\n    col_idx = 2 - 1                   # column 2 \u2192 index 1\n    # Check the true board: any ship is indicated by a value > 0\n    return true_board[row_idx, col_idx] > 0\n","name":"program_861","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there ships in line F","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the row index for 'F'\n    row_idx = ord('F') - ord('A')  # 'A'->0, 'B'->1, ..., 'F'->5\n    \n    # A ship tile is any true_board cell > 0\n    # We only care about those not yet revealed, i.e., partial_board == -1\n    hidden_ships_in_F = (true_board[row_idx, :] > 0) & (partial_board[row_idx, :] == -1)\n    \n    # If there's any such cell, answer is True (Yes), otherwise False (No)\n    return bool(np.any(hidden_ships_in_F))\n","name":"program_862","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there ships in column A","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map the letter \"A\" to row index 0 (since rows are A\u2013H \u2192 0\u20137),\n    # but the question asks about column \"A\", which in this variant means\n    # the first column of the board.\n    col_idx = 0\n    \n    # A ship tile is any cell in true_board > 0\n    ship_tiles = true_board[:, col_idx] > 0\n    # An unrevealed tile is any cell in partial_board == -1\n    unrevealed = partial_board[:, col_idx] == -1\n    \n    # If there's any cell in column A that is both a ship in true_board\n    # and still hidden in partial_board, return True, else False.\n    return bool(np.any(ship_tiles & unrevealed))\n","name":"program_863","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are any other ships horixontal","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if any of the ships that are not yet fully revealed \n    (i.e., have at least one hidden tile) are placed horizontally.\n    \"\"\"\n    # Ship IDs are 1 through 4\n    for ship_id in (1, 2, 3, 4):\n        # Get all coordinates of this ship on the true board\n        coords = np.argwhere(true_board == ship_id)\n        if coords.size == 0:\n            # No such ship on the board (shouldn't happen in a valid game)\n            continue\n\n        # Check which of these coordinates are still hidden in the partial view\n        hidden_mask = partial_board[coords[:, 0], coords[:, 1]] == -1\n\n        # If the ship is already fully revealed, skip it\n        if not np.any(hidden_mask):\n            continue\n\n        # For a horizontal ship, all row indices are the same and there is more than one column\n        rows = coords[:, 0]\n        cols = coords[:, 1]\n        if np.all(rows == rows[0]) and cols.ptp() >= 1:\n            return True\n\n    # No remaining (partially hidden) ship is horizontal\n    return False\n","name":"program_864","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there ships in any even numbered columns","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine which columns are even-numbered (2, 4, 6, 8 in 1-based indexing).\n    # In 0-based indexing, these are columns with index 1, 3, 5, 7.\n    even_col_mask = (np.arange(true_board.shape[1]) + 1) % 2 == 0\n\n    # Build a mask of ship tiles in true_board (values > 0)\n    # that remain hidden in partial_board (value == -1)\n    # and lie in even-numbered columns.\n    hidden_ship_in_even = (\n        (true_board > 0)\n        & (partial_board == -1)\n        & even_col_mask[np.newaxis, :]\n    )\n\n    # If any such tile exists, answer is True (Yes), otherwise False (No).\n    return bool(np.any(hidden_ship_in_even))\n","name":"program_865","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship in column 4","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Column 4 corresponds to index 3 in zero-based indexing\n    col_idx = 3\n    # A ship tile is any cell > 0 in true_board\n    # We only care about ship tiles that remain hidden (partial_board == -1)\n    hidden_ship_in_col = (true_board[:, col_idx] > 0) & (partial_board[:, col_idx] == -1)\n    return np.any(hidden_ship_in_col)\n","name":"program_866","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it on line C","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to know if there is any still\u2010hidden ship segment on row C.\n    # Map row letter 'C' to index 2 (0-based indexing: A\u21920, B\u21921, C\u21922, \u2026).\n    row_idx = ord('C') - ord('A')\n    \n    # Extract that row from both boards\n    true_row = true_board[row_idx, :]\n    partial_row = partial_board[row_idx, :]\n    \n    # A ship segment on the true board is any value > 0.\n    ship_mask = true_row > 0\n    # An unrevealed tile on the partial board is marked -1.\n    hidden_mask = partial_row == -1\n    \n    # If there exists a position on row C that is both a ship segment\n    # and still hidden, answer \"Yes\" (True); otherwise \"No\" (False).\n    return bool(np.any(ship_mask & hidden_mask))\n","name":"program_867","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"was your last answer wong?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    The last question was \"is it on line C?\" and I answered 'Yes'.\n    That answer would be wrong if and only if there are no unrevealed\n    ship\u2010parts in row C.  Here row C is index 2 (0-based).  We check\n    in the true board for any ship tiles (>0) that remain hidden in\n    the partial board (marked as -1).  If none remain, my last answer\n    was wrong (return True), otherwise it was correct (return False).\n    \"\"\"\n    row_idx = 2  # row C\n    # mask of positions in row C that are still hidden on the partial board\n    hidden = partial_board[row_idx] == -1\n    # mask of positions in row C that contain a ship in the true board\n    ship   = true_board[row_idx] > 0\n    # any unrevealed ship\u2010part in that row?\n    unrevealed_ship_here = np.any(hidden & ship)\n    # My last answer was wrong exactly when there is NO unrevealed ship on C\n    return not unrevealed_ship_here\n","name":"program_868","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship in column 4","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determines if there is any unrevealed ship tile in column 4.\n    Columns are 1-indexed in the question, so column 4 corresponds to index 3.\n    An unrevealed ship tile is one where true_board has a value > 0\n    and partial_board has a value of -1 at the same position.\n    \"\"\"\n    col_idx = 4 - 1  # zero\u2010based index for column 4\n    # Create a boolean mask of where there are ships in true_board\n    ships_in_col = true_board[:, col_idx] > 0\n    # Create a boolean mask of where those positions are still hidden\n    hidden_in_col = partial_board[:, col_idx] == -1\n    # If any position has both a ship and is hidden, return True\n    return bool(np.any(ships_in_col & hidden_in_col))\n","name":"program_869","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it vertical","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # 1) Identify the column the Captain has been probing by looking\n    #    at the revealed misses (0s) in the partial_board.\n    miss_rows, miss_cols = np.where(partial_board == 0)\n    if miss_cols.size == 0:\n        # No misses revealed yet; no basis to decide orientation.\n        return False\n\n    # If all misses fall in the same column, that's our column of interest.\n    # Otherwise pick the column with the most misses.\n    unique_cols, counts = np.unique(miss_cols, return_counts=True)\n    col_of_interest = unique_cols[np.argmax(counts)]\n\n    # 2) In that column, find any unrevealed ship tile (partial_board == -1\n    #    & true_board > 0).  Those are the still-hidden ship positions.\n    mask_unseen_ship = (\n        (true_board > 0) &\n        (partial_board == -1) &\n        (np.arange(true_board.shape[1])[None, :] == col_of_interest)\n    )\n    coords = np.argwhere(mask_unseen_ship)\n    if coords.size == 0:\n        # All ships in that column (if any) have been revealed or sunk.\n        return False\n\n    # 3) Pick one of those unrevealed-ship coordinates to identify the ship ID.\n    r, c = coords[0]\n    ship_id = true_board[r, c]\n\n    # 4) Gather all tiles belonging to that ship, then check their orientation.\n    ship_tiles = np.argwhere(true_board == ship_id)\n    # If all their column indices are equal, it's vertical.\n    is_vertical = np.all(ship_tiles[:, 1] == ship_tiles[0, 1])\n    return bool(is_vertical)\n","name":"program_870","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it in 4G","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # The question is asking about coordinate 4G, i.e. column 4, row G.\n    # Convert row 'G' -> index 6 (0-based), column 4 -> index 3 (0-based).\n    row = ord('G') - ord('A')\n    col = 4 - 1\n    # It's a 'yes' if there's an unrevealed ship tile at that location.\n    return (partial_board[row, col] == -1) and (true_board[row, col] != 0)\n","name":"program_871","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the last ship in column 7","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify all ship IDs (positive integers) on the true board\n    ships = np.unique(true_board)\n    ships = ships[ships > 0]  # ignore water (0) and hidden (-1)\n    \n    # Find which ships still have at least one hidden tile\n    remaining = []\n    for s in ships:\n        ship_cells = (true_board == s)\n        # A tile is \"hidden\" on the partial board if it is -1\n        if np.any(ship_cells & (partial_board == -1)):\n            remaining.append(s)\n    \n    # If there's exactly one ship left, check if any of its tiles lie in column 7\n    if len(remaining) == 1:\n        last_ship_id = remaining[0]\n        # Column 7 has index 6\n        return bool(np.any(true_board[:, 6] == last_ship_id))\n    \n    # If there's not exactly one ship left, we cannot unambiguously answer \"the last ship\"\n    return False\n","name":"program_872","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it in column 1","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify which ship IDs are not yet fully revealed\n    remaining_ships = []\n    for ship_id in [1, 2, 3, 4]:\n        total_tiles = np.count_nonzero(true_board == ship_id)\n        revealed_tiles = np.count_nonzero(partial_board == ship_id)\n        if revealed_tiles < total_tiles:\n            remaining_ships.append(ship_id)\n\n    # If for some reason no ships remain, answer False\n    if not remaining_ships:\n        return False\n\n    # Build a mask of all tiles belonging to the remaining ships\n    mask = np.isin(true_board, remaining_ships)\n    \n    # Columns are 0-based in the array; column 1 is index 0\n    return np.any(mask[:, 0])\n","name":"program_873","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Row G? or B?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map rows A\u2013H to indices 0\u20137; B is 1, G is 6\n    rows_to_check = [1, 6]\n    # An unrevealed ship tile is where true_board > 0 but partial_board == -1\n    mask = (true_board > 0) & (partial_board == -1)\n    # Return True if any such tile exists in row B or G\n    return bool(np.any(mask[rows_to_check, :]))\n","name":"program_874","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship in column 1 or column 8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed ship tile in column 1 or column 8\n    (i.e., in the first or last column of the board), otherwise False.\n    \"\"\"\n    # zero\u2010based indices for column 1 and column 8\n    cols_to_check = [0, partial_board.shape[1] - 1]\n\n    for c in cols_to_check:\n        # mask of unrevealed ship tiles in column c\n        unrevealed_ship = (true_board[:, c] > 0) & (partial_board[:, c] == -1)\n        if np.any(unrevealed_ship):\n            return True\n\n    return False\n","name":"program_875","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship in G1 or G3?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert row letter 'G' to index 6 (A\u21920, B\u21921, \u2026, H\u21927)\n    row_idx = ord('G') - ord('A')\n    # Columns 1 and 3 correspond to indices 0 and 2\n    col1_idx = 1 - 1\n    col3_idx = 3 - 1\n\n    # Check if there's an unrevealed ship tile at G1\n    if true_board[row_idx, col1_idx] != 0 and partial_board[row_idx, col1_idx] == -1:\n        return True\n    # Check if there's an unrevealed ship tile at G3\n    if true_board[row_idx, col3_idx] != 0 and partial_board[row_idx, col3_idx] == -1:\n        return True\n\n    # Neither square has an (unrevealed) ship\n    return False\n","name":"program_876","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship in row A or H?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letters A\u2013H to indices 0\u20137.\n    # We want to know if there's any unrevealed ship tile in row A (index 0) or row H (index 7).\n    rows_to_check = [0, true_board.shape[0] - 1]  # [0, 7] for an 8\u00d78 board\n\n    # A tile is an \"unrevealed ship\" if true_board > 0 and partial_board == -1.\n    unrevealed_ships = (true_board > 0) & (partial_board == -1)\n\n    # If any unrevealed ship appears in either row A or row H, answer True.\n    return bool(np.any(unrevealed_ships[rows_to_check, :]))\n","name":"program_877","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the ship in column 1 or 8 vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if any ship that occupies column 1 or column 8\n    (indices 0 or 7) is oriented vertically, otherwise False.\n    \"\"\"\n    # columns of interest (0-based)\n    target_cols = [0, 7]\n\n    # find the set of ship IDs that occupy either column 1 or 8\n    ship_ids = set()\n    for c in target_cols:\n        ids_in_col = np.unique(true_board[:, c])\n        for ship_id in ids_in_col:\n            if ship_id > 0:\n                ship_ids.add(ship_id)\n\n    # if no ship touches those columns, answer is False\n    if not ship_ids:\n        return False\n\n    # for each such ship, check if all its tiles lie in a single column\n    for ship_id in ship_ids:\n        rows, cols = np.where(true_board == ship_id)\n        # vertical if all column indices are the same\n        if np.all(cols == cols[0]):\n            return True\n\n    # if none are vertical, return False\n    return False\n","name":"program_878","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship in E1 E2 F1 or F2?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one (still hidden) ship tile\n    in the set of coordinates E1, E2, F1, F2; otherwise False.\n    \"\"\"\n    # Map rows A\u2013H to indices 0\u20137\n    # E -> 4, F -> 5; columns 1,2 -> indices 0,1\n    coords = [(4, 0),  # E1\n              (4, 1),  # E2\n              (5, 0),  # F1\n              (5, 1)]  # F2\n\n    for r, c in coords:\n        # Check that the tile is still hidden in partial_board\n        # and that it actually contains a ship in true_board\n        if partial_board[r, c] == -1 and true_board[r, c] != 0:\n            return True\n\n    return False\n","name":"program_879","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a horizontal ship in rows B or C?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed horizontally oriented ship\n    segment in row B or row C (indices 1 or 2), otherwise False.\n    \"\"\"\n    # Rows B and C correspond to indices 1 and 2\n    target_rows = [1, 2]\n\n    for r in target_rows:\n        row = true_board[r]\n        n = row.shape[0]\n        c = 0\n        # Scan across the row looking for contiguous non\u2010zero runs\n        while c < n:\n            if row[c] != 0:\n                ship_id = row[c]\n                start = c\n                # advance until the ship_id run ends\n                while c < n and row[c] == ship_id:\n                    c += 1\n                length = c - start\n                # any run of length >= 2 is a horizontal ship\n                if length >= 2:\n                    # check if at least one cell in that run is still hidden\n                    segment = partial_board[r, start:c]\n                    # if not all cells in partial_board are revealed as ship_id,\n                    # then there's at least one hidden part\n                    if not np.all(segment == ship_id):\n                        return True\n            else:\n                c += 1\n\n    return False\n","name":"program_880","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"does the ship start in column 1?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any horizontal ship in rows B or C (0-based rows 1 or 2)\n    whose leftmost (starting) cell lies in column 1 (0-based column 0), else False.\n    \"\"\"\n    # We are interested in rows B and C => indices 1 and 2\n    target_rows = [1, 2]\n    n_cols = true_board.shape[1]\n    \n    for r in target_rows:\n        row = true_board[r]\n        c = 0\n        while c < n_cols:\n            # If we see the start of a ship segment\n            if row[c] > 0:\n                ship_id = row[c]\n                start_c = c\n                # Walk until the end of this contiguous horizontal segment\n                while c + 1 < n_cols and row[c + 1] == ship_id:\n                    c += 1\n                # Check if this ship segment starts at column 1 (index 0)\n                if start_c == 0:\n                    return True\n            c += 1\n\n    return False\n","name":"program_881","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there more ships in the lower left quadrant?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # compute the \u201chalf\u2010way\u201d splits\n    n_rows, n_cols = true_board.shape\n    row_mid = n_rows \/\/ 2\n    col_mid = n_cols \/\/ 2\n\n    # slice out the lower\u2010left quadrant\n    lower_left_true    = true_board[row_mid:, :col_mid]\n    lower_left_partial = partial_board[row_mid:, :col_mid]\n\n    # a \u201cstill\u2010hidden ship cell\u201d is one where true_board>0 (a ship)\n    # but partial_board is still -1 (hidden)\n    hidden_ship_mask = (lower_left_true > 0) & (lower_left_partial == -1)\n\n    return bool(np.any(hidden_ship_mask))\n","name":"program_882","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship in the top left quadrant?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in the top-left 4\u00d74 quadrant (rows A\u2013D, columns 1\u20134), otherwise False.\n    \"\"\"\n    # Define the slice for the top-left quadrant: rows 0\u20133, columns 0\u20133\n    quad_slice = np.s_[:4, :4]\n    \n    # A ship tile in true_board is > 0. A hidden tile in partial_board is -1.\n    # We only care about ship tiles that are still hidden.\n    hidden_ship_tiles = (true_board[quad_slice] > 0) & (partial_board[quad_slice] == -1)\n    \n    # If any such tile exists, answer is Yes (True); otherwise No (False).\n    return bool(np.any(hidden_ship_tiles))\n","name":"program_883","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship in row c??","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Determine the index for row C (0-based: A\u21920, B\u21921, C\u21922, \u2026)\n    row_idx = ord('C') - ord('A')\n    # A ship tile in the true_board is any value > 0.\n    # A hidden tile in partial_board is marked as -1.\n    # We're looking for any hidden ship tiles in row C.\n    hidden_tiles = (partial_board[row_idx, :] == -1)\n    ship_tiles   = (true_board[row_idx,    :] > 0)\n    # If there's any position where both are True, there's an unrevealed ship in row C.\n    return bool(np.any(hidden_tiles & ship_tiles))\n","name":"program_884","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship in row g in the lower right quadrant?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any *unrevealed* ship tile in row G\n    within the lower-right quadrant (rows E\u2013H, columns 5\u20138), otherwise False.\n    \"\"\"\n    # Map row letter 'G' to a zero-based index: A\u21920, B\u21921, \u2026, G\u21926\n    row_index = ord('G') - ord('A')\n    \n    # For an 8\u00d78 board, the \"lower-right quadrant\" is rows 4\u20137 (E\u2013H)\n    # and columns 4\u20137 (5\u20138).  We only care about row G \u2192 index 6,\n    # so we slice columns 4 through the end.\n    col_start = true_board.shape[1] \/\/ 2  # 8 \/\/ 2 = 4\n    \n    # Extract the relevant slice from both boards\n    true_slice    = true_board   [row_index, col_start:]\n    partial_slice = partial_board[row_index, col_start:]\n    \n    # A cell contains an *unrevealed* ship tile if:\n    #   1) true_board > 0 (there is actually a ship)\n    #   2) partial_board == -1 (it is still hidden)\n    unrevealed_ship_mask = (true_slice > 0) & (partial_slice == -1)\n    \n    # If any such cell exists, answer \"Yes\" (True), otherwise \"No\" (False)\n    return bool(np.any(unrevealed_ship_mask))\n","name":"program_885","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"row b?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letters to indices: A\u21920, B\u21921, \u2026\n    row_index = 1  # Row B\n    # A tile is an unrevealed ship tile if partial_board==-1 and true_board>0\n    unrevealed = (partial_board[row_index] == -1)\n    ship_tiles = (true_board[row_index] > 0)\n    return np.any(unrevealed & ship_tiles)\n","name":"program_886","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there any other ships column 8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to know if there are any *unrevealed* ship tiles\n    # in column 8 (0-based index 7).\n    col_idx = 7\n    \n    # A tile is a ship if true_board > 0.\n    ship_mask = true_board[:, col_idx] > 0\n    \n    # A tile is still hidden if partial_board == -1.\n    hidden_mask = partial_board[:, col_idx] == -1\n    \n    # If there exists any position in column 8 that is both\n    # a ship in the true board and still hidden in the partial board,\n    # then the answer is True.\n    return bool(np.any(ship_mask & hidden_mask))\n","name":"program_887","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there ships in all 4 quadrants? (sorry i made a mistake before)","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in each of the\n    four quadrants (NW, NE, SW, SE), False otherwise.\n    \"\"\"\n    rows, cols = true_board.shape\n    mid_r, mid_c = rows \/\/ 2, cols \/\/ 2\n\n    # Define the four quadrants as (row_slice, col_slice)\n    quadrants = [\n        (slice(0,   mid_r), slice(0,   mid_c)),  # NW\n        (slice(0,   mid_r), slice(mid_c, cols)), # NE\n        (slice(mid_r, rows), slice(0,   mid_c)), # SW\n        (slice(mid_r, rows), slice(mid_c, cols)) # SE\n    ]\n\n    for r_slice, c_slice in quadrants:\n        sub_true    = true_board[r_slice, c_slice]\n        sub_partial = partial_board[r_slice, c_slice]\n\n        # An unrevealed ship tile is a cell where true_board > 0 and partial_board == -1\n        if not np.any((sub_true > 0) & (sub_partial == -1)):\n            # No unrevealed ship tiles in this quadrant\n            return False\n\n    # Every quadrant contains at least one unrevealed ship tile\n    return True\n","name":"program_888","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are all ships horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if every ship on true_board is placed horizontally,\n    i.e., all tiles of each ship share the same row index.\n    \"\"\"\n    # Ship IDs are 1 (Red), 2 (Green), 3 (Purple), 4 (Orange)\n    for ship_id in (1, 2, 3, 4):\n        # Get the coordinates of all tiles belonging to this ship\n        coords = np.argwhere(true_board == ship_id)\n        if coords.size == 0:\n            # Ship not present (shouldn't happen in a valid game), skip\n            continue\n        # Extract the row indices\n        rows = coords[:, 0]\n        # If there's more than one unique row, the ship is not purely horizontal\n        if np.unique(rows).size > 1:\n            return False\n    # All ships were found to lie in a single row\n    return True\n","name":"program_889","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are all ships vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if and only if every ship on true_board is oriented vertically.\n    Ships are indicated by positive integers; water is 0.\n    We ignore partial_board here because orientation only depends on true_board.\n    \"\"\"\n    # find all ship IDs (>0)\n    ship_ids = np.unique(true_board)\n    ship_ids = ship_ids[ship_ids > 0]\n    \n    for ship in ship_ids:\n        # get the coordinates of this ship's tiles\n        coords = np.argwhere(true_board == ship)\n        # cols = coords[:,1], rows = coords[:,0]\n        # if a ship spans more than one column, it's not purely vertical\n        if len(np.unique(coords[:, 1])) > 1:\n            return False\n    \n    return True\n","name":"program_890","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there other ships in the upper or lower right quadrants?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there are any *other* unrevealed ship tiles\n    (i.e., true_board > 0 and partial_board == -1) in either\n    the upper-right or lower-right quadrant of the board.\n    \"\"\"\n    # Identify hidden squares on the partial board\n    hidden = (partial_board == -1)\n    # Identify all ship squares on the true board\n    ship    = (true_board > 0)\n    \n    # Determine board size and the halfway point\n    rows, cols = true_board.shape\n    half_row   = rows \/\/ 2\n    half_col   = cols \/\/ 2\n    \n    # Build masks for the two right\u2010hand quadrants\n    upper_right = np.zeros_like(true_board, dtype=bool)\n    lower_right = np.zeros_like(true_board, dtype=bool)\n    \n    # Upper\u2010right: rows [0..half_row-1], cols [half_col..cols-1]\n    upper_right[0:half_row, half_col:cols] = True\n    # Lower\u2010right: rows [half_row..rows-1], cols [half_col..cols-1]\n    lower_right[half_row:rows, half_col:cols] = True\n    \n    # Combine masks: hidden ship squares in either right quadrant\n    candidate_tiles = hidden & ship & (upper_right | lower_right)\n    \n    # If any such tile exists, answer is True (\"Yes\"), else False (\"No\")\n    return bool(np.any(candidate_tiles))\n","name":"program_891","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are any ships touching\/alongside each other","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if any two different ships on the true_board\n    share an edge (i.e., are touching side\u2010by\u2010side).\n    \"\"\"\n    rows, cols = true_board.shape\n    # Only care about orthogonal adjacency, so check right and down neighbors\n    for i in range(rows):\n        for j in range(cols):\n            ship_id = true_board[i, j]\n            if ship_id > 0:\n                # check right neighbor\n                if j + 1 < cols:\n                    neighbor = true_board[i, j + 1]\n                    if neighbor > 0 and neighbor != ship_id:\n                        return True\n                # check down neighbor\n                if i + 1 < rows:\n                    neighbor = true_board[i + 1, j]\n                    if neighbor > 0 and neighbor != ship_id:\n                        return True\n    return False\n","name":"program_892","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are they in column 8","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Check column 8 (index 7). We want to know if there is any ship tile in that column\n    # that is still hidden on the partial board.\n    col_index = 7\n    # A ship tile in true_board is indicated by a value > 0.\n    ship_mask = true_board[:, col_index] > 0\n    # A hidden tile in partial_board is indicated by -1.\n    hidden_mask = partial_board[:, col_index] == -1\n    # If there is any position where both masks are True, there is an unrevealed ship tile\n    # in column 8.\n    return bool(np.any(ship_mask & hidden_mask))\n","name":"program_893","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship at B2","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map the row letter 'B' to index 1 (0-based) and column '2' to index 1\n    row_idx = ord('B') - ord('A')     # 'A'->0, 'B'->1, ...\n    col_idx = int('2') - 1            # '1'->0, '2'->1, ...\n    \n    # Return True if the true board has a ship (>0) at that position\n    return bool(true_board[row_idx, col_idx] > 0)\n","name":"program_894","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there ships in even and odd columns","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # A tile is an unrevealed ship tile if\n    #   true_board > 0  (there is a ship)\n    # and\n    #   partial_board == -1  (it has not yet been revealed)\n    unrevealed_ships = (true_board > 0) & (partial_board == -1)\n\n    # If there are no unrevealed ship tiles at all, answer is False.\n    if not unrevealed_ships.any():\n        return False\n\n    # Find which columns (0-based) contain at least one unrevealed ship tile\n    cols_with_ships = np.where(unrevealed_ships.any(axis=0))[0]  # array of column\u2010indices\n\n    # Convert to 1-based column numbers, then check parity\n    col_numbers = cols_with_ships + 1\n    has_odd = np.any(col_numbers % 2 == 1)\n    has_even = np.any(col_numbers % 2 == 0)\n\n    return bool(has_odd and has_even)\n","name":"program_895","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there ships in A or B","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows A and B correspond to indices 0 and 1\n    rows = [0, 1]\n    # A ship tile is indicated by a value > 0 in true_board\n    # A tile is still hidden if partial_board == -1\n    # We want to know if there is any hidden ship tile in rows A or B\n    hidden_ships_in_A_or_B = (partial_board[rows] == -1) & (true_board[rows] > 0)\n    return np.any(hidden_ships_in_A_or_B)\n","name":"program_896","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"C or D?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows C and D correspond to indices 2 and 3\n    rows = [2, 3]\n    # We're looking for any ship tiles (true_board != 0) in those rows\n    # that are still hidden in the partial_board (partial_board == -1)\n    unrevealed_ships = (true_board[rows, :] != 0) & (partial_board[rows, :] == -1)\n    return bool(np.any(unrevealed_ships))\n","name":"program_897","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the purple ship vertical","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Locate all tiles of the purple ship (denoted by 3)\n    coords = np.argwhere(true_board == 3)\n    if coords.shape[0] == 0:\n        # No purple ship found (shouldn't happen in a valid game)\n        return False\n    # Extract the column indices of those tiles\n    cols = coords[:, 1]\n    # The ship is vertical if all column indices are the same\n    return np.all(cols == cols[0])\n","name":"program_898","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"E or F","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We interpret \"E or F\" as asking whether there is any hidden ship tile\n    # in row E (index 4) or row F (index 5).\n    for r in (4, 5):  # 0-based indices: A=0, B=1, \u2026, E=4, F=5\n        # Check if any cell in row r is a ship in true_board (>0)\n        # and is still hidden in partial_board (== -1).\n        if np.any((true_board[r] > 0) & (partial_board[r] == -1)):\n            return True\n    return False\n","name":"program_899","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship at C3","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map the row letter 'C' to index 2 and column '3' to index 2\n    row_idx = ord('C') - ord('A')\n    col_idx = int('3') - 1\n    # If the true board at (C,3) is nonzero, there's a ship there\n    return true_board[row_idx, col_idx] != 0\n","name":"program_900","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there ships in G or H","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in row G or row H of the board.\n    \"\"\"\n    # A ship tile is true_board > 0; unrevealed means partial_board == -1\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n    # Rows G and H correspond to indices 6 and 7 (0-based)\n    return bool(np.any(hidden_ships[6:8, :]))\n","name":"program_901","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"does the remaining ship touch one of the other ships?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # all ship IDs present on the true board (exclude 0 = water)\n    ship_ids = set(np.unique(true_board)) - {0}\n    \n    # find which ship still has hidden tiles\n    remaining_id = None\n    for sid in ship_ids:\n        # mask of positions belonging to this ship\n        ship_mask = (true_board == sid)\n        # if any of those positions are still hidden in partial_board,\n        # this is our remaining ship\n        if np.any(ship_mask & (partial_board == -1)):\n            remaining_id = sid\n            break\n    \n    # safety check\n    if remaining_id is None:\n        # nothing hidden \u2192 no remaining ship, so it cannot be touching\n        return False\n\n    # collect coordinates of the remaining ship\n    rem_coords = set(zip(*np.where(true_board == remaining_id)))\n    # collect coordinates of all other ships\n    other_coords = set(zip(*np.where((true_board != remaining_id) & (true_board > 0))))\n    \n    # for each tile of the remaining ship, see if an orthogonal neighbor\n    # belongs to another ship\n    for r, c in rem_coords:\n        for dr, dc in ((1,0), (-1,0), (0,1), (0,-1)):\n            if (r+dr, c+dc) in other_coords:\n                return True\n    \n    return False\n","name":"program_902","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"trigger happy lol, is there a ship in F6, F7, G6, or G7?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Check the four specified tiles: F6, F7, G6, G7\n    # Rows A\u2013H map to indices 0\u20137 via ord()\n    for row_letter in ['F', 'G']:\n        r = ord(row_letter) - ord('A')\n        for col in [6, 7]:\n            c = col - 1\n            # If the tile is still hidden and actually contains a ship, return True\n            if partial_board[r, c] == -1 and true_board[r, c] > 0:\n                return True\n    return False\n","name":"program_903","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship in the center 4 tiles, D4 through E5?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Rows D and E correspond to indices 3 and 4 (0-based)\n    # Columns 4 and 5 correspond to indices 3 and 4 (0-based)\n    r_start, r_end = 3, 5  # D (3) up to but not including F (5)\n    c_start, c_end = 3, 5  # 4 (3) up to but not including 6 (5)\n\n    # Extract the 2\u00d72 block D4\u2013D5\u2013E4\u2013E5\n    region_true = true_board[r_start:r_end, c_start:c_end]\n    region_partial = partial_board[r_start:r_end, c_start:c_end]\n\n    # A \u201cyes\u201d answer if any of those tiles hide a ship (value > 0)\n    # and have not already been revealed (partial_board == -1)\n    hidden_ships = (region_true > 0) & (region_partial == -1)\n    return bool(np.any(hidden_ships))\n","name":"program_904","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there any horizontal ships left?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Iterate over every ship ID present in the true board\n    for ship_id in np.unique(true_board):\n        # Skip water (0) and hidden (-1)\n        if ship_id <= 0:\n            continue\n        \n        # Find all the positions of this ship\n        coords = np.argwhere(true_board == ship_id)\n        \n        # Ships have length >= 2, so skip any singletons\n        if coords.shape[0] < 2:\n            continue\n        \n        # Determine orientation: horizontal if all in one row\n        rows = np.unique(coords[:, 0])\n        if rows.size == 1:\n            # Check if any part of this ship remains hidden\n            for r, c in coords:\n                if partial_board[r, c] == -1:\n                    return True\n    # No horizontal ship with unrevealed tiles was found\n    return False\n","name":"program_905","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it in either row c or e?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map rows C and E to their indices 2 and 4 (0-based)\n    rows = [ord('C') - ord('A'), ord('E') - ord('A')]\n    # A tile is an unrevealed ship part if partial_board is -1 and true_board > 0\n    unrevealed_ship = (partial_board == -1) & (true_board > 0)\n    # Check if any such tile lies in row C or row E\n    return bool(np.any(unrevealed_ship[rows, :]))\n","name":"program_906","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is this ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the ship that has been at least partly revealed on partial_board\n    is placed horizontally on the true_board.\n    \"\"\"\n    # 1. Find the coordinates of any revealed ship tile on the partial board.\n    #    Ship tiles are > 0 (0 is water, -1 is hidden).\n    hits = np.argwhere(partial_board > 0)\n    if hits.size == 0:\n        # No ship has been revealed yet; ambiguous question.\n        # By convention, return False.\n        return False\n\n    # 2. Identify which ship this is by looking up the ship ID on the true board\n    first_hit = tuple(hits[0])\n    ship_id = true_board[first_hit]\n\n    # 3. Get all coordinates of that ship on the true board\n    ship_cells = np.argwhere(true_board == ship_id)\n\n    # 4. Check orientation: if all row indices are the same, it's horizontal.\n    rows = ship_cells[:, 0]\n    is_horizontal = np.all(rows == rows[0])\n\n    return bool(is_horizontal)\n","name":"program_907","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Does it touch E4 or C4?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We want to know if there is any unrevealed ship tile\n    # at either C4 or E4.  Using 0-based indexing:\n    #   Row C \u2192 index 2, Row E \u2192 index 4\n    #   Column 4 \u2192 index 3\n    targets = [(2, 3),  # C4\n               (4, 3)]  # E4\n    for r, c in targets:\n        # true_board[r, c] > 0 means there's a ship part there\n        # partial_board[r, c] == -1 means it is still hidden\n        if true_board[r, c] > 0 and partial_board[r, c] == -1:\n            return True\n    return False\n","name":"program_908","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Ran out of space lol, is there a vertical ship in column 1 or 8?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # We only care about ship\u2010IDs > 0\n    ship_ids = np.unique(true_board)\n    for ship_id in ship_ids:\n        if ship_id <= 0:\n            continue\n\n        # find all the coordinates belonging to this ship\n        coords = np.argwhere(true_board == ship_id)\n        length = coords.shape[0]\n        # must be at least length 2 to be a \u201cship\u201d\n        if length < 2:\n            continue\n\n        # check if all columns are the same \u2192 vertical orientation\n        cols = coords[:,1]\n        if not np.all(cols == cols[0]):\n            continue\n\n        # is that column 1 or 8? (zero\u2010based 0 or 7)\n        c = cols[0]\n        if c not in (0, 7):\n            continue\n\n        # finally, check if any tile of that ship is still hidden\n        # (partial_board == -1 means hidden)\n        for (r, c) in coords:\n            if partial_board[r, c] == -1:\n                return True\n\n    # if we never found an in\u2010column\u20101\/8 vertical ship with hidden parts\n    return False\n","name":"program_909","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a horizontal ship in row H?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'H' to its zero\u2010based index (A\u21920, B\u21921, \u2026, H\u21927)\n    row_idx = ord('H') - ord('A')\n    \n    # We will look at each ship ID (1=Red, 2=Green, 3=Purple, 4=Orange)\n    for ship_id in [1, 2, 3, 4]:\n        # Find all the coordinates of this ship on the true board\n        coords = np.argwhere(true_board == ship_id)\n        if coords.size == 0:\n            # This ship isn't on the board at all\n            continue\n        \n        # Check if the ship is strictly horizontal:\n        # i.e. all of its tiles lie in the same row.\n        rows_of_ship = coords[:, 0]\n        if np.unique(rows_of_ship).size != 1:\n            # This ship is vertical or not purely in one row\n            continue\n        \n        # Check if that single row is row H\n        if rows_of_ship[0] != row_idx:\n            continue\n        \n        # Finally, see if any part of that ship in row H is still hidden\n        # (partial_board == -1 means hidden)\n        for r, c in coords:\n            if partial_board[r, c] == -1:\n                # We found at least one unrevealed tile of a horizontal ship in H\n                return True\n    \n    # No horizontal, unrevealed ship segments found in row H\n    return False\n","name":"program_910","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a horizontal ship in row a?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any horizontal ship segment in row A (index 0)\n    that forms part of a length-2-or-greater contiguous run of ship cells,\n    and at least one of those cells is still hidden on partial_board.\n    \"\"\"\n    # We interpret \"row A\" as the first row, index 0.\n    row_idx = 0\n    row = true_board[row_idx]\n    hidden_row = partial_board[row_idx]\n\n    run_indices = []\n    run_length = 0\n\n    # Scan across columns in row A\n    for col in range(row.size):\n        if row[col] > 0:\n            # We have a ship cell here\n            run_indices.append(col)\n            run_length += 1\n        else:\n            # End of a contiguous run; check if it qualifies\n            if run_length >= 2:\n                # If any of the run's positions is still hidden, count it\n                if any(hidden_row[c] == -1 for c in run_indices):\n                    return True\n            # Reset for the next possible run\n            run_indices = []\n            run_length = 0\n\n    # Final check in case the row ends in a run\n    if run_length >= 2:\n        if any(hidden_row[c] == -1 for c in run_indices):\n            return True\n\n    return False\n","name":"program_911","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"does the remaining ship touch another ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all ship IDs on the true board (exclude 0)\n    all_ships = set(np.unique(true_board)) - {0}\n    # Find which ship IDs have any revealed part on the partial board\n    revealed_ships = set(np.unique(partial_board)) - {-1, 0}\n    # The remaining ships are those not yet revealed at all\n    remaining = all_ships - revealed_ships\n\n    # Directions to check for adjacency (8 neighbors)\n    dirs = [(-1,-1), (-1,0), (-1,1),\n            ( 0,-1),         ( 0,1),\n            ( 1,-1), ( 1,0), ( 1,1)]\n    nrows, ncols = true_board.shape\n\n    for ship_id in remaining:\n        # Get coordinates of all tiles of this ship\n        positions = np.argwhere(true_board == ship_id)\n        for (r, c) in positions:\n            # Check each neighbor\n            for dr, dc in dirs:\n                rr, cc = r + dr, c + dc\n                if 0 <= rr < nrows and 0 <= cc < ncols:\n                    neighbor_id = true_board[rr, cc]\n                    # If neighbor is a different ship (>0 and not same id), they touch\n                    if neighbor_id > 0 and neighbor_id != ship_id:\n                        return True\n    # No touching found\n    return False\n","name":"program_912","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"does it touch row h?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify which ship has not been revealed at all (the \"remaining\" ship).\n    # Ships are labeled 1\u20134 in true_board (0 is water, -1 is hidden in partial_board).\n    ship_ids = np.unique(true_board)\n    ship_ids = ship_ids[(ship_ids > 0)]  # drop 0 and any negatives\n    \n    remaining = None\n    for sid in ship_ids:\n        # if the captain has never uncovered any tile of ship `sid`, it's the remaining one\n        if not np.any(partial_board == sid):\n            remaining = sid\n            break\n    \n    # If for some reason more than one or none qualify, fall back to\n    # \"any ship with hidden segments\" heuristic\n    if remaining is None:\n        for sid in ship_ids:\n            hidden_segments = (true_board == sid) & (partial_board == -1)\n            if np.any(hidden_segments):\n                remaining = sid\n                break\n    \n    # Now get the row indices of that ship's tiles\n    rows, cols = np.where(true_board == remaining)\n    \n    # Row H is index 7 (0-based). We ask: does any tile of the remaining ship\n    # lie immediately adjacent (vertically) to row 7?\n    # That is, is there any tile in row 6 whose neighbor below is row 7?\n    touches = np.any(rows + 1 == 7)\n    \n    return bool(touches)\n","name":"program_913","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it in the lower right quadrant?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is any unrevealed ship tile in the lower-right quadrant\n    of the board, otherwise False.\n    \"\"\"\n    # A tile is part of a ship if true_board > 0\n    ship_tiles = true_board > 0\n\n    # A tile has been revealed if partial_board > 0\n    revealed_tiles = partial_board > 0\n\n    # Unrevealed ship tiles are those that are on a ship in true_board but still hidden in partial_board\n    unrevealed_ships = ship_tiles & ~revealed_tiles\n\n    # Determine the midpoint of the board to split into quadrants\n    n_rows, n_cols = true_board.shape\n    mid_row = n_rows \/\/ 2   # rows 0..mid_row-1 are upper, mid_row..n_rows-1 are lower\n    mid_col = n_cols \/\/ 2   # cols 0..mid_col-1 are left, mid_col..n_cols-1 are right\n\n    # Extract the lower-right quadrant\n    lower_right = unrevealed_ships[mid_row:n_rows, mid_col:n_cols]\n\n    # If there's any True in that quadrant, then there is at least one unrevealed ship tile there\n    return bool(np.any(lower_right))\n","name":"program_914","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it in column 1?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in column 1 (index 0),\n    otherwise False.\n    \"\"\"\n    col = 0  # column 1 in 1-based indexing corresponds to index 0\n    # A tile counts if the true board has a ship (>0) and the partial board still hides it (-1)\n    unrevealed_ships_in_col1 = (true_board[:, col] > 0) & (partial_board[:, col] == -1)\n    return bool(np.any(unrevealed_ships_in_col1))\n","name":"program_915","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are all the ships same orientation (all horizontal or all vertical)?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether all ships on the true_board are oriented the same way:\n    either all horizontal or all vertical.\n    \n    Ships are identified by positive integers in true_board. Zero denotes water.\n    \"\"\"\n    orientations = []\n    \n    # Look at each ship type present on the true board\n    for ship_id in np.unique(true_board):\n        if ship_id <= 0:\n            # skip water and hidden markers\n            continue\n        \n        # find the coordinates of this ship's tiles\n        coords = np.argwhere(true_board == ship_id)\n        if coords.shape[0] <= 1:\n            # If there's only one tile (edge case), skip it\n            continue\n        \n        rows = coords[:, 0]\n        cols = coords[:, 1]\n        \n        if np.all(rows == rows[0]):\n            # all row indices equal \u2192 horizontal ship\n            orientations.append('H')\n        elif np.all(cols == cols[0]):\n            # all column indices equal \u2192 vertical ship\n            orientations.append('V')\n        else:\n            # irregular placement (shouldn't happen in valid Battleship)\n            # treat as neither\n            orientations.append('N')\n    \n    # If there are no properly oriented ships or only one orientation, return True\n    unique_orients = set(orientations)\n    # discard any 'N' markers before comparison\n    unique_orients.discard('N')\n    return len(unique_orients) <= 1\n","name":"program_916","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there ships in all 4 quadrants?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Return True if there is at least one *hidden* ship tile in each of the\n    four 4x4 quadrants of the board, False otherwise.\n    \n    Quadrant layout on an 8x8 grid (0-based indexing):\n      - Q1: rows 0\u20133, cols 0\u20133 (top-left)\n      - Q2: rows 0\u20133, cols 4\u20137 (top-right)\n      - Q3: rows 4\u20137, cols 0\u20133 (bottom-left)\n      - Q4: rows 4\u20137, cols 4\u20137 (bottom-right)\n    \n    We only count a ship tile as \u201cpresent\u201d if it is still hidden\n    (i.e. true_board > 0 and partial_board == -1).\n    \"\"\"\n    # mask of hidden ship tiles\n    hidden_ships = (true_board > 0) & (partial_board == -1)\n    \n    # define the slices for the four quadrants\n    quads = [\n        (slice(0,4), slice(0,4)),  # Q1\n        (slice(0,4), slice(4,8)),  # Q2\n        (slice(4,8), slice(0,4)),  # Q3\n        (slice(4,8), slice(4,8)),  # Q4\n    ]\n    \n    # check each quadrant for at least one hidden ship tile\n    return all(np.any(hidden_ships[rng_rows, rng_cols]) for rng_rows, rng_cols in quads)\n","name":"program_917","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship in row F","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Row F corresponds to index 5 (0-based: A=0, B=1, \u2026, F=5)\n    row_idx = 5\n    \n    # We answer \"Yes\" if there's at least one hidden tile in row F that is actually a ship.\n    # In partial_board, hidden tiles are marked -1; in true_board, ship tiles are > 0.\n    hidden_in_F = (partial_board[row_idx, :] == -1)\n    ship_in_F   = (true_board[row_idx, :] > 0)\n    \n    return np.any(hidden_in_F & ship_in_F)\n","name":"program_918","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there ships in any of the four center squares D4 D5 E4 E5","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile\n    in any of the four center squares D4, D5, E4, E5.\n    Otherwise returns False.\n    \"\"\"\n    # In zero-based indexing: D\u21923, E\u21924; columns 4\u21923, 5\u21924\n    center_true = true_board[3:5, 3:5]\n    center_partial = partial_board[3:5, 3:5]\n    \n    # A tile is an unrevealed ship if true_board > 0 and partial_board is still hidden (-1)\n    unrevealed_ships = (center_true > 0) & (center_partial == -1)\n    return bool(np.any(unrevealed_ships))\n","name":"program_919","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"does it touch either right side or left side","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # The Captain just asked about the ship that has at least one hidden segment in row F.\n    # Compute the index for row 'F' (A=0, B=1, ..., H=7).\n    row_idx = ord('F') - ord('A')\n    \n    # Find all ship IDs that have at least one hidden cell in that row.\n    # A hidden cell is indicated by partial_board == -1, and a ship cell by true_board > 0.\n    hidden_in_row = (partial_board[row_idx, :] == -1) & (true_board[row_idx, :] > 0)\n    ship_ids = np.unique(true_board[row_idx, hidden_in_row])\n    \n    # If no ship is still hidden in row F, the answer is False.\n    if ship_ids.size == 0:\n        return False\n    \n    # For each such ship, check if any of its segments lie in the leftmost or rightmost column.\n    n_cols = true_board.shape[1]\n    for sid in ship_ids:\n        if sid == 0:\n            continue\n        coords = np.argwhere(true_board == sid)\n        cols = coords[:, 1]\n        # Check if any column index is 0 (left edge) or n_cols-1 (right edge).\n        if np.any((cols == 0) | (cols == n_cols - 1)):\n            return True\n    \n    # If none of those ships touch the left or right edge, answer False.\n    return False\n","name":"program_920","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"E5?","solution":"\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Convert row letter 'E' to index 4, column '5' to index 4\n    row = ord('E') - ord('A')\n    col = 5 - 1\n    # Return True if there's a ship (value > 0) at E5, False otherwise\n    return true_board[row, col] > 0\n","name":"program_921","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is this ship horizontal","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all revealed ship\u2010hit coordinates on the partial board\n    # (partial_board > 0 indicates a revealed ship tile)\n    hits = np.argwhere(partial_board > 0)\n    \n    if hits.size == 0:\n        # No hits have been revealed yet; we cannot determine orientation\n        return False\n    \n    # Assume the Captain is asking about the ship that was just hit.\n    # All hits on that ship share the same ship ID.\n    # Grab the ship ID from the first hit location.\n    r0, c0 = hits[0]\n    ship_id = true_board[r0, c0]\n    \n    # Find all coordinates of that ship on the true board\n    ship_coords = np.argwhere(true_board == ship_id)\n    \n    # Extract row and column indices\n    rows = ship_coords[:, 0]\n    cols = ship_coords[:, 1]\n    \n    # The ship is horizontal if all of its row indices are the same\n    return np.all(rows == rows[0])\n","name":"program_922","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the last ship in row H","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Identify all ship labels on the true board (values > 0)\n    all_ships = np.unique(true_board[true_board > 0])\n    \n    # Identify which ship labels have already been hit (appear in partial_board as > 0)\n    hit_ships = np.unique(partial_board[partial_board > 0])\n    \n    # The \"last\" ship is one that appears on the true board but has no hits yet\n    remaining = [s for s in all_ships if s not in hit_ships]\n    \n    # If there's not exactly one completely untouched ship, we cannot answer \"yes\"\n    if len(remaining) != 1:\n        return False\n    \n    last_ship = remaining[0]\n    \n    # Find the row indices of all tiles of that last ship\n    ship_rows, _ = np.where(true_board == last_ship)\n    \n    # Check whether *all* of those tiles lie in row H (index 7)\n    return np.all(ship_rows == 7)\n","name":"program_923","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"does the last ship touch the green ship","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # 1) Determine which ship IDs have already been revealed\n    #    (i.e. appear in partial_board as > 0).\n    revealed_ids = set(np.unique(partial_board[partial_board > 0]))\n    \n    # 2) All possible ship IDs in this variant are 1,2,3,4.\n    all_ship_ids = {1, 2, 3, 4}\n    \n    # 3) The \"last ship\" is the one ID not yet in revealed_ids.\n    last_id = (all_ship_ids - revealed_ids).pop()\n    \n    # 4) Find the coordinates of the last ship and of the green ship (ID=2).\n    last_locs = np.argwhere(true_board == last_id)\n    green_locs = np.argwhere(true_board == 2)\n    \n    # 5) For each tile of the last ship, check all 8 neighbors\n    #    to see if any neighbor is a green\u2010ship tile.\n    for (r_last, c_last) in last_locs:\n        # build a small 3\u00d73 window around (r_last, c_last)\n        r0, r1 = r_last - 1, r_last + 1\n        c0, c1 = c_last - 1, c_last + 1\n        \n        # clip to the board bounds [0..7]\n        r0 = max(r0, 0)\n        c0 = max(c0, 0)\n        r1 = min(r1, true_board.shape[0] - 1)\n        c1 = min(c1, true_board.shape[1] - 1)\n        \n        # extract that window from true_board\n        window = true_board[r0:r1+1, c0:c1+1]\n        \n        # if any of those cells is 2 (green), they touch\n        if np.any(window == 2):\n            return True\n    \n    # if we never found an adjacency, they do not touch\n    return False\n","name":"program_924","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"are there other ships in this upper right quadrant?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Define the indices for the upper-right quadrant:\n    # Rows A-D correspond to indices 0-3, columns 5-8 correspond to indices 4-7.\n    rows = slice(0, 4)\n    cols = slice(4, 8)\n    \n    # Extract the quadrant from both boards\n    true_sub = true_board[rows, cols]\n    partial_sub = partial_board[rows, cols]\n    \n    # A tile contains an unrevealed ship if in true_board it's > 0 (a ship)\n    # and in partial_board it's still -1 (hidden).\n    unrevealed_ships = (true_sub > 0) & (partial_sub == -1)\n    \n    # If any such tile exists, the answer is True, otherwise False.\n    return bool(np.any(unrevealed_ships))\n","name":"program_925","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"do any other ships touch this one?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether any other ship (i.e. a ship with a different id) \n    touches the currently revealed ship on partial_board.\n    We consider all 8-directional neighbors as \"touching.\"\n    \"\"\"\n    # 1) Identify the ship id that has been hit on the partial board.\n    #    We assume there's exactly one partially revealed ship of interest.\n    #    Hits are marked by 1,2,3,4 on partial_board (water is 0, hidden is -1).\n    ship_ids = np.unique(partial_board[(partial_board > 0)])\n    if ship_ids.size == 0:\n        # No ship has been hit yet\n        return False\n\n    # In normal play there's only one partially uncovered ship under question.\n    ship_id = ship_ids[0]\n\n    # 2) Find the coordinates of all revealed tiles of that ship.\n    #    These are the tiles in partial_board == ship_id.\n    hit_positions = np.argwhere(partial_board == ship_id)\n\n    # 3) For each revealed tile, check its 8 neighbors in true_board.\n    #    If any neighbor holds a ship id > 0 and != ship_id, they touch.\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  ( 0, -1),          ( 0, 1),\n                  ( 1, -1), ( 1, 0), ( 1, 1)]\n    nrows, ncols = true_board.shape\n\n    for (r, c) in hit_positions:\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            # stay in bounds\n            if 0 <= nr < nrows and 0 <= nc < ncols:\n                neighbor_val = true_board[nr, nc]\n                # if there's a different ship at that neighbor, they touch\n                if neighbor_val > 0 and neighbor_val != ship_id:\n                    return True\n\n    # If we found no touching ships, answer is False\n    return False\n","name":"program_926","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"C4?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letter 'C' to index 2 (0-based), column 4 to index 3 (0-based)\n    row = ord('C') - ord('A')  \n    col = 4 - 1               \n    # Return True if there's a ship on the true board at C4, False otherwise\n    return true_board[row, col] > 0\n","name":"program_927","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it in row E","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if there is at least one unrevealed ship tile in row E,\n    i.e. any position in row 4 (0\u2010indexed) where true_board has a ship (>0)\n    and partial_board is still hidden (-1).\n    \"\"\"\n    # Row E corresponds to index 4 (0-indexed since row A is index 0)\n    row_idx = 4\n\n    # Mask of ship tiles in the true board on row E\n    ships_in_E = true_board[row_idx, :] > 0\n\n    # Mask of hidden tiles in the partial board on row E\n    hidden_in_E = partial_board[row_idx, :] == -1\n\n    # If any position in row E is both a ship in true_board and hidden in partial_board,\n    # then the answer to \"is it in row E?\" is True.\n    return bool(np.any(ships_in_E & hidden_in_E))\n","name":"program_928","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is this ship vertical","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all revealed ship\u2010ids on the partial board\n    revealed = partial_board[partial_board > 0]\n    # If nothing revealed, we cannot answer\n    if revealed.size == 0:\n        return False\n    # Count how many times each ship\u2010id appears\n    ship_ids, counts = np.unique(revealed, return_counts=True)\n    # Assume \"this ship\" is the one with the fewest revealed hits\n    i = np.argmin(counts)\n    current_ship_id = ship_ids[i]\n    # Get all true\u2010board coordinates of that ship\n    coords = np.argwhere(true_board == current_ship_id)  # array of [row, col]\n    # Extract columns\n    cols = coords[:, 1]\n    # It's vertical iff all columns are identical\n    return bool(np.all(cols == cols[0]))\n","name":"program_929","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a ship in the center? D4, D5, E4, E5?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Checks whether any of the four center tiles (D4, D5, E4, E5)\n    contains a ship that has not yet been revealed.\n    \"\"\"\n    # Define the target coordinates\n    # 'D' -> row index 3, 'E' -> row index 4; columns are 1-based so subtract 1\n    centers = [(\"D\", 4), (\"D\", 5), (\"E\", 4), (\"E\", 5)]\n    \n    for row_letter, col_num in centers:\n        i = ord(row_letter) - ord('A')   # Convert 'A'..'H' to 0..7\n        j = col_num - 1                  # Convert 1..8 to 0..7\n        # true_board[i, j] > 0 means there's a ship segment\n        # partial_board[i, j] == -1 means it's still hidden\n        if true_board[i, j] > 0 and partial_board[i, j] == -1:\n            return True  # Yes, an unrevealed ship segment is in the center\n    \n    return False  # No unrevealed ship segments among D4, D5, E4, E5\n","name":"program_930","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is it in E5\/D4?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Define the two coordinates we care about: E5 and D4\n    coords = [(\"E\", 5), (\"D\", 4)]\n    for row_letter, col_num in coords:\n        # Convert row letter to zero-based index (A->0, B->1, ..., H->7)\n        r = ord(row_letter) - ord(\"A\")\n        # Convert column number to zero-based index\n        c = col_num - 1\n        # If there's a ship at (r, c) in true_board and it's still hidden in partial_board\n        if true_board[r, c] > 0 and partial_board[r, c] == -1:\n            return True\n    return False\n","name":"program_931","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is the last ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the as\u2010yet unrevealed ship (i.e., the ship\n    with any remaining hidden tiles) lies wholly in a single row\n    (horizontal), False otherwise.\n    \"\"\"\n    # Find all coordinates where there's a ship on the true board\n    # but that tile is still hidden in the partial board.\n    mask_unseen_ship = (true_board > 0) & (partial_board == -1)\n    rows, cols = np.where(mask_unseen_ship)\n    \n    # If there's zero or one tile left, we cannot say it's horizontal\n    if len(rows) <= 1:\n        return False\n    \n    # If all remaining unseen ship tiles share the same row index,\n    # the ship is horizontal.\n    return bool(np.all(rows == rows[0]))\n","name":"program_932","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is this ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find which ship ID has at least one revealed tile in partial_board\n    # (exclude water (0) and hidden (-1))\n    revealed_ids = set(np.unique(partial_board)) - {0, -1}\n    if len(revealed_ids) != 1:\n        # If there's no single clear target ship, we cannot assert vertical orientation.\n        return False\n\n    ship_id = revealed_ids.pop()\n    # Get all the coordinates of that ship in the true_board\n    coords = np.argwhere(true_board == ship_id)\n    if coords.size == 0:\n        # No such ship on the true board (shouldn't happen in a valid game)\n        return False\n\n    # Compute span in rows vs. span in columns\n    row_span = coords[:, 0].max() - coords[:, 0].min()\n    col_span = coords[:, 1].max() - coords[:, 1].min()\n\n    # It's vertical if it extends more in the row direction than in the column direction\n    return row_span > col_span\n","name":"program_933","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is it in row g?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row 'G' to a 0-based index (A\u21920, B\u21921, \u2026, H\u21927)\n    row_idx = ord('G') - ord('A')\n    # Extract that row from both boards\n    true_row = true_board[row_idx, :]\n    partial_row = partial_board[row_idx, :]\n    # An unrevealed ship tile is one where true_board > 0 but partial_board == -1\n    unrevealed_ship_tiles = (true_row > 0) & (partial_row == -1)\n    # If any such tile exists in row G, answer yes (True), otherwise no (False)\n    return bool(unrevealed_ship_tiles.any())\n","name":"program_934","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Does it start in either G 8 or G1?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Determine whether the remaining (undiscovered) ship starts at G1 or G8.\n    We identify the ship type that still has hidden tiles by comparing true_board\n    to partial_board, collect its full set of coordinates, infer its orientation,\n    compute its 'starting' tile (leftmost if horizontal, topmost if vertical),\n    and then check if that start is either G1 or G8.\n    \"\"\"\n    # Step 1: find which ship type still has unrevealed tiles\n    undiscovered_type = None\n    for ship_type in (1, 2, 3, 4):\n        # mask of where this ship actually is\n        true_mask = (true_board == ship_type)\n        # mask of where the captain has already revealed this ship\n        seen_mask = (partial_board == ship_type)\n        # if there exist true tiles of this type that haven't been revealed, it's our ship\n        if np.any(true_mask & ~seen_mask):\n            undiscovered_type = ship_type\n            break\n\n    if undiscovered_type is None:\n        # no undiscovered ship \u2192 default to False\n        return False\n\n    # Step 2: get all coordinates of that ship\n    ship_coords = np.argwhere(true_board == undiscovered_type)\n    rows = ship_coords[:, 0]\n    cols = ship_coords[:, 1]\n\n    # Step 3: determine orientation and compute the \"start\" coordinate\n    # Horizontal \u2192 start is the leftmost cell (min column)\n    # Vertical   \u2192 start is the topmost cell (min row)\n    if np.all(rows == rows[0]):\n        # horizontal\n        start = (rows[0], int(np.min(cols)))\n    else:\n        # vertical\n        start = (int(np.min(rows)), cols[0])\n\n    # Step 4: map G1 and G8 to zero\u2010based indices\n    target_row = ord('G') - ord('A')  # G \u2192 6\n    g1 = (target_row, 0)\n    g8 = (target_row, 7)\n\n    # Return True if the ship's start matches either G1 or G8\n    return start == g1 or start == g8\n","name":"program_935","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"g2?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # The Captain is asking about G2.\n    # Rows A\u2013H map to indices 0\u20137, so G \u2192 6. Columns 1\u20138 map to 0\u20137, so 2 \u2192 1.\n    row, col = 6, 1\n    # Return True if there's a ship on the true board at G2 (i.e. value > 0), False otherwise.\n    return true_board[row, col] > 0\n","name":"program_936","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"is there a ship in B6, B7, C6, C7?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Coordinates for B6, B7, C6, C7 in 0\u2010based indexing\n    targets = [(1, 5), (1, 6), (2, 5), (2, 6)]\n    # If any of these tiles is still hidden on partial_board\n    # but contains a ship on true_board, return True\n    for r, c in targets:\n        if partial_board[r, c] == -1 and true_board[r, c] > 0:\n            return True\n    return False\n","name":"program_937","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"does this ship touch the red ship?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # 1) Find the \"incomplete\" ship ID in partial_board\n    #    (one that has some hits but not all its true cells yet revealed):\n    ship_ids = set(np.unique(true_board)) - {0}   # ignore water\n    target_id = None\n    for sid in ship_ids:\n        # how many of that ship are revealed so far?\n        seen = np.count_nonzero(partial_board == sid)\n        total = np.count_nonzero(true_board    == sid)\n        if 0 < seen < total:\n            target_id = sid\n            break\n    # if we never found a partially\u2010discovered ship, question doesn't apply\n    if target_id is None:\n        return False\n\n    # 2) Collect all true\u2010coordinates of that ship and of the red ship (ID=1)\n    tgt_pos = np.argwhere(true_board == target_id)\n    red_pos = set(map(tuple, np.argwhere(true_board == 1)))\n\n    # 3) For each true\u2010cell of target ship, check all 8 neighbors for a red cell\n    H, W = true_board.shape\n    for (r, c) in tgt_pos:\n        for dr in (-1, 0, +1):\n            for dc in (-1, 0, +1):\n                if dr == 0 and dc == 0:\n                    continue\n                rr, cc = r + dr, c + dc\n                if 0 <= rr < H and 0 <= cc < W and (rr, cc) in red_pos:\n                    return True\n\n    return False\n","name":"program_938","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the green ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the green ship (denoted by 2)\n    green_positions = np.argwhere(true_board == 2)\n    if green_positions.size == 0:\n        # No green ship found; default to False\n        return False\n    # green is vertical if all column indices are the same\n    cols = green_positions[:, 1]\n    return bool(np.all(cols == cols[0]))\n","name":"program_939","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the green ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the green ship (marked with 2) is placed vertically on the true_board,\n    i.e., all of its tiles share the same column index.\n    \"\"\"\n    # Find the row and column indices of all green ship tiles\n    green_rows, green_cols = np.where(true_board == 2)\n    \n    # If there are no green tiles, we cannot say it's vertical\n    if green_rows.size == 0:\n        return False\n    \n    # The green ship is vertical if all its column indices are the same\n    return np.all(green_cols == green_cols[0])\n","name":"program_940","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the orange ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the orange ship (denoted by 4)\n    orange_coords = np.argwhere(true_board == 4)\n    \n    # If all row indices are the same, the ship is horizontal\n    unique_rows = np.unique(orange_coords[:, 0])\n    return unique_rows.size == 1\n","name":"program_941","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the green ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the green ship (marked with 2)\n    green_positions = np.argwhere(true_board == 2)\n    \n    # If there are no green tiles or only one tile, we cannot say it's horizontal\n    if green_positions.shape[0] <= 1:\n        return False\n    \n    # Extract row indices and column indices\n    rows = green_positions[:, 0]\n    cols = green_positions[:, 1]\n    \n    # The ship is horizontal if all row indices are the same\n    return np.all(rows == rows[0])\n","name":"program_942","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is there a piece of the red ship in letter C?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Map row letters A\u2013H to indices 0\u20137\n    row_idx = ord('C') - ord('A')\n    # Check for any red ship piece (1) in row C that is still hidden (-1)\n    hidden_red_in_C = (true_board[row_idx] == 1) & (partial_board[row_idx] == -1)\n    return bool(np.any(hidden_red_in_C))\n","name":"program_943","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the red ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all the coordinates of the red ship (value == 1) in the true board\n    red_coords = np.argwhere(true_board == 1)\n    \n    # Extract the column indices of those coordinates\n    red_cols = red_coords[:, 1]\n    \n    # If all red ship squares share the same column index, it's vertical\n    return np.unique(red_cols).size == 1\n","name":"program_944","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the orange ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the orange ship (encoded as 4)\n    coords = np.argwhere(true_board == 4)\n    if coords.size == 0:\n        # No orange ship found (shouldn't happen in a valid game), say No\n        return False\n\n    # Separate into row indices and column indices\n    rows = coords[:, 0]\n    cols = coords[:, 1]\n\n    # If all row indices are the same, it's horizontal; otherwise vertical\n    return np.all(rows == rows[0])\n","name":"program_945","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the purple ship horizontal?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    # Find all coordinates of the purple ship (denoted by 3)\n    coords = np.argwhere(true_board == 3)\n    if coords.size == 0:\n        # No purple ship found (should not happen in a valid game)\n        return False\n    # Extract row indices and column indices\n    rows = coords[:, 0]\n    cols = coords[:, 1]\n    # If all row indices are the same, the ship is horizontal\n    return np.all(rows == rows[0])\n","name":"program_946","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
{"description":"Is the red ship vertical?","solution":"\nimport numpy as np\n\ndef answer(true_board: np.ndarray, partial_board: np.ndarray) -> bool:\n    \"\"\"\n    Returns True if the red ship (value 1 in true_board) is oriented vertically,\n    False otherwise.\n    \"\"\"\n    # Find all positions of the red ship (value == 1)\n    positions = np.argwhere(true_board == 1)\n    # If there are fewer than 2 tiles, it can't form a vertical ship in the usual sense\n    if positions.shape[0] < 2:\n        return False\n    # Extract the column indices of those positions\n    cols = positions[:, 1]\n    # The ship is vertical if all column indices are the same\n    return np.all(cols == cols[0])\n","name":"program_947","public_tests":{"input":[],"output":[]},"private_tests":{"input":[],"output":[]}}
